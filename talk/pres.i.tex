\documentclass[fleqn]{beamer}

%
% TODO
%   Slide 2: Erklärung an Besipielgraph, weniger formal
%   Slide 3: Weniger formal, intuition von res-graph
%        "-->" überladen. Farbkodierung?
%         Klar machen dass res-graph eine Funktion von c und f ist!
%
%  Slide 7: \vfill vs vspace einheitlich. \vspace springt rum, \vfill: Zu weit unten
%  Slide 15: Farben für box/circle markers in Diagramm.
%


\mode<presentation>
{
  \usetheme{default}
%   \useinnertheme[shadow=true]{rounded}

  \useinnertheme{circles}
  
%    \useoutertheme{infolines}
  % or ...
  \setbeamersize{text margin left=1em,text margin right=1em}

%   \setbeamercovered{transparent}
  % or whatever (possibly just delete it)

  \beamertemplatenavigationsymbolsempty
  
% Display frame numbers in footline
  \setbeamertemplate{footline}[frame number]
}

\usepackage{etex}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
% \usepackage{amsthm}
% \usepackage{stmaryrd}
\usepackage{times}
\usepackage{mathpartir}

\usepackage{centernot}

\usepackage{colortbl}
\usepackage{multirow}

\usepackage[purexy]{qsymbols}
\usepackage{graphicx}

\usepackage{listings}
\usepackage{lstautogobble}

\usepackage{ifthen}
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{scopes}
\usetikzlibrary{decorations}
  \usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{arrows}
\usetikzlibrary{automata}
\usetikzlibrary{positioning}
\usetikzlibrary{chains}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.callouts}
\usetikzlibrary{shapes.misc}
\usetikzlibrary{fit}
\usetikzlibrary{calc}
\usepackage{pgfplots}

% \tikzstyle{stack}=[inner sep=0pt,minimum size=2mm]
% \tikzstyle{ssline}=[->,snake=snake,segment amplitude=.2mm,segment length=3mm,line after snake=1mm]
% \tikzstyle{fgnode}=[circle,draw,inner sep=0pt,minimum size=2mm]


\usepackage{packages/isabelle}
\usepackage{packages/isabelletags}
\usepackage{packages/isabellesym}
\usepackage{packages/comment}

% \isabellestyle{it}

\def\isachardoublequote{}%
\def\isachardoublequoteopen{}%
\def\isachardoublequoteclose{}%

\newcommand{\isainnerkeyword}[1]{{\textbf{#1}}}
\newcommand{\isasymexistsA}{\isamath{\exists_{\textsc A}\,}}

\def\isadelimproof{}
\def\endisadelimproof{}
\def\isatagproof{}
\def\endisatagproof{}
\def\isafoldproof{}
\def\isadelimproof{}
\def\endisadelimproof{}

\def\isastylescript{\sl}%


\input{lstisabelle}
\newcommand\Until{}
\input{macros}

\newcommand{\eqdef}{\mathrel{{=}_{def}}}
\newcommand{\iffdef}{\mathrel{{\mathord{\iff}\!\!}_{def}}}


\makeatletter
\newcommand*{\overlaynumber}{\number\beamer@slideinframe}
\makeatother

\AtBeginSection[] % Do nothing for \section*
{
  \begin{frame}<beamer>
    \frametitle{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}


\title{Formalizing the Edmonds-Karp Algorithm}

% \subtitle
% {Subtitle} % (optional)

\author[Peter Lammich]{\underline{Peter Lammich} and S.~Reza Sefidgar}
% - Use the \inst{?} command only if the authors have different
%   affiliation.

\institute[TUM] % (optional, but mostly needed)
{ TU M\"unchen %, Institut f\"ur Informatik, Chair for Logic and Verification
}
% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

\date {August 2016}
% {2008-12-01}


% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=0.5cm]{university-logo}{university-logo-filename}
% \logo{\pgfuseimage{university-logo}}


% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

%\beamerdefaultoverlayspecification{<+->}

%\mathchardef\-="2D
%\renewcommand\-{\text{-}}

\newcommand{\mc}{\color{blue}}
\newcommand{\term}[1]{{\mc#1}}

\let\olddisplaystyle\displaystyle
\newcommand{\mydisplaystyle}{\olddisplaystyle\mc}
\let\displaystyle\mydisplaystyle

\newcommand{\smc}{\everymath{\mc}}
\smc

% \newcommand<>{\btikzset}[2]{\alt#3{\tikzset{#1}}{\tikzset{#2}}}

\tikzset{onslide/.code args={<#1>#2}{%
  \only<#1>{\pgfkeysalso{#2}} % \pgfkeysalso doesn't change the path
}}

\tikzset{>=latex}


\lstset{autogobble}

\newcommand{\natN}{{\text{nat}_{\mathord{<}N}}}

\newcommand{\edge}[1]{\stackrel{#1}{\longrightarrow}}


\definecolor{capacity}{rgb}{0,0,0}
\definecolor{flow}{rgb}{0,0,.7}
\definecolor{parval}{rgb}{0,.6,0}
\definecolor{aparval}{rgb}{.6,0,0}


\begin{document}
% \input{macros}

\begin{frame}
  \titlepage
\end{frame}

{

  \def\basicnet{
    \tikzstyle{nd}=[shape=circle,draw, minimum size = 5mm]
    \node[nd] (s) {s};
    \node[nd] (a) [above right of = s] {a};
    \node[nd] (b) [below right of = s] {b};
    \node[nd] (c) [right of = a] {c};
    \node[nd] (d) [right of = b] {d};
    \node[nd] (t) [below right of = c] {t};
  }
  \def\capedges{
    \tikzstyle{lab}=[text=capacity]
    \draw[->] (s) to node[lab] {3} (a);
    \draw[->] (s) to node[lab] {5} (b);
    \draw[->] (a) to node[lab] {6} (c);
    \draw[->] (b) to node[lab] {3} (d);
    \draw[->] (c) to node[lab] {4} (t);
    \draw[->] (d) to node[lab] {4} (t);

    \draw[->] (a) to node[lab] {3} (d);
  }
  \def\flowa{
    \draw[dflow,line width = 3pt] (s) to node[flow] {3} (a);
    \draw[dflow,line width = 3pt] (a) to node[flow] {3} (d);
    \draw[dflow,line width = 3pt] (d) to node[flow] {3} (t);
  }
  \def\augpatha{
    \draw[aug] (s) to (b);
    \draw[aug] (b) to (d);
    \draw[aug] (d) to (t);
  }
  \def\flowb{
    \draw[dflow,line width = 3pt] (s) to node[flow] {3} (a);
    \draw[dflow,line width = 3pt] (a) to node[flow] {3} (d);
    \draw[dflow,line width = 4pt] (d) to node[flow] {4} (t);
    \draw[dflow,line width = 1pt] (s) to node[flow] {1} (b);
    \draw[dflow,line width = 1pt] (b) to node[flow] {1} (d);
  }
  \def\augpathb{
    \draw[aug] (s) to (b);
    \draw[aug] (b) to (d);
    \draw[aug] (d) to (a);
    \draw[aug] (a) to (c);
    \draw[aug] (c) to (t);
  }
  \def\flowc{
    \draw[dflow,line width = 3pt] (s) to node[flow] {3} (a);
    \draw[dflow,line width = 1pt] (a) to node[flow] {1} (d);
    \draw[dflow,line width = 4pt] (d) to node[flow] {4} (t);
    \draw[dflow,line width = 3pt] (s) to node[flow] {3} (b);
    \draw[dflow,line width = 3pt] (b) to node[flow] {3} (d);

    \draw[dflow,line width = 2pt] (a) to node[flow] {2} (c);
    \draw[dflow,line width = 2pt] (c) to node[flow] {2} (t);
  }


# Flow Networks
  \begin{minipage}{.49\textwidth}
  \begin{tikzpicture}[node distance = 2cm, auto]
    \tikzstyle{flow}=[text=flow,swap]
    \tikzstyle{dflow}=[color=flow, draw opacity=.5]
    \tikzstyle{aug}=[color=red, draw opacity=.5, line width = 2pt]

    \basicnet
    \capedges
    
    \only<2>{\flowa}
    \only<3>{\flowa\augpatha}
    
    \only<4>{\flowb}
    \only<5>{\flowb\augpathb}
    
    \only<6>{\flowc}
  \end{tikzpicture}
  \end{minipage}
  \begin{minipage}{.49\textwidth}
    *<1-> Digraph with capacities
      * Source (s) and sink (t)
    *<2-> Flow from s to t
      * Not exceeding capacities
      * Inflow = outflow (except s,t)
    *<3-> Finding maximum flow
      * Incr.\ along augmenting path
    *<5-> May need to take back flow
      * To increase overall value
    *<6-> Flow is maximal now
  
  \end{minipage}

\def\resgraph{
    \draw[resgp, bend left] (s) to node[resgp] {4} (b);
    \draw[resga, bend left] (b) to node[resga] {1} (s);
    \draw[resga] (a) to node[resga] {3} (s);
    \draw[resgp] (a) to node[resgp] {6} (c);
    \draw[resgp] (c) to node[resgp] {4} (t);
    \draw[resgp, bend left] (b) to node[resgp] {2} (d);
    \draw[resga, bend left] (d) to node[resgp] {1} (b);
    \draw[resga] (t) to node[resga] {4} (d);
    \draw[resga] (d) to node[resga] {3} (a);
}

\def\augpathres{
  \draw[aug, bend left] (s) to (b);
  \draw[aug, bend left] (b) to (d);
  \draw[aug] (d) to (a);
  \draw[aug] (a) to (c);
  \draw[aug] (c) to (t);
}


# Residual Graph 
  {of Network and Flow}
  *<1-> Flow that can be moved between nodes
    * By \textcolor{parval}{increasing} or \textcolor{aparval}{taking back} flow
  *<2-> Augmenting path: s-t path in residual graph  

  \begin{tikzpicture}[node distance = 2cm, auto]
    \tikzstyle{flow}=[text=flow,swap]
    \tikzstyle{dflow}=[color=flow, draw opacity=.5]
    \tikzstyle{aug}=[color=red, draw opacity=.5, line width = 2pt]
    \tikzstyle{resgp}=[->,color=parval,text=parval]
    \tikzstyle{resga}=[->,color=aparval,text=aparval]

    \basicnet
    \resgraph
    
    \only<2>{\augpathres}
    
  \end{tikzpicture}
    
}  

%   
% # Maximum Flow Problem
%   *<+-> Network: digraph with edge capacities and source/sink nodes
%   *<+-> Flow: from source to sink, not exceeding capacities
%     * Kirchhoff's law: inflow = outflow for all nodes but source/sink
%     * No inflow to source, no outflow from sink
%     * Value: flow transported from source to sink (=Outflow of source)
%   *<+-> Problem: given a network, find a flow with maximum value
% 
% # Min-Cut/Max-Flow Theorem
%   *<+-> Consider network with flow
%     * No antiparallel edges: $u\edge{} v \implies v\centernot{\edge{}} u$
%   *<+-> Residual graph
%     * Intuition: flow that can be moved between nodes
%       * By either increasing or decreasing flow on network edge
%     * For network edge $u\edge{c,f} v$, residual graph has edges\\[1em]
%       ~~~$u\edge{c-f} v$ and $v\edge{f} u$\\[1em]
%   *<+-> Min-Cut/Max-Flow Theorem
%     * Value of minimal cut = value of maximum flow
%     * Corollary: maximum flow iff no source--sink path in residual graph

#! Ford-Fulkerson Method
  *<+-> Theorem: Flow is maximal iff there is no augmenting path.
    * Corollary of Min-Cut/Max-Flow theorem
  *<+-> Greedy algorithm to compute maximum flow
    \begin{lstlisting}
      set flow to zero
      while exists augmenting path
        augment flow along path
    \end{lstlisting}%
  *<+-> Partial correctness: obvious
  *<+-> Termination: only for integer/rational capacities
  *<+-> Edmonds/Karp: choose shortest augmenting path
    * $O(VE)$ iterations for real-valued capacities
    * Using BFS to find path: $O(VE^2)$ algorithm

# Our Contributions 
  {Verified in Isabelle/HOL}

  *<+-> Min-Cut/Max-Flow Theorem
    * Human-readable proof
    * Closely following Cormen et al.
  *<+-> Ford-Fulkerson and Edmonds Karp algorithms
    * Human-readable presentation of algorithms
    * Proved correctness and complexity
  *<+-> Efficient Implementation
    * Using stepwise refinement down to Imperative/HOL
    * Isabelle's code generator exports to SML
    * Benchmark: comparable to Java (from Sedgewick et al.)

\newcommand{\augment}{{\mathbin\uparrow}}%

\def\isasnipcolor{black}

\newcommand{\isawithcolor}[2]{{\setbeamercolor{math text}{fg=#1}\textcolor{#1}{#2}}}


\newcommand{\isasnipb}[1]{\isawithcolor\isasnipcolor{#1}}
\newcommand{\isasnip}[1]{{\footnotesize\isasnipb{#1}}}
\newcommand{\isasnipsmall}[1]{{\scriptsize\isasnipb{#1}}}




\def\isarproofsnippet{
\ \ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isacharparenleft}f{\isasymup}f{\isacharprime}{\isacharparenright}{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}\ {\isacharequal}\ f{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}\ {\isacharplus}\ f{\isacharprime}{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}\ {\isacharminus}\ f{\isacharprime}{\isacharparenleft}v{\isacharcomma}u{\isacharparenright}{\isachardoublequoteclose}\ \isanewline
\ \ \ \ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}auto\ simp{\isacharcolon}\ augment{\isacharunderscore}def{\isacharparenright}\isanewline
\ \ \isacommand{also}\isamarkupfalse%
\ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isasymdots}\ {\isasymle}\ f{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}\ {\isacharplus}\ f{\isacharprime}{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}{\isachardoublequoteclose}\ \isacommand{using}\isamarkupfalse%
\ f{\isacharprime}{\isachardot}capacity{\isacharunderscore}const\ \isacommand{by}\isamarkupfalse%
\ auto\isanewline
\ \ \isacommand{also}\isamarkupfalse%
\ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isasymdots}\ {\isasymle}\ f{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}\ {\isacharplus}\ cf{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}{\isachardoublequoteclose}\ \isacommand{using}\isamarkupfalse%
\ f{\isacharprime}{\isachardot}capacity{\isacharunderscore}const\ \isacommand{by}\isamarkupfalse%
\ auto\isanewline
\ \ \isacommand{also}\isamarkupfalse%
\ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isasymdots}\ {\isacharequal}\ f{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}\ {\isacharplus}\ c{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}\ {\isacharminus}\ f{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}{\isachardoublequoteclose}\ \isanewline
\ \ \ \ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}auto\ simp{\isacharcolon}\ residualGraph{\isacharunderscore}def{\isacharparenright}\isanewline
\ \ \isacommand{also}\isamarkupfalse%
\ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isasymdots}\ {\isacharequal}\ c{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}{\isachardoublequoteclose}\ \isacommand{by}\isamarkupfalse%
\ auto\isanewline
\ \ \isacommand{finally}\isamarkupfalse%
\ \isacommand{show}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isacharparenleft}f{\isasymup}f{\isacharprime}{\isacharparenright}{\isacharparenleft}u{\isacharcomma}\ v{\isacharparenright}\ {\isasymle}\ c{\isacharparenleft}u{\isacharcomma}\ v{\isacharparenright}{\isachardoublequoteclose}\ \isacommand{{\isachardot}}\isamarkupfalse%
}

# Human-Readable Proofs
  *<1-> Used Isar proof language
  
    \begin{uncoverenv}<2->
    {\footnotesize Proof fragment from Cormen at al.:
    \begin{align*}
    (f \uparrow f') (u, v) &= f(u, v) + f'(u, v) - f'(v, u)  && \text{(definition of $\augment$)} \\
    & \leq f(u, v) + f'(u, v) && \text{(because flows are nonnegative)} \\
    & \leq f(u, v) + c_f(u, v) &&  \text{(capacity constraint)} \\
    & = f(u, v) + c(u, v) - f(u, v) && \text{(definition of $c_f$)} \\
    & = c (u, v).
    \end{align*}
    }
    \end{uncoverenv}

    \begin{uncoverenv}<3->
    \isasnip{
      Our Isar version:\\[1em]
      \isarproofsnippet
    }
    \end{uncoverenv}

{
\def\isarsnippetstatement{
\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ augment{\isacharunderscore}flow{\isacharunderscore}value{\isacharcolon}\ {\isachardoublequoteopen}Flow{\isachardot}val\ c\ s\ {\isacharparenleft}f{\isasymup}f{\isacharprime}{\isacharparenright}\ {\isacharequal}\ val\ {\isacharplus}\ Flow{\isachardot}val\ cf\ s\ f{\isacharprime}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
\isacommand{proof}\isamarkupfalse%
\ {\isacharminus}\isanewline
\ \ \isacommand{interpret}\isamarkupfalse%
\ f{\isacharprime}{\isacharprime}{\isacharcolon}\ Flow\ c\ s\ t\ {\isachardoublequoteopen}f{\isasymup}f{\isacharprime}{\isachardoublequoteclose}\ \isacommand{using}\isamarkupfalse%
\ augment{\isacharunderscore}flow{\isacharunderscore}presv{\isacharbrackleft}OF\ assms{\isacharbrackright}\ \isacommand{{\isachardot}}\isamarkupfalse%
}    

\def\isarsnippetsimpset{
\isamarkuptrue%
\ \ \isacommand{note}\isamarkupfalse%
\ setsum{\isacharunderscore}simp{\isacharunderscore}setup{\isacharbrackleft}simp{\isacharbrackright}\ {\isacharequal}\ \isanewline
\ \ \ \ sum{\isacharunderscore}outgoing{\isacharunderscore}alt{\isacharbrackleft}OF\ capacity{\isacharunderscore}const{\isacharbrackright}\ s{\isacharunderscore}node\isanewline
\ \ \ \ sum{\isacharunderscore}incoming{\isacharunderscore}alt{\isacharbrackleft}OF\ capacity{\isacharunderscore}const{\isacharbrackright}\isanewline
\ \ \ \ cf{\isachardot}sum{\isacharunderscore}outgoing{\isacharunderscore}alt{\isacharbrackleft}OF\ f{\isacharprime}{\isachardot}capacity{\isacharunderscore}const{\isacharbrackright}\isanewline
\ \ \ \ cf{\isachardot}sum{\isacharunderscore}incoming{\isacharunderscore}alt{\isacharbrackleft}OF\ f{\isacharprime}{\isachardot}capacity{\isacharunderscore}const{\isacharbrackright}\isanewline
\ \ \ \ sum{\isacharunderscore}outgoing{\isacharunderscore}alt{\isacharbrackleft}OF\ f{\isacharprime}{\isacharprime}{\isachardot}capacity{\isacharunderscore}const{\isacharbrackright}\isanewline
\ \ \ \ sum{\isacharunderscore}incoming{\isacharunderscore}alt{\isacharbrackleft}OF\ f{\isacharprime}{\isacharprime}{\isachardot}capacity{\isacharunderscore}const{\isacharbrackright}\isanewline
\ \ \ \ setsum{\isacharunderscore}subtractf\ setsum{\isachardot}distrib%
}
\def\isarsnippetaux{\isamarkuptrue%
\ \ \isacommand{have}\isamarkupfalse%
\ aux{\isadigit{1}}{\isacharcolon}\ {\isachardoublequoteopen}f{\isacharprime}{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}\ {\isacharequal}\ {\isadigit{0}}{\isachardoublequoteclose}\ \isakeyword{if}\ {\isachardoublequoteopen}{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}{\isasymnotin}E{\isachardoublequoteclose}\ {\isachardoublequoteopen}{\isacharparenleft}v{\isacharcomma}u{\isacharparenright}{\isasymnotin}E{\isachardoublequoteclose}\ \isakeyword{for}\ u\ v\isanewline
\ \ \isacommand{proof}\isamarkupfalse%
\ {\isacharminus}\isanewline
\ \ \ \ \isacommand{from}\isamarkupfalse%
\ that\ cfE{\isacharunderscore}ss{\isacharunderscore}invE\ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}{\isasymnotin}cf{\isachardot}E{\isachardoublequoteclose}\ \isacommand{by}\isamarkupfalse%
\ auto\isanewline
\ \ \ \ \isacommand{thus}\isamarkupfalse%
\ {\isachardoublequoteopen}f{\isacharprime}{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}\ {\isacharequal}\ {\isadigit{0}}{\isachardoublequoteclose}\ \isacommand{by}\isamarkupfalse%
\ auto\isanewline
\ \ \isacommand{qed}\isamarkupfalse%
}
\def\isarsnippetredprf{
\isamarkuptrue%
\ \ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}f{\isacharprime}{\isacharprime}{\isachardot}val\ {\isacharequal}\ {\isacharparenleft}{\isasymSum}u{\isasymin}V{\isachardot}\ augment\ f{\isacharprime}\ {\isacharparenleft}s{\isacharcomma}\ u{\isacharparenright}\ {\isacharminus}\ augment\ f{\isacharprime}\ {\isacharparenleft}u{\isacharcomma}\ s{\isacharparenright}{\isacharparenright}{\isachardoublequoteclose}\ \isanewline
\ \ \ \ \isacommand{unfolding}\isamarkupfalse%
\ f{\isacharprime}{\isacharprime}{\isachardot}val{\isacharunderscore}def\ \isacommand{by}\isamarkupfalse%
\ simp\isanewline
\ \ \isacommand{also}\isamarkupfalse%
\ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isasymdots}\ {\isacharequal}\ {\isacharparenleft}{\isasymSum}u{\isasymin}V{\isachardot}\ f\ {\isacharparenleft}s{\isacharcomma}\ u{\isacharparenright}\ {\isacharminus}\ f\ {\isacharparenleft}u{\isacharcomma}\ s{\isacharparenright}\ {\isacharplus}\ {\isacharparenleft}f{\isacharprime}\ {\isacharparenleft}s{\isacharcomma}\ u{\isacharparenright}\ {\isacharminus}\ f{\isacharprime}\ {\isacharparenleft}u{\isacharcomma}\ s{\isacharparenright}{\isacharparenright}{\isacharparenright}{\isachardoublequoteclose}\isanewline
\ \ \ \ %
\isamarkupcmt{Note that this is the crucial step of the proof, which Cormen et al. leave as an exercise.%
}
\isanewline
\ \ \ \ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}rule\ setsum{\isachardot}cong{\isacharparenright}\ {\isacharparenleft}auto\ simp{\isacharcolon}\ augment{\isacharunderscore}def\ no{\isacharunderscore}parallel{\isacharunderscore}edge\ aux{\isadigit{1}}{\isacharparenright}\isanewline
\ \ \isacommand{also}\isamarkupfalse%
\ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isasymdots}\ {\isacharequal}\ val\ {\isacharplus}\ Flow{\isachardot}val\ cf\ s\ f{\isacharprime}{\isachardoublequoteclose}\ \ \isanewline
\ \ \ \ \isacommand{unfolding}\isamarkupfalse%
\ val{\isacharunderscore}def\ f{\isacharprime}{\isachardot}val{\isacharunderscore}def\ \isacommand{by}\isamarkupfalse%
\ simp\isanewline
\ \ \isacommand{finally}\isamarkupfalse%
\ \isacommand{show}\isamarkupfalse%
\ {\isachardoublequoteopen}f{\isacharprime}{\isacharprime}{\isachardot}val\ {\isacharequal}\ val\ {\isacharplus}\ f{\isacharprime}{\isachardot}val{\isachardoublequoteclose}\ \isacommand{{\isachardot}}\isamarkupfalse%
\ \ \isanewline
\isacommand{qed}\isamarkupfalse%
}
    
#[t] And Automatic Proofs
  {}
  
  *<1-> Cormen et al. also give more complicated proofs
  *<2-> We sometimes chose to use more automatic proofs
    *<3-> Using some simplifier setup
    *<4-> And auxiliary statements
    *<5-> We reduce the displayed proof's complexity
  
  \vspace*{1em}
  \begin{onlyenv}<1>
  First part of proof that $|f\up f'| = |f|+|f'|$:\\
  \includegraphics[width=.7\textwidth]{cormen26_6.png}
  \end{onlyenv}
  \begin{onlyenv}<2>
    \isasnip\isarsnippetstatement
  \end{onlyenv}
  \begin{onlyenv}<3>
    \isasnip\isarsnippetsimpset
  \end{onlyenv}
  \begin{onlyenv}<4>
    \isasnip\isarsnippetaux
  \end{onlyenv}
  \begin{onlyenv}<5>
    \isasnip\isarsnippetredprf
  \end{onlyenv}
  
}  

{
\def\snippetfofuthm{
\isamarkuptrue%
\isacommand{context}\isamarkupfalse%
\ NFlow\ \isakeyword{begin}%
\isanewline...\isanewline
\isamarkuptrue%
\isacommand{theorem}\isamarkupfalse%
\ ford{\isacharunderscore}fulkerson{\isacharcolon}\isanewline
\ \ {\isachardoublequoteopen}isMaxFlow\ f\ {\isasymlongleftrightarrow}\ {\isacharparenleft}{\isasymnexists}p{\isachardot}\ isAugmentingPath\ p{\isacharparenright}{\isachardoublequoteclose}\ 
}
# Main Result
 * Finally, we arrive at\\[2em]
    \isasnip\snippetfofuthm

}


{
\def\snippetfofu{
\isacommand{definition}\isamarkupfalse%
\ {\isachardoublequoteopen}ford{\isacharunderscore}fulkerson{\isacharunderscore}method\ {\isasymequiv}\ \isainnerkeyword{do}\ {\isacharbraceleft}\isanewline
\ \ \isainnerkeyword{let}\ f\isactrlsub {\isadigit{0}}\ {\isacharequal}\ {\isacharparenleft}{\isasymlambda}{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}{\isachardot}\ {\isadigit{0}}{\isacharparenright}{\isacharsemicolon}\isanewline
\isanewline
\ \ {\isacharparenleft}f{\isacharcomma}brk{\isacharparenright}\ {\isasymleftarrow}\ \isainnerkeyword{while}\ {\isacharparenleft}{\isasymlambda}{\isacharparenleft}f{\isacharcomma}brk{\isacharparenright}{\isachardot}\ {\isasymnot}brk{\isacharparenright}\ \isanewline
\ \ \ \ {\isacharparenleft}{\isasymlambda}{\isacharparenleft}f{\isacharcomma}brk{\isacharparenright}{\isachardot}\ \isainnerkeyword{do}\ {\isacharbraceleft}\isanewline
\ \ \ \ \ \ p\ {\isasymleftarrow}\ \isainnerkeyword{selectp}\ p{\isachardot}\ is{\isacharunderscore}augmenting{\isacharunderscore}path\ f\ p{\isacharsemicolon}\isanewline
\ \ \ \ \ \ \isainnerkeyword{case}\ p\ of\ \isanewline
\ \ \ \ \ \ \ \ None\ {\isasymRightarrow}\ \isainnerkeyword{return}\ {\isacharparenleft}f{\isacharcomma}True{\isacharparenright}\isanewline
\ \ \ \ \ \ {\isacharbar}\ Some\ p\ {\isasymRightarrow}\ \isainnerkeyword{return}\ {\isacharparenleft}augment\ c\ f\ p{\isacharcomma}\ False{\isacharparenright}\isanewline
\ \ \ \ {\isacharbraceright}{\isacharparenright}\isanewline
\ \ \ \ {\isacharparenleft}f\isactrlsub {\isadigit{0}}{\isacharcomma}False{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \isainnerkeyword{return}\ f\ \isanewline
{\isacharbraceright}{\isachardoublequoteclose}%
}
%%BEGIN-FILTER: sed -rf massage_snippets.sed
\def\snippetproof{
\isamarkuptrue%
\isacommand{theorem}\isamarkupfalse%
\ fofu{\isacharunderscore}partial{\isacharunderscore}correct{\isacharcolon}\ {\isachardoublequoteopen}fofu\ {\isasymle}\ {\isacharparenleft}{spec}\ f{\isachardot}\ isMaxFlow\ f{\isacharparenright}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isawithcolor{gray}{
\isanewline
\isatagproof
\isacommand{unfolding}\isamarkupfalse%
\ fofu{\isacharunderscore}def\ find{\isacharunderscore}augmenting{\isacharunderscore}spec{\isacharunderscore}def\isanewline
\ \ \isacommand{apply}\isamarkupfalse%
\ {\isacharparenleft}refine{\isacharunderscore}vcg{\isacharparenright}\isanewline
\ \ \isacommand{apply}\isamarkupfalse%
\ {\isacharparenleft}vc{\isacharunderscore}solve\ simp{\isacharcolon}\ \isanewline
\ \ \ \ zero{\isacharunderscore}flow\ \isanewline
\ \ \ \ NFlow{\isachardot}augment{\isacharunderscore}pres{\isacharunderscore}nflow\ \isanewline
\ \ \ \ NFlow{\isachardot}augmenting{\isacharunderscore}path{\isacharunderscore}not{\isacharunderscore}empty\isanewline
\ \ \ \ NFlow{\isachardot}noAugPath{\isacharunderscore}iff{\isacharunderscore}maxFlow{\isacharbrackleft}symmetric{\isacharbrackright}{\isacharparenright}\isanewline
\ \ \isacommand{done}\isamarkupfalse%
%
\endisatagproof%
}
}
\def\snippetfofuassn{\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ {\isachardoublequoteopen}fofu\ {\isasymequiv}\ do\ {\isacharbraceleft}\isanewline
\ \ let\ f\isactrlsub {\isadigit{0}}\ {\isacharequal}\ {\isacharparenleft}{\isasymlambda}{\isacharunderscore}{\isachardot}\ {\isadigit{0}}{\isacharparenright}{\isacharsemicolon}\isanewline
\isanewline
\ \ {\isacharparenleft}f{\isacharcomma}{\isacharunderscore}{\isacharparenright}\ {\isasymleftarrow}\ while\isactrlbsup \isawithcolor{blue}{fofu{\isacharunderscore}invar}\isactrlesup \isanewline
\ \ \ \ {\isacharparenleft}{\isasymlambda}{\isacharparenleft}f{\isacharcomma}brk{\isacharparenright}{\isachardot}\ {\isasymnot}brk{\isacharparenright}\ \isanewline
\ \ \ \ {\isacharparenleft}{\isasymlambda}{\isacharparenleft}f{\isacharcomma}{\isacharunderscore}{\isacharparenright}{\isachardot}\ do\ {\isacharbraceleft}\isanewline
\ \ \ \ \ \ p\ {\isasymleftarrow}\ find{\isacharunderscore}augmenting{\isacharunderscore}spec\ f{\isacharsemicolon}\isanewline
\ \ \ \ \ \ case\ p\ of\ \isanewline
\ \ \ \ \ \ \ \ None\ {\isasymRightarrow}\ return\ {\isacharparenleft}f{\isacharcomma}True{\isacharparenright}\isanewline
\ \ \ \ \ \ {\isacharbar}\ Some\ p\ {\isasymRightarrow}\ do\ {\isacharbraceleft}\isanewline
\ \ \ \ \ \ \ \ \ \ \isawithcolor{blue}{ assert\ {\isacharparenleft}p{\isasymnoteq}{\isacharbrackleft}{\isacharbrackright}{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ \ \ \ \ \ \ assert\ {\isacharparenleft}NFlow{\isachardot}isAugmentingPath\ c\ s\ t\ f\ p{\isacharparenright}{\isacharsemicolon}}\isanewline
\ \ \ \ \ \ \ \ \ \ let\ f\ {\isacharequal}\ NFlow{\isachardot}augment{\isacharunderscore}with{\isacharunderscore}path\ c\ f\ p{\isacharsemicolon}\isanewline
\ \ \ \ \ \ \ \ \ \ \isawithcolor{blue}{ assert\ {\isacharparenleft}NFlow\ c\ s\ t\ f{\isacharparenright}{\isacharsemicolon}}\isanewline
\ \ \ \ \ \ \ \ \ \ return\ {\isacharparenleft}f{\isacharcomma}\ False{\isacharparenright}\isanewline
\ \ \ \ \ \ \ \ {\isacharbraceright}\ \ \isanewline
\ \ \ \ {\isacharbraceright}{\isacharparenright}\isanewline
\ \ \ \ {\isacharparenleft}f\isactrlsub {\isadigit{0}}{\isacharcomma}False{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \isawithcolor{blue}{ assert\ {\isacharparenleft}NFlow\ c\ s\ t\ f{\isacharparenright}{\isacharsemicolon}}\isanewline
\ \ return\ f\ \isanewline
{\isacharbraceright}{\isachardoublequoteclose}%
}
%%END-FILTER

\def\snippetnprf{
\isacommand{theorem}\isamarkupfalse%
\ {\isacharparenleft}\isakeyword{in}\ Network{\isacharparenright}\ {\isachardoublequoteopen}ford{\isacharunderscore}fulkerson{\isacharunderscore}method\ {\isasymle}\ {\isacharparenleft}\isainnerkeyword{spec}\ f{\isachardot}\ isMaxFlow\ f{\isacharparenright}{\isachardoublequoteclose}%
}

#[t] Ford-Fulkerson Method
  {}
  *<1-> We use the Isabelle Refinement Framework
    *<2-> Based on nondeterminism monad + refinement calculus 
    *<2-> Provides proof tools + Isabelle Collection Framework
      \vspace*{1em}
      
      \begin{onlyenv}<3>
        \isasnip\snippetfofu
      \end{onlyenv}

#[t] Correctness Proof  
  *<1-> First, we add some assertions and invariant annotations
    \begin{onlyenv}<1>
      \vspace*{1em}
      
      \isasnipsmall\snippetfofuassn
    \end{onlyenv}
  *<2-> Then, we use the VCG to prove partial correctness
    \begin{onlyenv}<2>
      \vspace*{1em}
      
      \isasnip\snippetproof
    \end{onlyenv}
  *<3-> This also yields correctness of the unannotated version
    \begin{onlyenv}<3>
      \vspace*{1em}
      
      \isasnip\snippetnprf
    \end{onlyenv}
  
}
{
%%BEGIN-FILTER: sed -rf massage_snippets.sed
\def\snipshortest{
\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ {\isachardoublequoteopen}find{\isacharunderscore}shortest{\isacharunderscore}augmenting{\isacharunderscore}spec\ f\ {\isasymequiv}\isanewline
\ \ assert\ {\isacharparenleft}NFlow\ c\ s\ t\ f{\isacharparenright}\ {\isasymthen}\ \isanewline
\ \ {\isacharparenleft}selectp\ p{\isachardot}\ Graph{\isachardot}isShortestPath\ {\isacharparenleft}residualGraph\ c\ f{\isacharparenright}\ s\ p\ t{\isacharparenright}{\isachardoublequoteclose}%
}
\def\snipsrefine{
\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ find{\isacharunderscore}shortest{\isacharunderscore}augmenting{\isacharunderscore}refine{\isacharcolon}\ \isanewline
\ \ find{\isacharunderscore}shortest{\isacharunderscore}augmenting{\isacharunderscore}spec\ {\isasymle}\ find{\isacharunderscore}augmenting{\isacharunderscore}spec
}
\def\snipalgoorig{
\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ {\isachardoublequoteopen}fofu\ {\isasymequiv}\ do\ {\isacharbraceleft}\isanewline

...\isanewline
p\ {\isasymleftarrow}\ find{\isacharunderscore}augmenting{\isacharunderscore}spec\ f{\isacharsemicolon}
\isanewline...
}
\def\snipalgorepl{
\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ {\isachardoublequoteopen}\isawithcolor{blue}{edka{\isacharunderscore}partial}\ {\isasymequiv}\ do\ {\isacharbraceleft}\isanewline

...\isanewline
p\ {\isasymleftarrow}\ \isawithcolor{blue}{find{\isacharunderscore}shortest{\isacharunderscore}augmenting{\isacharunderscore}spec}\ f{\isacharsemicolon}
\isanewline...
}
\def\snipalgoref{
\isacommand{lemma}\isamarkupfalse%
\ edka{\isacharunderscore}partial{\isacharunderscore}refine{\isacharbrackleft}refine{\isacharbrackright}{\isacharcolon}\ {\isachardoublequoteopen}edka{\isacharunderscore}partial\ {\isasymle}\ fofu{\isachardoublequoteclose}\isanewline

\isawithcolor{gray}{
\isatagproof
\isacommand{unfolding}\isamarkupfalse%
\ find{\isacharunderscore}shortest{\isacharunderscore}augmenting{\isacharunderscore}spec{\isacharunderscore}def\ find{\isacharunderscore}augmenting{\isacharunderscore}spec{\isacharunderscore}def\isanewline
\ \ \isacommand{apply}\isamarkupfalse%
\ {\isacharparenleft}refine{\isacharunderscore}vcg{\isacharparenright}\isanewline
\ \ \isacommand{apply}\isamarkupfalse%
\ {\isacharparenleft}auto\ \isanewline
\ \ \ \ simp{\isacharcolon}\ NFlow{\isachardot}shortest{\isacharunderscore}is{\isacharunderscore}augmenting\ \isanewline
\ \ \ \ dest{\isacharcolon}\ NFlow{\isachardot}augmenting{\isacharunderscore}path{\isacharunderscore}imp{\isacharunderscore}shortest{\isacharparenright}\isanewline
\ \ \isacommand{done}\isamarkupfalse%
%
\endisatagproof
}
}
%%END-FILTER
#[t] Edmonds-Karp Algorithm
  *<1-> Specify shortest augmenting path
    \begin{onlyenv}<1>
      \vspace*{1em}
      
      \isasnip\snipshortest
    \end{onlyenv}
  *<2-> This is a refinement of augmenting path
    \begin{onlyenv}<2>
      \vspace*{1em}
      
      \isasnip\snipsrefine
    \end{onlyenv}
  *<3-> Replace in algorithm
    \begin{onlyenv}<3>
      \vspace*{1em}
      
      \isasnip\snipalgoorig
    \end{onlyenv}
    \begin{onlyenv}<4>
      \vspace*{1em}
      
      \isasnip\snipalgorepl
    \end{onlyenv}
  
  *<5-> New algorithm refines original one
    \begin{onlyenv}<5>
      \vspace*{1em}
      
      \isasnip\snipalgoref
    \end{onlyenv}

}

{
%%BEGIN-FILTER: sed -rf massage_snippets.sed
\def\edkarefine{
\isamarkuptrue%
\isacommand{theorem}\isamarkupfalse%
\ edka{\isacharunderscore}refine{\isacharbrackleft}refine{\isacharbrackright}{\isacharcolon}\ {\isachardoublequoteopen}edka\ {\isasymle}\ edka{\isacharunderscore}partial{\isachardoublequoteclose}\isanewline
}
\def\edkapartial{
\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ {\isachardoublequoteopen}edka{\isacharunderscore}partial\ {\isasymequiv}\ do\ {\isacharbraceleft}\isanewline
...\isanewline
{\isacharparenleft}f{\isacharcomma}{\isacharunderscore}{\isacharparenright}\ {\isasymleftarrow}\ while\isactrlbsup fofu{\isacharunderscore}invar\isactrlesup \isanewline
\isanewline...
}

\def\edkatotal{
\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ {\isachardoublequoteopen}\isawithcolor{blue}{edka}\ {\isasymequiv}\ do\ {\isacharbraceleft}\isanewline
...\isanewline
{\isacharparenleft}f{\isacharcomma}{\isacharunderscore}{\isacharparenright}\ {\isasymleftarrow}\ \isawithcolor{blue}{ while\isactrlsub T}\isactrlbsup fofu{\isacharunderscore}invar\isactrlesup \isanewline
\isanewline...
}


%%END-FILTER
#[t] Total Correctness and Complexity
  *<1-> Next, we define a total correct version
    \begin{onlyenv}<1>
      \vspace{1em}
      
      \isasnip\edkapartial
    \end{onlyenv}
    \begin{onlyenv}<2>
      \vspace{1em}
      
      \isasnip\edkatotal
    \end{onlyenv}
  *<3-> And show refinement
    \begin{onlyenv}<3>
      \vspace{1em}
      
      \isasnip\edkarefine
    \end{onlyenv}
  *<4-> We also show $O(VE)$ bound on loop iterations
    * Instrumenting the loop with a counter
}

# Towards Efficient Implementation
  {}
  \only<+->{Several refinement steps lead to final implementation:}
  *#<+-> Update residual graphs instead of flows
  *<+-> Implement augmentation (iterate over path twice)
  *<+-> Use BFS to determine shortest augmenting path
  *<+-> Implement successor function on residual graph
    * Using pre-computed map of adjacent nodes in network
  *<+-> Imperative Data Structures
    * Tabulate capacity matrix and adjacency map to array
    * Maintain residual graph in array
  *<+-> Export to SML code

{
%%BEGIN-FILTER: sed -rf massage_snippets.sed

\def\snipthm{
\isamarkuptrue%
\ \ \isacommand{context}\isamarkupfalse%
\ Network{\isacharunderscore}Impl\ \isakeyword{begin}\isanewline
\ \ \ \ \isacommand{theorem}\isamarkupfalse%
\ edka{\isacharunderscore}imp{\isacharunderscore}correct{\isacharcolon}\ \isanewline
\ \ \ \ \ \ \isakeyword{assumes}\ {\isachardoublequoteopen}Graph{\isachardot}V\ c\ {\isasymsubseteq}\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isacharless}N{\isacharbraceright}{\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \isakeyword{assumes}\ {\isachardoublequoteopen}is{\isacharunderscore}adj{\isacharunderscore}map\ am{\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \isakeyword{shows}\ {\isachardoublequoteopen}\isanewline
\ \ \ \ \ \ \ \ {\isacharless}emp{\isachargreater}\ \isanewline
\ \ \ \ \ \ \ \ \ \ \isawithcolor{blue}{edka{\isacharunderscore}imp\ c\ s\ t\ N\ am}\ \isanewline
\ \ \ \ \ \ \ \ {\isacharless}{\isasymlambda}fi{\isachardot}\ {\isasymexists}\isactrlsub Af{\isachardot}\ is{\isacharunderscore}rflow\ N\ f\ fi\ {\isacharasterisk}\ {\isasymup}{\isacharparenleft}isMaxFlow\ f{\isacharparenright}{\isachargreater}\isactrlsub t{\isachardoublequoteclose}\isanewline
%
}

\def\snipproof{
%
\isatagproof
\isacommand{proof}\isamarkupfalse%
\ {\isacharminus}\isanewline
\ \ \ \ \ \ \isacommand{interpret}\isamarkupfalse%
\ Edka{\isacharunderscore}Impl\ \isacommand{by}\isamarkupfalse%
\ unfold{\isacharunderscore}locales\ fact\isanewline
\isanewline
\ \ \ \ \ \ \isacommand{note}\isamarkupfalse%
\ edka{\isadigit{5}}{\isacharunderscore}refine{\isacharbrackleft}OF\ ABS{\isacharunderscore}PS{\isacharbrackright}\isanewline
\ \ \ \ \ \ \isacommand{also}\isamarkupfalse%
\ \isacommand{note}\isamarkupfalse%
\ edka{\isadigit{4}}{\isacharunderscore}refine\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \isanewline
\ \ \ \ \ \ \isacommand{also}\isamarkupfalse%
\ \isacommand{note}\isamarkupfalse%
\ edka{\isadigit{3}}{\isacharunderscore}refine\ \ \ \ \isanewline
\ \ \ \ \ \ \isacommand{also}\isamarkupfalse%
\ \isacommand{note}\isamarkupfalse%
\ edka{\isadigit{2}}{\isacharunderscore}refine\ \isanewline
\ \ \ \ \ \ \isacommand{also}\isamarkupfalse%
\ \isacommand{note}\isamarkupfalse%
\ edka{\isacharunderscore}refine\isanewline
\ \ \ \ \ \ \isacommand{also}\isamarkupfalse%
\ \isacommand{note}\isamarkupfalse%
\ edka{\isacharunderscore}partial{\isacharunderscore}refine\isanewline
\ \ \ \ \ \ \isacommand{also}\isamarkupfalse%
\ \isacommand{note}\isamarkupfalse%
\ fofu{\isacharunderscore}partial{\isacharunderscore}correct\isanewline
\ \ \ \ \ \ \isacommand{finally}\isamarkupfalse%
\ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}edka{\isadigit{5}}\ am\ {\isasymle}\ SPEC\ isMaxFlow{\isachardoublequoteclose}\ \isacommand{{\isachardot}}\isamarkupfalse%
\isanewline
\ \ \ \ \ \ \isacommand{from}\isamarkupfalse%
\ hn{\isacharunderscore}refine{\isacharunderscore}ref{\isacharbrackleft}OF\ this\ edka{\isacharunderscore}imp{\isacharunderscore}refine{\isacharbrackright}\isanewline
\ \ \ \ \ \ \isacommand{show}\isamarkupfalse%
\ {\isacharquery}thesis\ \isanewline
\ \ \ \ \ \ \ \ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}simp\ add{\isacharcolon}\ hn{\isacharunderscore}refine{\isacharunderscore}def{\isacharparenright}\isanewline
\isacommand{qed}\isamarkupfalse%
%
\endisatagproof
}
  
\def\snipcheckedthm{
\isacommand{theorem}\isamarkupfalse%
\isanewline
\ \ \isakeyword{fixes}\ el\ \isakeyword{defines}\ {\isachardoublequoteopen}c\ {\isasymequiv}\ ln{\isacharunderscore}{\isasymalpha}\ el{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ \isanewline
\ \ \ \ {\isachardoublequoteopen}{\isacharless}emp{\isachargreater}\ \isanewline
\ \ \ \ \ \ \isawithcolor{blue}{edmonds{\isacharunderscore}karp\ el\ s\ t}\ \isanewline
\ \ \ \ {\isacharless}\isanewline
\ \ \ \ \ \ {\isasymlambda}None\ {\isasymRightarrow}\ {\isasymup}{\isacharparenleft}{\isasymnot}ln{\isacharunderscore}invar\ el\ {\isasymor}\ {\isasymnot}Network\ c\ s\ t{\isacharparenright}\isanewline
\ \ \ \ \ \ {\isacharbar}\ Some\ {\isacharparenleft}{\isacharunderscore}{\isacharcomma}{\isacharunderscore}{\isacharcomma}N{\isacharcomma}cf{\isacharparenright}\ {\isasymRightarrow}\ \isanewline
\ \ \ \ \ \ \ \ \ {\isasymup}{\isacharparenleft}ln{\isacharunderscore}invar\ el\ {\isasymand}\ Network\ c\ s\ t\ {\isasymand}\ Graph{\isachardot}V\ c\ {\isasymsubseteq}\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isacharless}N{\isacharbraceright}{\isacharparenright}\isanewline
\ \ \ \ \ \ \ {\isacharasterisk}\ {\isacharparenleft}{\isasymexists}\isactrlsub Af{\isachardot}\ is{\isacharunderscore}rflow\ c\ s\ t\ N\ f\ cf\ {\isacharasterisk}\ {\isasymup}{\isacharparenleft}Network{\isachardot}isMaxFlow\ c\ s\ t\ f{\isacharparenright}{\isacharparenright}\isanewline
\ \ \ \ {\isachargreater}\isactrlsub t{\isachardoublequoteclose}%
}

%%END-FILTER


#[t] Assembling Overall Correctness Proof
  *<1-> Correctness statement
    * As Hoare Triple using Separation Logic
    \begin{onlyenv}<1>
      \vspace{1em}
      
      \isasnip\snipthm
    \end{onlyenv}
  *<2-> Proof by transitivity
    \begin{onlyenv}<2>
      \vspace{1em}
      
      \isasnip\snipproof
    \end{onlyenv}
  *<3-> Also integrated with check for valid network
    * Input: list of edges, source node, sink node
    \begin{onlyenv}<3>
      \vspace{1em}
      
      \isasnip\snipcheckedthm
    \end{onlyenv}
    
}  

#! Benchmarking
  * Against Java version of Sedgewick et al., on random networks
  * Two data sets: Sparse ($D=0.02$) and dense ($D=0.25$) graphs
    * Sparse: Java is (slightly) faster
    * Dense: we are (slightly) faster
    * Supposed reason: different 2-dimensional array implementations

  \center  
  \begin{tikzpicture}[thick,scale=.6, every node/.style={scale=1}] %change the scales if you like to reduce the size
    \begin{axis}[
      %title={Benchmark of the Edmonds-Karp algorithm},
        axis x line*= bottom,
        axis y line*= left,
        xmode = log,
        ymode = log,
        xlabel = number of nodes,
        ylabel = time/s, 
        xtick = {0,1000,...,5000},
        ytick = {0.01,0.1,1,10},
        xticklabels = {$1k$, $2k$, $3k$, $4k$, $5k$},
        yticklabels = {$0.01$,$0.1$,$1$,$10$}, 
        smooth,
        cycle list name = black white,
        legend style = { 
          at={(0.59,0.4)}, 
            anchor=north west,
            draw=black, 
            fill= white,
            align=left
        }
    ]
    
    %start data for plotting
      \addplot table {
        1000 .027   
        1500 .124  
        2000 .299  
        2500 .665  
        3000 1.335 
        3500 2.526 
        4000 3.111 
        4500 6.917 
        5000 7.743 
        5500 10.452    
      }; \addlegendentry{SML, sparse};

      \addplot table {
        1000 .016   
        1500 .049   
        2000 .168  
        2500 .453  
        3000 .842  
        3500 1.524 
        4000 2.136 
        4500 3.438 
        5000 4.734 
        5500 6.369     
      }; \addlegendentry{Java, sparse};
    %end data for plotting
    \end{axis}
  \end{tikzpicture}
%
  \hspace{1em}
  \begin{tikzpicture}[thick,scale=.6, every node/.style={scale=1}] %change the scales if you like to reduce the size
    \begin{axis}[
      %title={Benchmark of the Edmonds-Karp algorithm},
        axis x line*= bottom,
        axis y line*= left,
        xmode = log,
        ymode = log,
        xlabel = number of nodes,
        ylabel = time/s, 
        xtick = {0,1000,1100,...,1400},
        ytick = {2,4,...,10},
        xticklabels = {$1.0k$, $1.1k$, $1.2k$, $1.3k$, $1.4k$}, 
        yticklabels = {$2$, $4$,$6$,$8$,$10$}, 
        smooth,
        cycle list name = black white,
        legend style = { 
          at={(0.59,0.4)}, 
            anchor=north west,
            draw=black, 
            fill= white,
            align=left
        }
    ]
    
    %start data for plotting
      \addplot table {
        1000 3.328 
        1050 3.345 
        1100 4.841 
        1150 5.036 
        1200 5.840 
        1250 6.858 
        1300 7.651 
        1350 8.950 
        1400 8.398 
        1450 10.769     
      }; \addlegendentry{SML, dense};

      \addplot table {
        1000 4.141 
        1050 4.778 
        1100 5.465 
        1150 6.248 
        1200 7.128 
        1250 8.137 
        1300 9.864 
        1350 11.008
        1400 11.902
        1450 13.365     
      }; \addlegendentry{Java, dense};
    %end data for plotting
    \end{axis}
  \end{tikzpicture}
    
# Conclusion
  * Proof of Min-Cut/Max-Flow Theorem
    * Human readable proofs following textbook presentation
    * Showing off Isar proof language
  * Verified Edmonds-Karp algorithm
    * From abstract pseudo-code like version ...
    * ... down to imperative implementation
    * Showing off Isabelle Refinement Framework
  * Our implementation is pretty efficient

  \vfill
  \center
  Available in Archive of Formal Proofs
  
  \url{www.isa-afp.org/entries/EdmondsKarp_Maxflow.shtml}
  
  \url{www.isa-afp.org/entries/Refine_Imperative_HOL.shtml}
  \vfill
  
  \uncover<2->{\huge\center Questions?}
    
    
\end{document}




