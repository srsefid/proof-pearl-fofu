<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Graph (Isabelle2015: May 2015)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Graph</h1>

<span class="command">theory</span> <span class="name">Graph</span><br/>
<span class="keyword">imports</span> <a href="Fofu_Abs_Base.html"><span class="name">Fofu_Abs_Base</span></a><br/>

</div>
<div class="source">
<pre><span class="keyword1">theory</span> Graph
<span class="keyword2">imports</span> Fofu_Abs_Base
<span class="keyword2">begin</span>


  <span class="comment">(* Graph definitions *)</span>
  <span class="comment">(*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*)</span>
  <span class="comment">(*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*)</span>
  <span class="keyword1">type_synonym</span> node <span class="delimiter">=</span> nat 
  <span class="keyword1">type_synonym</span> edge <span class="delimiter">=</span> <span class="string">&quot;node &times; node&quot;</span>
  <span class="comment">(*type_synonym capacity = int*)</span>

  <span class="comment">(*
  typedecl capacity 
  instance capacity :: linordered_idom sorry
  *)</span>


  <span class="keyword1">type_synonym</span> <span class="tfree">&#39;capacity</span> graph <span class="delimiter">=</span> <span class="string">&quot;edge =&gt; &#39;capacity&quot;</span>
  
<span class="keyword1">locale</span> Graph <span class="delimiter">=</span> <span class="keyword2">fixes</span> c <span class="delimiter">::</span> <span class="string">&quot;&#39;capacity::linordered_idom graph&quot;</span>
  <span class="keyword2">begin</span>
    <span class="keyword1">definition</span> E <span class="delimiter">::</span> <span class="string">&quot;edge set&quot;</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Edges of the graph&#8250;</span>
    <span class="keyword2">where</span> <span class="string">&quot;E &equiv; {(u, v). c (u, v) &ne; 0}&quot;</span>
    
    <span class="keyword1">definition</span> V <span class="delimiter">::</span> <span class="string">&quot;node set&quot;</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Nodes of the graph. Exactly the nodes that have adjacent edges.&#8250;</span>
    <span class="keyword2">where</span> <span class="string">&quot;V &equiv; {u. &exist;v. (u, v) &isin; E &or; (v, u) &isin; E}&quot;</span>
    
    <span class="keyword1">definition</span> incoming <span class="delimiter">::</span> <span class="string">&quot;node =&gt; edge set&quot;</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Incoming edges into a node&#8250;</span>
    <span class="keyword2">where</span> <span class="string">&quot;incoming v &equiv; {(u, v) | u. (u, v) &isin; E}&quot;</span>
    
    <span class="keyword1">definition</span> outgoing <span class="delimiter">::</span> <span class="string">&quot;node =&gt; edge set&quot;</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Outgoing edges from a node&#8250;</span>
    <span class="keyword2">where</span> <span class="string">&quot;outgoing v &equiv; {(v, u) | u. (v, u) &isin; E}&quot;</span>
      
    <span class="keyword1">definition</span> adjacent <span class="delimiter">::</span> <span class="string">&quot;node =&gt; edge set&quot;</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Adjacent edges of a node&#8250;</span>
    <span class="keyword2">where</span> <span class="string">&quot;adjacent v &equiv; incoming v &cup; outgoing v&quot;</span>
    
    <span class="keyword1">definition</span> incoming&#39; <span class="delimiter">::</span> <span class="string">&quot;node set =&gt; edge set&quot;</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Incoming edges into a set of nodes&#8250;</span>
    <span class="keyword2">where</span> <span class="string">&quot;incoming&#39; k &equiv; {(u, v) | u v. u &notin; k &and; v &isin; k &and; (u, v) &isin; E}&quot;</span>
      
    <span class="keyword1">definition</span> outgoing&#39; <span class="delimiter">::</span> <span class="string">&quot;node set =&gt; edge set&quot;</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Outgoing edges from a set of nodes&#8250;</span>
    <span class="keyword2">where</span> <span class="string">&quot;outgoing&#39; k &equiv; {(v, u) | u v. u &notin; k &and; v &isin; k &and; (v, u) &isin; E}&quot;</span>
      
    <span class="keyword1">definition</span> adjacent&#39; <span class="delimiter">::</span> <span class="string">&quot;node set =&gt; edge set&quot;</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Edges adjacent to a set of nodes&#8250;</span>
    <span class="keyword2">where</span> <span class="string">&quot;adjacent&#39; k &equiv; incoming&#39; k &cup; outgoing&#39; k&quot;</span>
  <span class="keyword2">end</span>

  <span class="comment">(* TODO: Rename to is_adjacency_map, and move to Graph locale! *)</span>
  <span class="keyword1">definition</span> is_pred_succ <span class="delimiter">::</span> <span class="string">&quot;(node =&gt; node list) =&gt; _ graph =&gt; bool&quot;</span> 
    <span class="delimiter">--</span> <span class="cartouche">&#8249;Predicate to characterize function that returns adjacent nodes&#8250;</span>
    <span class="keyword2">where</span>
    <span class="string">&quot;is_pred_succ ps c &equiv; (&forall;u. distinct (ps u) &and; set (ps u) = (Graph.E c)``{u} &cup; (Graph.E c)&macr;``{u})&quot;</span>


  <span class="keyword1">locale</span> Graph_Loc_Syntax <span class="delimiter">=</span> Graph
  <span class="keyword2">begin</span>
    <span class="keyword1">notation</span> incoming <span class="delimiter">(</span><span class="string">&quot;&delta;<span class="hidden">&#8679;</span><sup>+</sup>(_)&quot;</span> 1000<span class="delimiter">)</span> 
    <span class="keyword1">notation</span> outgoing <span class="delimiter">(</span><span class="string">&quot;&delta;<span class="hidden">&#8679;</span><sup>-</sup>(_)&quot;</span> 1000<span class="delimiter">)</span>
    <span class="keyword1">notation</span> adjacent <span class="delimiter">(</span><span class="string">&quot;&delta;(_)&quot;</span> 1000<span class="delimiter">)</span> 
    <span class="keyword1">notation</span> incoming&#39; <span class="delimiter">(</span><span class="string">&quot;&Delta;<span class="hidden">&#8679;</span><sup>+</sup>(_)&quot;</span> 1000<span class="delimiter">)</span> 
    <span class="keyword1">notation</span> outgoing&#39; <span class="delimiter">(</span><span class="string">&quot;&Delta;<span class="hidden">&#8679;</span><sup>-</sup>(_)&quot;</span> 1000<span class="delimiter">)</span>
    <span class="keyword1">notation</span> adjacent&#39; <span class="delimiter">(</span><span class="string">&quot;&Delta;(_)&quot;</span> 1000<span class="delimiter">)</span> 
  <span class="keyword2">end</span>

  <span class="keyword1">locale</span> Graph_Syntax <span class="keyword2">begin</span>
    <span class="keyword1">abbreviation</span> Graph_E <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; edge set&quot;</span>
      <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ E\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span>
    <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> E\&lt;rbrace&gt; &equiv; Graph.E c&quot;</span>
      
    <span class="keyword1">abbreviation</span> Graph_V <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node set&quot;</span> 
      <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ V\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span> 
    <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> V\&lt;rbrace&gt; &equiv; Graph.V c&quot;</span>
      
    <span class="keyword1">abbreviation</span> Graph_incoming <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node =&gt; edge set&quot;</span> 
      <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &delta;<span class="hidden">&#8679;</span><sup>+</sup>(_)\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span> 
    <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &delta;<span class="hidden">&#8679;</span><sup>+</sup> u\&lt;rbrace&gt; &equiv; Graph.incoming c u&quot;</span>
      
    <span class="keyword1">abbreviation</span> Graph_outgoing <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node =&gt; edge set&quot;</span> 
      <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &delta;<span class="hidden">&#8679;</span><sup>-</sup>(_)\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span>
    <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &delta;<span class="hidden">&#8679;</span><sup>-</sup> u\&lt;rbrace&gt; &equiv; Graph.outgoing c u&quot;</span>
      
    <span class="keyword1">abbreviation</span> Graph_delta <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node =&gt; edge set&quot;</span>
      <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &delta;(_)\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span> 
    <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &delta; u\&lt;rbrace&gt; &equiv; Graph.adjacent c u&quot;</span>
      
    <span class="keyword1">abbreviation</span> Graph_incoming&#39; <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node set =&gt; edge set&quot;</span> 
      <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &Delta;<span class="hidden">&#8679;</span><sup>+</sup>(_)\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span>
    <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &Delta;<span class="hidden">&#8679;</span><sup>+</sup> u\&lt;rbrace&gt; &equiv; Graph.incoming&#39; c u&quot;</span>  
    
    <span class="keyword1">abbreviation</span> Graph_outgoing&#39; <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node set =&gt; edge set&quot;</span> 
      <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &Delta;<span class="hidden">&#8679;</span><sup>-</sup>(_)\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span> 
    <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &Delta;<span class="hidden">&#8679;</span><sup>-</sup> u\&lt;rbrace&gt; &equiv; Graph.outgoing&#39; c u&quot;</span>
      
    <span class="keyword1">abbreviation</span> Graph_delta&#39; <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node set =&gt; edge set&quot;</span> 
      <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &Delta;(_)\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span> 
    <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &Delta; u\&lt;rbrace&gt; &equiv; Graph.adjacent&#39; c u&quot;</span>
    <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
    <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
    <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^END^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  <span class="keyword2">end</span>  
  
  <span class="keyword1">locale</span> Finite_Graph <span class="delimiter">=</span> Graph <span class="delimiter">+</span>
    <span class="keyword2">assumes</span> finite_V<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;finite V&quot;</span>

  
  <span class="comment">(* Path definitions *)</span>
  <span class="comment">(*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*)</span>
  <span class="comment">(*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*)</span>
  <span class="keyword1">type_synonym</span> path <span class="delimiter">=</span> <span class="string">&quot;edge list&quot;</span>
  
  <span class="keyword1">context</span> Graph
  <span class="keyword2">begin</span>
    <span class="keyword1">fun</span> isPath <span class="delimiter">::</span> <span class="string">&quot;node =&gt; path =&gt; node =&gt; bool&quot;</span> 
    <span class="keyword2">where</span>
      <span class="string">&quot;isPath u [] v &lt;-&gt; u = v&quot;</span>
    <span class="delimiter">|</span> <span class="string">&quot;isPath u ((x,y)#p) v &lt;-&gt; u = x &and; (x, y) &isin; E &and; isPath y p v&quot;</span>
  
    <span class="keyword1">fun</span> pathVertices <span class="delimiter">::</span> <span class="string">&quot;node =&gt; path =&gt; node list&quot;</span>
    <span class="keyword2">where</span>
      <span class="string">&quot;pathVertices u [] = [u]&quot;</span>
    <span class="delimiter">|</span> <span class="string">&quot;pathVertices u (e # es) = fst e # (pathVertices (snd e) es)&quot;</span>
    
    <span class="comment">(* TODO: This characterization is probably nicer to work with! Exchange! *)</span>
    <span class="keyword1">definition</span> <span class="delimiter">(</span><span class="keyword2">in</span> Graph<span class="delimiter">)</span> pathVertices_fwd <span class="delimiter">::</span> <span class="string">&quot;node =&gt; edge list =&gt; node list&quot;</span> 
      <span class="keyword2">where</span> <span class="string">&quot;pathVertices_fwd u p = u#map snd p&quot;</span>

    <span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> Graph<span class="delimiter">)</span> pathVertices_fwd<span class="delimiter">:</span> 
      <span class="keyword2">assumes</span> <span class="string">&quot;isPath u p v&quot;</span>
      <span class="keyword2">shows</span> <span class="string">&quot;pathVertices u p = pathVertices_fwd u p&quot;</span>
      <span class="keyword1">unfolding</span> pathVertices_fwd_def
      <span class="keyword1">using</span> assms <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>induction p arbitrary<span class="delimiter">:</span> u<span class="delimiter">)</span>
      <span class="keyword1">by</span> auto


    <span class="keyword1">definition</span> connected <span class="delimiter">::</span> <span class="string">&quot;node =&gt; node =&gt; bool&quot;</span> 
    <span class="keyword2">where</span> <span class="string">&quot;connected u v &equiv; &exist;p. isPath u p v&quot;</span> 
    
    <span class="keyword1">abbreviation</span> <span class="delimiter">(</span>input<span class="delimiter">)</span> <span class="string">&quot;isReachable &equiv; connected&quot;</span> <span class="comment">(* Deprecated *)</span>

    <span class="keyword1">definition</span> reachableNodes <span class="delimiter">::</span> <span class="string">&quot;node =&gt; node set&quot;</span>  
    <span class="keyword2">where</span> <span class="string">&quot;reachableNodes u &equiv; {v. connected u v}&quot;</span>
    
    <span class="keyword1">definition</span> isShortestPath <span class="delimiter">::</span> <span class="string">&quot;node =&gt; path =&gt; node =&gt; bool&quot;</span> 
    <span class="keyword2">where</span> <span class="string">&quot;isShortestPath u p v &equiv; isPath u p v &and; (&forall;p&#39;. isPath u p&#39; v --&gt; length p &le; length p&#39;)&quot;</span>
        
    <span class="keyword1">definition</span> isSimplePath <span class="delimiter">::</span> <span class="string">&quot;node =&gt; path =&gt; node =&gt; bool&quot;</span> 
    <span class="keyword2">where</span> <span class="string">&quot;isSimplePath u p v &equiv; isPath u p v &and; distinct (pathVertices u p)&quot;</span>

    <span class="keyword1">definition</span> dist <span class="delimiter">::</span> <span class="string">&quot;node =&gt; nat =&gt; node =&gt; bool&quot;</span> 
      <span class="delimiter">--</span> <span class="cartouche">&#8249;There is a path of given length between the nodes&#8250;</span>
      <span class="keyword2">where</span> <span class="string">&quot;dist v d v&#39; &equiv; &exist;p. isPath v p v&#39; &and; length p = d&quot;</span>

    <span class="keyword1">definition</span> min_dist <span class="delimiter">::</span> <span class="string">&quot;node =&gt; node =&gt; nat&quot;</span>
      <span class="delimiter">--</span> <span class="cartouche">&#8249;Minimum distance between two connected nodes&#8250;</span>
      <span class="keyword2">where</span> <span class="string">&quot;min_dist v v&#39; = (LEAST d. dist v d v&#39;)&quot;</span>

  <span class="keyword2">end</span>  

  <span class="keyword1">context</span> Graph_Loc_Syntax <span class="keyword2">begin</span>
    <span class="keyword1">notation</span> isPath <span class="delimiter">(</span><span class="string">&quot;&lang;\&lt;leadsto&gt;/ _,/ _,/ _&rang;&quot;</span>  1000<span class="delimiter">)</span>
    <span class="keyword1">notation</span> connected <span class="delimiter">(</span><span class="string">&quot;&lang;_/ \&lt;leadsto&gt;/ _&rang;&quot;</span> 1000<span class="delimiter">)</span>
    <span class="keyword1">notation</span> reachableNodes <span class="delimiter">(</span><span class="string">&quot;&lang;&lowast;/ _&rang;&quot;</span> 1000<span class="delimiter">)</span>
    <span class="keyword1">notation</span> isShortestPath <span class="delimiter">(</span><span class="string">&quot;&lang;-&gt;/ _,/ _,/ _&rang;&quot;</span> 1000<span class="delimiter">)</span> 
    <span class="keyword1">notation</span> isSimplePath <span class="delimiter">(</span><span class="string">&quot;&lang;=&gt;/ _,/ _,/ _&rang;&quot;</span> 1000<span class="delimiter">)</span>
  <span class="keyword2">end</span>

  <span class="keyword1">context</span> Graph_Syntax <span class="keyword2">begin</span>  
    <span class="keyword1">abbreviation</span> Graph_isPath <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node =&gt; path =&gt; node =&gt; bool&quot;</span> 
      <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &lang;\&lt;leadsto&gt; _, _, _&rang;\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span>
    <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &lang;\&lt;leadsto&gt; u, p, v&rang;\&lt;rbrace&gt; &equiv; Graph.isPath c u p v&quot;</span>
      
    <span class="keyword1">abbreviation</span> Graph_connected <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node =&gt; node =&gt; bool&quot;</span> 
      <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &lang;_/ \&lt;leadsto&gt;/ _&rang;\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span> 
    <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &lang;u \&lt;leadsto&gt; v&rang;\&lt;rbrace&gt; &equiv; Graph.connected c u v&quot;</span>
      
    <span class="keyword1">abbreviation</span> Graph_reachableNodes <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node =&gt; node set&quot;</span> 
      <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &lang;&lowast;/ _&rang;\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span> 
    <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &lang;&lowast; u&rang;\&lt;rbrace&gt; &equiv; Graph.reachableNodes c u&quot;</span>
      
    <span class="keyword1">abbreviation</span> Graph_isShortestPath <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node =&gt; path =&gt; node =&gt; bool&quot;</span> 
      <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &lang;-&gt; _, _, _&rang;\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span>
    <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &lang;-&gt; u, p, v&rang;\&lt;rbrace&gt; &equiv; Graph.isShortestPath c u p v&quot;</span>
      
    <span class="keyword1">abbreviation</span> Graph_isSimplePath <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node =&gt; path =&gt; node =&gt; bool&quot;</span>
      <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &lang;=&gt; _, _, _&rang;\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span> 
    <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &lang;=&gt; u, p, v&rang;\&lt;rbrace&gt; &equiv; Graph.isSimplePath c u p v&quot;</span>
  <span class="keyword2">end</span>  
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^END^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  
  <span class="comment">(* Graph lemmas *)</span>
  <span class="comment">(*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*)</span>
  <span class="comment">(*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*)</span>
  <span class="keyword1">context</span> Graph
  <span class="keyword2">begin</span>
    <span class="keyword1">lemma</span> V_alt<span class="delimiter">:</span> <span class="string">&quot;V = fst`E &cup; snd`E&quot;</span> <span class="keyword1">unfolding</span> V_def <span class="keyword1">by</span> force
    
    <span class="keyword1">lemma</span> E_ss_VxV<span class="delimiter">:</span> <span class="string">&quot;E &sube; V&times;V&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> V_def<span class="delimiter">)</span>

    <span class="keyword1">lemma</span> Vfin_imp_Efin<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="keyword2">assumes</span> <span class="string">&quot;finite V&quot;</span> <span class="keyword2">shows</span> <span class="string">&quot;finite E&quot;</span>
      <span class="keyword1">using</span> E_ss_VxV assms <span class="keyword1">by</span> <span class="delimiter">(</span>auto intro<span class="delimiter">:</span> finite_subset<span class="delimiter">)</span>

    <span class="keyword1">lemma</span> Efin_imp_Vfin<span class="delimiter">:</span> <span class="string">&quot;finite E ==&gt; finite V&quot;</span>
      <span class="keyword1">unfolding</span> V_alt <span class="keyword1">by</span> auto

    <span class="keyword1">lemma</span> zero_cap_simp<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;(u,v)&notin;E ==&gt; c (u,v) = 0&quot;</span>  
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> E_def<span class="delimiter">)</span>
  
    <span class="keyword1">text</span> <span class="cartouche">&#8249;We provide useful alternative characterizations for summation over 
        all incoming or outgoing edges.&#8250;</span>
    <span class="keyword1">lemma</span> sum_outgoing_pointwise<span class="delimiter">:</span> <span class="string">&quot;(&sum;e&isin;outgoing u. g e) = (&sum;v&isin;E``{u}. g (u,v))&quot;</span>  
    <span class="keyword1">proof</span> -
      <span class="keyword1">have</span> <span class="string">&quot;(&sum;e&isin;outgoing u. g e) = (&sum;e&isin;(&lambda;v. (u,v))`(E``{u}). g e)&quot;</span>  
        <span class="keyword1">by</span> <span class="delimiter">(</span>rule setsum.cong<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> outgoing_def<span class="delimiter">)</span>
      <span class="keyword1">also</span> <span class="keyword1">have</span> <span class="string">&quot;&hellip; = (&sum;v&isin;E``{u}. g (u,v))&quot;</span>  
        <span class="keyword1">by</span> <span class="delimiter">(</span>subst setsum.reindex<span class="delimiter">)</span> auto
      <span class="keyword1">finally</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">.</span>
    <span class="keyword1">qed</span>  
  
    <span class="keyword1">lemma</span> sum_incoming_pointwise<span class="delimiter">:</span> <span class="string">&quot;(&sum;e&isin;incoming u. g e) = (&sum;v&isin;E&macr;``{u}. g (v,u))&quot;</span>  
    <span class="keyword1">proof</span> -
      <span class="keyword1">have</span> <span class="string">&quot;(&sum;e&isin;incoming u. g e) = (&sum;e&isin;(&lambda;v. (v,u))`(E&macr;``{u}). g e)&quot;</span>  
        <span class="keyword1">by</span> <span class="delimiter">(</span>rule setsum.cong<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> incoming_def<span class="delimiter">)</span>
      <span class="keyword1">also</span> <span class="keyword1">have</span> <span class="string">&quot;&hellip; = (&sum;v&isin;E&macr;``{u}. g (v,u))&quot;</span>  
        <span class="keyword1">by</span> <span class="delimiter">(</span>subst setsum.reindex<span class="delimiter">)</span> auto
      <span class="keyword1">finally</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">.</span>
    <span class="keyword1">qed</span>  

    <span class="keyword1">text</span> <span class="cartouche">&#8249;When summation is done over something that satisfies the capacity 
      constraint, e.g., a flow, the summation can be extended to all 
      outgoing/incoming edges, as the additional edges must have zero capacity.&#8250;</span>
    <span class="comment">(* TODO: Clean up proofs *)</span>
    <span class="keyword1">lemma</span> sum_outgoing_alt<span class="delimiter">:</span> <span class="string">&quot;[|finite V; &forall;e. 0 &le; g e &and; g e &le; c e|] ==&gt;
      &forall;v &isin; V. (&sum;e &isin; outgoing v. g e) = (&sum;u &isin; V. g (v, u))&quot;</span>
      <span class="keyword1">proof</span> -
        <span class="keyword3">assume</span> asm1<span class="delimiter">:</span> <span class="string">&quot;finite V&quot;</span>
        <span class="keyword3">assume</span> asm2<span class="delimiter">:</span> <span class="string">&quot;&forall;e. 0 &le; g e &and; g e &le; c e&quot;</span>
        <span class="keyword1">{</span>
          <span class="keyword3">fix</span> v
          <span class="keyword3">assume</span> <span class="string">&quot;v &isin; V&quot;</span>
          <span class="keyword1">{</span>
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;{(v, u) | u. u &isin; V} &sube; V &times; V&quot;</span> <span class="keyword1">by</span> blast
            <span class="keyword1">then</span> <span class="keyword1">have</span> tmp1<span class="delimiter">:</span> <span class="string">&quot;finite {(v, u) | u. u &isin; V}&quot;</span> <span class="keyword1">using</span> asm1 finite_subset <span class="keyword1">by</span> simp
            <span class="keyword1">have</span> <span class="string">&quot;{(v, u) | u. u &isin; V &and; (v, u) &isin; E} &sube; {(v, u) | u. u &isin; V}&quot;</span> <span class="keyword1">by</span> blast
            <span class="keyword1">then</span> <span class="keyword1">have</span> f1<span class="delimiter">:</span><span class="string">&quot;finite {(v, u) | u. u &isin; V &and; (v, u) &isin; E}&quot;</span> <span class="keyword1">using</span> tmp1 finite_subset <span class="keyword1">by</span> auto
            <span class="keyword1">have</span> <span class="string">&quot;{(v, u) | u. u &isin; V &and; (v, u) &notin; E} &sube; {(v, u) | u. u &isin; V}&quot;</span> <span class="keyword1">by</span> blast
            <span class="keyword1">then</span> <span class="keyword1">have</span> f2<span class="delimiter">:</span><span class="string">&quot;finite {(v, u) | u. u &isin; V &and; (v, u) &notin; E}&quot;</span> <span class="keyword1">using</span> tmp1 finite_subset <span class="keyword1">by</span> auto
            <span class="keyword1">have</span> f3<span class="delimiter">:</span> <span class="string">&quot;{(v, u) | u. u &isin; V &and; (v, u) &isin; E} &cap; {(v, u) | u. u &isin; V &and; (v, u) &notin; E} = {}&quot;</span>
              <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;?S1 &cap; ?S2 = _&quot;</span><span class="delimiter">)</span> <span class="keyword1">by</span> blast          
            <span class="keyword1">note</span> f <span class="delimiter">=</span> setsum.union_disjoint<span class="delimiter">[</span>of <span class="var">?S1</span> <span class="var">?S2</span> g<span class="delimiter">]</span>
            <span class="keyword1">have</span> <span class="string">&quot;(&sum;e &isin; ?S1 &cup; ?S2. g e) = (&sum;e &isin; ?S1. g e) + (&sum;e &isin; ?S2. g e)&quot;</span>
              <span class="keyword1">using</span> f<span class="delimiter">[</span>OF f1 f2 f3<span class="delimiter">]</span> <span class="keyword1">by</span> simp
            <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;?S1 &cup; ?S2 = {(v, u) | u. u &isin; V}&quot;</span> <span class="keyword1">by</span> force
            <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;(&sum;e &isin; {(v, u) | u. u &isin; V}. g e) =
              (&sum;e &isin; ?S1. g e) + (&sum;e &isin; ?S2. g e)&quot;</span> <span class="keyword1">by</span> simp
          <span class="keyword1">}</span> <span class="keyword1">note</span> fct1 <span class="delimiter">=</span> this
          <span class="keyword1">{</span>
            <span class="keyword1">have</span> <span class="string">&quot;!!e. (e &isin; {(v, u) | u. u &isin; V &and; (v, u) &notin; E} ==&gt; g e = 0)&quot;</span>
              <span class="keyword1">proof</span> -
                <span class="keyword1">{</span>
                  <span class="keyword3">fix</span> e
                  <span class="keyword3">assume</span> asm<span class="delimiter">:</span> <span class="string">&quot;e &isin; {(v, u) | u. u &isin; V &and; (v, u) &notin; E}&quot;</span>
                  <span class="keyword1">have</span> <span class="string">&quot;g e = 0&quot;</span>
                    <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
                      <span class="keyword3">assume</span> <span class="string">&quot;&not; g e = 0&quot;</span>
                      <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;e &isin; E&quot;</span> <span class="keyword1">using</span> asm2 E_def
                        <span class="keyword1">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>mono_tags<span class="delimiter">,</span> lifting<span class="delimiter">)</span> antisym case_prodI2 mem_Collect_eq<span class="delimiter">)</span> 
                      <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;e &notin; {(v, u) | u. u &isin; V &and; (v, u) &notin; E}&quot;</span> <span class="keyword1">unfolding</span> E_def <span class="keyword1">by</span> auto
                      <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> asm <span class="keyword1">by</span> blast
                    <span class="keyword1">qed</span>
                <span class="keyword1">}</span>
                <span class="keyword1">then</span> <span class="keyword3">show</span> <span class="string">&quot;!!e. (e &isin; {(v, u) | u. u &isin; V &and; (v, u) &notin; E} ==&gt; g e = 0)&quot;</span> <span class="keyword1">by</span> simp
              <span class="keyword1">qed</span>
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(&sum;e &isin; {(v, u) | u. u &isin; V &and; (v, u) &notin; E}. g e) = 0&quot;</span> <span class="keyword1">by</span> auto
          <span class="keyword1">}</span> <span class="keyword1">note</span> fct2 <span class="delimiter">=</span> this
          <span class="keyword1">{</span>
            <span class="keyword1">have</span> <span class="string">&quot;{(v, u) | u. u &isin; V &and; (v, u) &isin; E} = {(v, u) | u. (v, u) &isin; E}&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;?L = ?R&quot;</span><span class="delimiter">)</span>
              <span class="keyword1">unfolding</span> V_def E_def <span class="keyword1">by</span> auto
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(&sum;e &isin; ?L. g e) = (&sum;e &isin; ?R. g e)&quot;</span> <span class="keyword1">by</span> simp
          <span class="keyword1">}</span> <span class="keyword1">note</span> fct3 <span class="delimiter">=</span> this
          <span class="keyword1">have</span> <span class="string">&quot;(&sum;e &isin; {(v, u) | u. (v, u) &isin; E}. g e) = (&sum;e &isin; {(v, u) | u. u &isin; V}. g e) &quot;</span>
            <span class="keyword1">using</span> fct1 fct2 fct3 <span class="keyword1">by</span> auto
          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;(&sum;e &isin; {(v, u) | u. u &isin; V}. g e) = (&sum;u &isin; {u | u. u &isin; V}. g (v, u))&quot;</span>
            <span class="keyword1">using</span> setsumExt.decomp_3<span class="delimiter">[</span>of V Pair g v<span class="delimiter">]</span> asm1 <span class="keyword1">by</span> auto
          <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;(&sum;e &isin; {(v, u) | u. (v, u) &isin; E}. g e) = 
            (&sum;u &isin; {u | u. u &isin; V}. g (v, u))&quot;</span> <span class="keyword1">by</span> auto
        <span class="keyword1">}</span>
        <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">unfolding</span> outgoing_def <span class="keyword1">by</span> auto
      <span class="keyword1">qed</span>
      
    <span class="keyword1">lemma</span> sum_incoming_alt<span class="delimiter">:</span> <span class="string">&quot;[|finite V; &forall;e. 0 &le; g e &and; g e &le; c e|] ==&gt;
      &forall;v &isin; V. (&sum;e &isin; incoming v. g e) = (&sum;u &isin; V. g (u, v))&quot;</span>
      <span class="keyword1">proof</span> -
        <span class="keyword3">assume</span> asm1<span class="delimiter">:</span> <span class="string">&quot;finite V&quot;</span>
        <span class="keyword3">assume</span> asm2<span class="delimiter">:</span> <span class="string">&quot;&forall;e. 0 &le; g e &and; g e &le; c e&quot;</span>
        <span class="keyword1">{</span>
          <span class="keyword3">fix</span> v
          <span class="keyword3">assume</span> <span class="string">&quot;v &isin; V&quot;</span>
          <span class="keyword1">{</span>
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;{(u, v) | u. u &isin; V} &sube; V &times; V&quot;</span> <span class="keyword1">by</span> blast
            <span class="keyword1">then</span> <span class="keyword1">have</span> tmp1<span class="delimiter">:</span> <span class="string">&quot;finite {(u, v) | u. u &isin; V}&quot;</span> <span class="keyword1">using</span> asm1 finite_subset <span class="keyword1">by</span> simp
            <span class="keyword1">have</span> <span class="string">&quot;{(u, v) | u. u &isin; V &and; (u, v) &isin; E} &sube; {(u, v) | u. u &isin; V}&quot;</span> <span class="keyword1">by</span> blast
            <span class="keyword1">then</span> <span class="keyword1">have</span> f1<span class="delimiter">:</span><span class="string">&quot;finite {(u, v) | u. u &isin; V &and; (u, v) &isin; E}&quot;</span> <span class="keyword1">using</span> tmp1 finite_subset <span class="keyword1">by</span> auto
            <span class="keyword1">have</span> <span class="string">&quot;{(u, v) | u. u &isin; V &and; (u, v) &notin; E} &sube; {(u, v) | u. u &isin; V}&quot;</span> <span class="keyword1">by</span> blast
            <span class="keyword1">then</span> <span class="keyword1">have</span> f2<span class="delimiter">:</span><span class="string">&quot;finite {(u, v) | u. u &isin; V &and; (u, v) &notin; E}&quot;</span> <span class="keyword1">using</span> tmp1 finite_subset <span class="keyword1">by</span> auto
            <span class="keyword1">have</span> f3<span class="delimiter">:</span> <span class="string">&quot;{(u, v) | u. u &isin; V &and; (u, v) &isin; E} &cap; {(u, v) | u. u &isin; V &and; (u, v) &notin; E} = {}&quot;</span>
              <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;?S1 &cap; ?S2 = _&quot;</span><span class="delimiter">)</span> <span class="keyword1">by</span> blast 
            <span class="keyword1">note</span> f <span class="delimiter">=</span> setsum.union_disjoint<span class="delimiter">[</span>of <span class="var">?S1</span> <span class="var">?S2</span> g<span class="delimiter">]</span>
            <span class="keyword1">have</span> <span class="string">&quot;(&sum;e &isin; ?S1 &cup; ?S2. g e) = (&sum;e &isin; ?S1. g e) + (&sum;e &isin; ?S2. g e)&quot;</span>
              <span class="keyword1">using</span> f<span class="delimiter">[</span>OF f1 f2 f3<span class="delimiter">]</span> <span class="keyword1">by</span> simp
            <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;?S1 &cup; ?S2 = {(u, v) | u. u &isin; V}&quot;</span> <span class="keyword1">by</span> force
            <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;(&sum;e &isin; {(u, v) | u. u &isin; V}. g e) =
              (&sum;e &isin; ?S1. g e) + (&sum;e &isin; ?S2. g e)&quot;</span> <span class="keyword1">by</span> simp
          <span class="keyword1">}</span> <span class="keyword1">note</span> fct1 <span class="delimiter">=</span> this
          <span class="keyword1">{</span>
            <span class="keyword1">have</span> <span class="string">&quot;!!e. (e &isin; {(u, v) | u. u &isin; V &and; (u, v) &notin; E} ==&gt; g e = 0)&quot;</span>
              <span class="keyword1">proof</span> -
                <span class="keyword1">{</span>
                  <span class="keyword3">fix</span> e
                  <span class="keyword3">assume</span> asm<span class="delimiter">:</span> <span class="string">&quot;e &isin; {(u, v) | u. u &isin; V &and; (u, v) &notin; E}&quot;</span>
                  <span class="keyword1">have</span> <span class="string">&quot;g e = 0&quot;</span>
                    <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
                      <span class="keyword3">assume</span> <span class="string">&quot;&not; g e = 0&quot;</span>
                      <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;e &isin; E&quot;</span> <span class="keyword1">using</span> asm2 E_def 
                         <span class="keyword1">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>mono_tags<span class="delimiter">,</span> lifting<span class="delimiter">)</span> antisym case_prodI2 mem_Collect_eq<span class="delimiter">)</span>
                      <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;e &notin; {(u, v) | u. u &isin; V &and; (u, v) &notin; E}&quot;</span> <span class="keyword1">unfolding</span> E_def <span class="keyword1">by</span> auto
                      <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> asm <span class="keyword1">by</span> blast
                    <span class="keyword1">qed</span>
                <span class="keyword1">}</span>
                <span class="keyword1">then</span> <span class="keyword3">show</span> <span class="string">&quot;!!e. (e &isin; {(u, v) | u. u &isin; V &and; (u, v) &notin; E} ==&gt; g e = 0)&quot;</span> <span class="keyword1">by</span> simp
              <span class="keyword1">qed</span>
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(&sum;e &isin; {(u, v) | u. u &isin; V &and; (u, v) &notin; E}. g e) = 0&quot;</span> <span class="keyword1">by</span> auto
          <span class="keyword1">}</span> <span class="keyword1">note</span> fct2 <span class="delimiter">=</span> this
          <span class="keyword1">{</span>
            <span class="keyword1">have</span> <span class="string">&quot;{(u, v) | u. u &isin; V &and; (u, v) &isin; E} = {(u, v) | u. (u, v) &isin; E}&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;?L = ?R&quot;</span><span class="delimiter">)</span>
              <span class="keyword1">unfolding</span> V_def E_def <span class="keyword1">by</span> auto
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(&sum;e &isin; ?L. g e) = (&sum;e &isin; ?R. g e)&quot;</span> <span class="keyword1">by</span> simp
          <span class="keyword1">}</span> <span class="keyword1">note</span> fct3 <span class="delimiter">=</span> this
          <span class="keyword1">have</span> <span class="string">&quot;(&sum;e &isin; {(u, v) | u. (u, v) &isin; E}. g e) = (&sum;e &isin; {(u, v) | u. u &isin; V}. g e) &quot;</span>
            <span class="keyword1">using</span> fct1 fct2 fct3 <span class="keyword1">by</span> auto
          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;(&sum;e &isin; {(u, v) | u. u &isin; V}. g e) = (&sum;u &isin; {u | u. u &isin; V}. g (u, v))&quot;</span>
            <span class="keyword1">using</span> setsumExt.decomp_3<span class="delimiter">[</span>of V <span class="string">&quot;&lambda;x y. (y, x)&quot;</span> g v<span class="delimiter">]</span> asm1 <span class="keyword1">by</span> auto
          <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;(&sum;e &isin; {(u, v) | u. (u, v) &isin; E}. g e) = 
            (&sum;u &isin; {u | u. u &isin; V}. g (u, v))&quot;</span> <span class="keyword1">by</span> auto
        <span class="keyword1">}</span>
        <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">unfolding</span> incoming_def <span class="keyword1">by</span> auto
      <span class="keyword1">qed</span>
  <span class="keyword2">end</span>


  <span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> Finite_Graph<span class="delimiter">)</span> finite_E<span class="delimiter">[</span>simp<span class="delimiter">,</span>intro<span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;finite E&quot;</span> <span class="keyword1">by</span> simp


  <span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> Graph<span class="delimiter">)</span> Finite_Graph_EI<span class="delimiter">:</span> <span class="string">&quot;finite E ==&gt; Finite_Graph c&quot;</span>
    <span class="keyword1"><span class="improper">apply</span></span> unfold_locales
    <span class="keyword1">by</span> <span class="delimiter">(</span>rule Efin_imp_Vfin<span class="delimiter">)</span>
  


  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^END^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  
  
  
  
  <span class="comment">(* Path lemmas *)</span>
  <span class="comment">(*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*)</span>
  <span class="comment">(*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*)</span>
  <span class="keyword1">context</span> Graph
  <span class="keyword2">begin</span> 
    <span class="keyword1">named_theorems</span> split_path_simps <span class="cartouche">&#8249;Simplification lemmas to split paths&#8250;</span>

    <span class="keyword1">lemma</span> transfer_path<span class="delimiter">:</span>
      <span class="delimiter">--</span> <span class="cartouche">&#8249;Transfer path to another graph&#8250;</span>
      <span class="keyword2">assumes</span> <span class="string">&quot;set p&cap;E &sube; Graph.E c&#39;&quot;</span>
      <span class="keyword2">assumes</span> <span class="string">&quot;isPath u p v&quot;</span>
      <span class="keyword2">shows</span> <span class="string">&quot;Graph.isPath c&#39; u p v&quot;</span>
      <span class="keyword1">using</span> assms
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>induction u p v rule<span class="delimiter">:</span> isPath.induct<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> Graph.isPath.simps<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">done</span></span>

    <span class="keyword1">lemma</span> isPath_append<span class="delimiter">[</span>split_path_simps<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;isPath u (p1 @ p2) v &lt;-&gt; (&exist;w. isPath u p1 w &and; isPath w p2 v)&quot;</span>  
      <span class="keyword1">by</span> <span class="delimiter">(</span>induction p1 arbitrary<span class="delimiter">:</span> u<span class="delimiter">)</span> auto 
      
    <span class="keyword1">lemma</span> isPath_head<span class="delimiter">[</span>split_path_simps<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;isPath u (e#p) v &lt;-&gt; fst e = u &and; e &isin; E &and; isPath (snd e) p v&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>cases e<span class="delimiter">)</span> auto

    <span class="keyword1">lemma</span> isPath_head2<span class="delimiter">:</span> <span class="string">&quot;isPath u (e#p) v ==&gt; (p = [] &or; (p &ne; [] &and; fst (hd p) = snd e))&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.isPath_head list.collapse<span class="delimiter">)</span>
      
    <span class="keyword1">lemma</span> isPath_tail<span class="delimiter">:</span> <span class="string">&quot;isPath u (p@[e]) v &lt;-&gt; isPath u p (fst e) &and; e &isin; E &and; snd e = v&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>induction p<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isPath_append isPath_head<span class="delimiter">)</span>
    
    <span class="keyword1">lemma</span> isPath_tail2<span class="delimiter">:</span> <span class="string">&quot;isPath u (p@[e]) v ==&gt; (p = [] &or; (p &ne; [] &and; snd (last p) = fst e))&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.isPath_tail append_butlast_last_id<span class="delimiter">)</span>
      
    <span class="comment">(* TODO: Really needed? *)</span>  
    <span class="keyword1">lemma</span> isPath_append_edge<span class="delimiter">:</span> <span class="string">&quot;isPath v p v&#39; ==&gt; (v&#39;,v&#39;&#39;)&isin;E ==&gt; isPath v (p@[(v&#39;,v&#39;&#39;)]) v&#39;&#39;&quot;</span>  
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isPath_append<span class="delimiter">)</span>

    <span class="keyword1">lemma</span> isPath_edgeset<span class="delimiter">:</span> <span class="string">&quot;[|isPath u p v; e &isin; set p|] ==&gt; e &isin; E&quot;</span>
      <span class="keyword1">using</span> E_def 
      <span class="keyword1">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>mono_tags<span class="delimiter">,</span> lifting<span class="delimiter">)</span> isPath_head isPath_append in_set_conv_decomp_first<span class="delimiter">)</span>
      
    <span class="keyword1">lemma</span> isPath_rtc<span class="delimiter">:</span> <span class="string">&quot;isPath u p v ==&gt; (u, v) &isin; E<span class="hidden">&#8679;</span><sup>*</sup>&quot;</span>
      <span class="keyword1">proof</span> <span class="delimiter">(</span>induction p arbitrary<span class="delimiter">:</span> u<span class="delimiter">)</span>
        <span class="keyword3">case</span> Nil
          <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">by</span> auto
      <span class="keyword1">next</span>
        <span class="keyword3">case</span> <span class="delimiter">(</span>Cons e es<span class="delimiter">)</span>
          <span class="keyword3">obtain</span> u1 u2 <span class="keyword2">where</span> <span class="string">&quot;e = (u1, u2)&quot;</span> <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases e<span class="delimiter">)</span> <span class="keyword1">by</span> auto
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;u = u1 &and; isPath u2 es v &and; (u1, u2) &isin; E&quot;</span>
            <span class="keyword1">using</span> isPath.simps<span class="delimiter">(</span>2<span class="delimiter">)</span> Cons.prems <span class="keyword1">by</span> auto
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(u, u2) &isin; E&quot;</span> <span class="keyword2">and</span> <span class="string">&quot;(u2, v) &isin; E<span class="hidden">&#8679;</span><sup>*</sup>&quot;</span> <span class="keyword1">using</span> Cons.IH <span class="keyword1">by</span> auto
          <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">by</span> auto 
      <span class="keyword1">qed</span>
      
    <span class="keyword1">lemma</span> rtc_isPath<span class="delimiter">:</span> <span class="string">&quot;(u, v) &isin; E<span class="hidden">&#8679;</span><sup>*</sup> ==&gt; (&exist;p. isPath u p v)&quot;</span>
      <span class="keyword1">proof</span> <span class="delimiter">(</span>induction rule<span class="delimiter">:</span> rtrancl.induct<span class="delimiter">)</span>
        <span class="keyword3">case</span> <span class="delimiter">(</span>rtrancl_refl a<span class="delimiter">)</span>
          <span class="keyword1">have</span> <span class="string">&quot;isPath a [] a&quot;</span> <span class="keyword1">by</span> simp
          <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">by</span> blast
      <span class="keyword1">next</span>
        <span class="keyword3">case</span> <span class="delimiter">(</span>rtrancl_into_rtrancl u u&#39; v<span class="delimiter">)</span>
          <span class="keyword1">then</span> <span class="keyword3">obtain</span> p1 <span class="keyword2">where</span> <span class="string">&quot;isPath u p1 u&#39;&quot;</span> <span class="keyword1">by</span> blast
          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;(u&#39;, v) &isin; E&quot;</span> <span class="keyword1">using</span> rtrancl_into_rtrancl.hyps<span class="delimiter">(</span>2<span class="delimiter">)</span> <span class="keyword1">by</span> simp
          <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;isPath u (p1 @ [(u&#39;, v)]) v&quot;</span> <span class="keyword1">using</span> isPath_tail <span class="keyword1">by</span> simp
          <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">by</span> blast
      <span class="keyword1">qed</span>
    
    <span class="keyword1">lemma</span> rtci_isPath<span class="delimiter">:</span> <span class="string">&quot;(v, u) &isin; (E&macr;)<span class="hidden">&#8679;</span><sup>*</sup> ==&gt; (&exist;p. isPath u p v)&quot;</span>
    <span class="keyword1">proof</span> -
      <span class="keyword3">assume</span> <span class="string">&quot;(v,u)&isin;(E&macr;)<span class="hidden">&#8679;</span><sup>*</sup>&quot;</span> 
      <span class="keyword1">hence</span> <span class="string">&quot;(u,v)&isin;E<span class="hidden">&#8679;</span><sup>*</sup>&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>rule rtrancl_converseD<span class="delimiter">)</span>
      <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> <span class="delimiter">(</span>rule rtc_isPath<span class="delimiter">)</span>
    <span class="keyword1">qed</span>      
      
    <span class="keyword1">lemma</span> isPath_ex_edge1<span class="delimiter">:</span> <span class="string">&quot;[|isPath u p v; (u1, v1) &isin; set p; u1 &ne; u|] ==&gt; &exist;u2. (u2, u1) &isin; set p&quot;</span>
      <span class="keyword1">proof</span> -
        <span class="keyword3">assume</span> asm1<span class="delimiter">:</span> <span class="string">&quot;isPath u p v&quot;</span>
        <span class="keyword3">assume</span> asm2<span class="delimiter">:</span> <span class="string">&quot;(u1, v1) &isin; set p&quot;</span>
        <span class="keyword3">assume</span> asm3<span class="delimiter">:</span> <span class="string">&quot;u1 &ne; u&quot;</span>
        <span class="keyword3">obtain</span> w1 w2 <span class="keyword2">where</span> obt1<span class="delimiter">:</span> <span class="string">&quot;p = w1 @ [(u1, v1)] @ w2&quot;</span> <span class="keyword1">using</span> asm2
          <span class="keyword1">by</span> <span class="delimiter">(</span>metis append_Cons append_Nil in_set_conv_decomp_first<span class="delimiter">)</span>
        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;isPath u w1 u1&quot;</span> <span class="keyword1">using</span> asm1 isPath_append <span class="keyword1">by</span> auto
        <span class="keyword1">have</span> <span class="string">&quot;w1 &ne; []&quot;</span>
          <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
            <span class="keyword3">assume</span> <span class="string">&quot;&not; w1 &ne; []&quot;</span>
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;u = u1&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`isPath u w1 u1`</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis isPath.simps<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> asm3 <span class="keyword1">by</span> blast
          <span class="keyword1">qed</span>
        <span class="keyword1">then</span> <span class="keyword3">obtain</span> e w1&#39; <span class="keyword2">where</span> obt2<span class="delimiter">:</span><span class="string">&quot;w1 = w1&#39; @ [e]&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis append_butlast_last_id<span class="delimiter">)</span>
        <span class="keyword1">then</span> <span class="keyword3">obtain</span> u2 <span class="keyword2">where</span> <span class="string">&quot;e = (u2, u1)&quot;</span> 
          <span class="keyword1">using</span> <span class="alt_string">`isPath u w1 u1`</span> isPath_tail <span class="keyword1">by</span> <span class="delimiter">(</span>metis prod.collapse<span class="delimiter">)</span>
        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;p = w1&#39; @ (u2, u1) # (u1, v1) # w2&quot;</span> <span class="keyword1">using</span> obt1 obt2 <span class="keyword1">by</span> auto 
        <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
      <span class="keyword1">qed</span>
    
    <span class="keyword1">lemma</span> isPath_ex_edge2<span class="delimiter">:</span> <span class="string">&quot;[|isPath u p v; (u1, v1) &isin; set p; v1 &ne; v|] ==&gt; &exist;v2. (v1, v2) &isin; set p&quot;</span>
      <span class="keyword1">proof</span> -
        <span class="keyword3">assume</span> asm1<span class="delimiter">:</span> <span class="string">&quot;isPath u p v&quot;</span>
        <span class="keyword3">assume</span> asm2<span class="delimiter">:</span> <span class="string">&quot;(u1, v1) &isin; set p&quot;</span>
        <span class="keyword3">assume</span> asm3<span class="delimiter">:</span> <span class="string">&quot;v1 &ne; v&quot;</span>
        <span class="keyword3">obtain</span> w1 w2 <span class="keyword2">where</span> obt1<span class="delimiter">:</span> <span class="string">&quot;p = w1 @ [(u1, v1)] @ w2&quot;</span> <span class="keyword1">using</span> asm2
          <span class="keyword1">by</span> <span class="delimiter">(</span>metis append_Cons append_Nil in_set_conv_decomp_first<span class="delimiter">)</span>
        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;isPath v1 w2 v&quot;</span> <span class="keyword1">using</span> asm1 isPath_append <span class="keyword1">by</span> auto
        <span class="keyword1">have</span> <span class="string">&quot;w2 &ne; []&quot;</span>
          <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
            <span class="keyword3">assume</span> <span class="string">&quot;&not; w2 &ne; []&quot;</span>
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;v = v1&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`isPath v1 w2 v`</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis isPath.simps<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> asm3 <span class="keyword1">by</span> blast
          <span class="keyword1">qed</span>
        <span class="keyword1">then</span> <span class="keyword3">obtain</span> e w2&#39; <span class="keyword2">where</span> obt2<span class="delimiter">:</span><span class="string">&quot;w2 =  e # w2&#39;&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis neq_Nil_conv<span class="delimiter">)</span>
        <span class="keyword1">then</span> <span class="keyword3">obtain</span> v2 <span class="keyword2">where</span> <span class="string">&quot;e = (v1, v2)&quot;</span> 
          <span class="keyword1">using</span> <span class="alt_string">`isPath v1 w2 v`</span> isPath_head <span class="keyword1">by</span> <span class="delimiter">(</span>metis prod.collapse<span class="delimiter">)</span>
        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;p = w1 @ (u1, v1) # (v1, v2) # w2&#39;&quot;</span> <span class="keyword1">using</span> obt1 obt2 <span class="keyword1">by</span> auto
        <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
       <span class="keyword1">qed</span>
  <span class="keyword2">end</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^END^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  
  
  
  
  <span class="comment">(* Path Vertices lemmas *)</span>
  <span class="comment">(*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*)</span>
  <span class="comment">(*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*)</span>
  <span class="keyword1">context</span> Graph
  <span class="keyword2">begin</span>   

    <span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> Graph<span class="delimiter">)</span> pathVertices_fwd_simps<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> 
      <span class="string">&quot;pathVertices_fwd s ([]) = [s]&quot;</span>  
      <span class="string">&quot;pathVertices_fwd s (e#p) = s#pathVertices_fwd (snd e) p&quot;</span>  
      <span class="string">&quot;pathVertices_fwd s (p@[e]) = pathVertices_fwd s p@[snd e]&quot;</span>
      <span class="string">&quot;pathVertices_fwd s (p1@e#p2) = pathVertices_fwd s p1 @ pathVertices_fwd (snd e) p2&quot;</span>
      <span class="string">&quot;s&isin;set (pathVertices_fwd s p)&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> pathVertices_fwd_def<span class="delimiter">)</span>



    <span class="keyword1">lemma</span> pathVertices_alt<span class="delimiter">:</span> <span class="string">&quot;p &ne; [] ==&gt; pathVertices u p = map fst p @ [snd (last p)]&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>induction p arbitrary<span class="delimiter">:</span> u<span class="delimiter">)</span> auto
    
    <span class="keyword1">lemma</span> pathVertices_singleton_iff<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;pathVertices s p = [u] &lt;-&gt; (p=[] &and; s=u)&quot;</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases p rule<span class="delimiter">:</span> rev_cases<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> pathVertices_alt<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">done</span></span>

    <span class="keyword1">lemma</span> length_pathVertices_eq<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;length (pathVertices u p) = length p + 1&quot;</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases <span class="string">&quot;p=[]&quot;</span><span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> pathVertices_alt<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">done</span></span>

    <span class="keyword1">lemma</span> pathVertices_edgeset<span class="delimiter">:</span> <span class="string">&quot;[|u&isin;V; isPath u p v|] ==&gt; set (pathVertices u p) &sube; V&quot;</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases p rule<span class="delimiter">:</span> rev_cases<span class="delimiter">;</span> simp<span class="delimiter">)</span>
      <span class="keyword1">using</span> isPath_edgeset<span class="delimiter">[</span>of u p v<span class="delimiter">]</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>fastforce simp<span class="delimiter">:</span> pathVertices_alt V_def<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">done</span></span>

    <span class="keyword1">lemma</span> pathVertices_append<span class="delimiter">:</span> <span class="string">&quot;pathVertices u (p1 @ p2) = 
      butlast (pathVertices u p1) @ pathVertices (last (pathVertices u p1)) p2&quot;</span>
      <span class="keyword1">proof</span> <span class="delimiter">(</span>induction p1 arbitrary<span class="delimiter">:</span> u<span class="delimiter">)</span>
        <span class="keyword3">case</span> Nil
          <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">by</span> auto
      <span class="keyword1">next</span>
        <span class="keyword3">case</span> <span class="delimiter">(</span>Cons e es<span class="delimiter">)</span>
          <span class="keyword1">have</span> <span class="string">&quot;pathVertices u ((e # es) @ p2) =  fst e # pathVertices (snd e) (es @ p2)&quot;</span>
            <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.pathVertices.simps<span class="delimiter">(</span>2<span class="delimiter">)</span> append_Cons<span class="delimiter">)</span>
          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;pathVertices (snd e) (es @ p2) =  butlast (pathVertices (snd e) es) @
            pathVertices (last (pathVertices (snd e) es)) p2&quot;</span> <span class="keyword1">using</span> Cons.IH <span class="keyword1">by</span> auto
          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;fst e # butlast (pathVertices (snd e) es) = 
            butlast (fst e # pathVertices (snd e) es)&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.pathVertices.simps<span class="delimiter">(</span>1<span class="delimiter">)</span>
            Graph.pathVertices_alt Nil_is_append_conv butlast.simps<span class="delimiter">(</span>2<span class="delimiter">)</span> list.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;fst e # pathVertices (snd e) es = pathVertices u (e # es)&quot;</span>
            <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.pathVertices.simps<span class="delimiter">(</span>2<span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;last (pathVertices (snd e) es) = last (pathVertices u (e # es))&quot;</span>
            <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.pathVertices.simps<span class="delimiter">(</span>1<span class="delimiter">)</span> Graph.pathVertices_alt 
            last.simps last_snoc list.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?case</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis append_Cons<span class="delimiter">)</span>
      <span class="keyword1">qed</span>
    
    <span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> Graph<span class="delimiter">)</span> split_path_at_vertex<span class="delimiter">:</span> 
      <span class="keyword2">assumes</span> <span class="string">&quot;u&isin;set (pathVertices_fwd s p)&quot;</span>
      <span class="keyword2">assumes</span> <span class="string">&quot;isPath s p t&quot;</span>
      <span class="keyword2">obtains</span> p1 p2 <span class="keyword2">where</span> <span class="string">&quot;p=p1@p2&quot;</span> <span class="string">&quot;isPath s p1 u&quot;</span> <span class="string">&quot;isPath u p2 t&quot;</span>
      <span class="keyword1">using</span> assms
      <span class="keyword1"><span class="improper">apply</span></span> -
      <span class="comment">(*unfolding pathVertices_fwd*)</span>
      <span class="keyword1">unfolding</span> pathVertices_fwd_def
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> in_set_conv_decomp isPath_append<span class="delimiter">)</span> 
      <span class="keyword1"><span class="improper">apply</span></span> force
      <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.isPath_append_edge append_Cons append_Nil append_assoc<span class="delimiter">)</span>


    <span class="keyword1">lemma</span> split_path_at_vertex_complete<span class="delimiter">:</span> 
      <span class="keyword2">assumes</span> <span class="string">&quot;isPath s p t&quot;</span> <span class="string">&quot;pathVertices_fwd s p = pv1@u#pv2&quot;</span> 
      <span class="keyword2">obtains</span> p1 p2 <span class="keyword2">where</span> 
        <span class="string">&quot;p=p1@p2&quot;</span> 
        <span class="string">&quot;isPath s p1 u&quot;</span> <span class="string">&quot;pathVertices_fwd s p1 = pv1@[u]&quot;</span> 
        <span class="string">&quot;isPath u p2 t&quot;</span> <span class="string">&quot;pathVertices_fwd u p2 = u#pv2&quot;</span> 
    <span class="keyword1">proof</span> -
      <span class="keyword1">from</span> assms <span class="keyword1">have</span> PV<span class="delimiter">:</span> <span class="string">&quot;pathVertices s p = pv1@u#pv2&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> pathVertices_fwd<span class="delimiter">)</span>
      <span class="keyword1">then</span> <span class="keyword3">obtain</span> p1 p2 <span class="keyword2">where</span> 
        <span class="string">&quot;p=p1@p2&quot;</span> 
        <span class="string">&quot;isPath s p1 u&quot;</span> <span class="string">&quot;pathVertices s p1 = pv1@[u]&quot;</span> 
        <span class="string">&quot;isPath u p2 t&quot;</span> <span class="string">&quot;pathVertices u p2 = u#pv2&quot;</span>
      <span class="keyword1">proof</span> -
        <span class="keyword3">show</span> thesis
        <span class="keyword1">using</span> assms<span class="delimiter">(</span>1<span class="delimiter">)</span> PV
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases p rule<span class="delimiter">:</span> rev_cases<span class="delimiter">;</span> clarsimp simp<span class="delimiter">:</span> pathVertices_alt<span class="delimiter">)</span>
          <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule that<span class="delimiter">[</span>of <span class="string">&quot;[]&quot;</span> <span class="string">&quot;[]&quot;</span><span class="delimiter">]</span><span class="delimiter">;</span> simp<span class="delimiter">)</span>

          <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases pv2<span class="delimiter">;</span> clarsimp<span class="delimiter">)</span>
          <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule that<span class="delimiter">[</span>of p <span class="string">&quot;[]&quot;</span><span class="delimiter">]</span><span class="delimiter">;</span> 
            auto simp add<span class="delimiter">:</span> isPath_append pathVertices_alt
          <span class="delimiter">)</span>  

          <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>clarsimp simp<span class="delimiter">:</span> append_eq_append_conv2<span class="delimiter">;</span> 
            auto elim<span class="delimiter">!</span><span class="delimiter">:</span> map_eq_concE map_eq_consE list_append_eq_Cons_cases
                simp<span class="delimiter">:</span> isPath_append<span class="delimiter">)</span>

            <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rename_tac l<span class="delimiter">)</span>
            <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>erule that<span class="delimiter">)</span> 
            <span class="keyword1"><span class="improper">apply</span></span> auto <span class="delimiter">[</span>4<span class="delimiter">]</span>
            <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>case_tac l rule<span class="delimiter">:</span> rev_cases<span class="delimiter">;</span> auto simp add<span class="delimiter">:</span> pathVertices_alt isPath_append<span class="delimiter">)</span>

            <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rename_tac l<span class="delimiter">)</span>
            <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>erule that<span class="delimiter">)</span> 
            <span class="keyword1"><span class="improper">apply</span></span> auto <span class="delimiter">[</span>4<span class="delimiter">]</span>
            <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>case_tac l rule<span class="delimiter">:</span> rev_cases<span class="delimiter">;</span> auto simp add<span class="delimiter">:</span> pathVertices_alt isPath_append<span class="delimiter">)</span>

            <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rename_tac l u1 u2 u3<span class="delimiter">)</span>
            <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>erule that<span class="delimiter">)</span>  
            <span class="keyword1"><span class="improper">apply</span></span> auto <span class="delimiter">[</span>4<span class="delimiter">]</span>
            <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>case_tac l rule<span class="delimiter">:</span> rev_cases<span class="delimiter">;</span> auto simp add<span class="delimiter">:</span> pathVertices_alt isPath_append<span class="delimiter">)</span>
            <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isPath_append<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
            <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> pathVertices_alt<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
            
            <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rename_tac l<span class="delimiter">)</span>
            <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>erule that<span class="delimiter">)</span> <span class="keyword1"><span class="improper">apply</span></span> auto <span class="delimiter">[</span>4<span class="delimiter">]</span>
            <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>case_tac l rule<span class="delimiter">:</span> rev_cases<span class="delimiter">;</span> auto simp add<span class="delimiter">:</span> pathVertices_alt isPath_append<span class="delimiter">)</span>
        <span class="keyword1"><span class="improper">done</span></span>
      <span class="keyword1">qed</span>
      <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1"><span class="improper">apply</span></span> - <span class="keyword1">unfolding</span> pathVertices_fwd <span class="keyword1">using</span> that <span class="keyword1">.</span>
    <span class="keyword1">qed</span>

    <span class="keyword1">lemma</span> isPath_fwd_cases<span class="delimiter">:</span> 
      <span class="keyword2">assumes</span> <span class="string">&quot;isPath s p t&quot;</span>
      <span class="keyword2">obtains</span> <span class="string">&quot;p=[]&quot;</span> <span class="string">&quot;t=s&quot;</span>
        <span class="delimiter">|</span> p&#39; u <span class="keyword2">where</span> <span class="string">&quot;p=(s,u)#p&#39;&quot;</span> <span class="string">&quot;(s,u)&isin;E&quot;</span> <span class="string">&quot;isPath u p&#39; t&quot;</span>
        <span class="keyword1">using</span> assms <span class="keyword1">by</span> <span class="delimiter">(</span>cases p<span class="delimiter">)</span> <span class="delimiter">(</span>auto<span class="delimiter">)</span>

    <span class="keyword1">lemma</span> isPath_bwd_cases<span class="delimiter">:</span> 
      <span class="keyword2">assumes</span> <span class="string">&quot;isPath s p t&quot;</span>
      <span class="keyword2">obtains</span> <span class="string">&quot;p=[]&quot;</span> <span class="string">&quot;t=s&quot;</span>
        <span class="delimiter">|</span> p&#39; u <span class="keyword2">where</span> <span class="string">&quot;p=p&#39;@[(u,t)]&quot;</span> <span class="string">&quot;isPath s p&#39; u&quot;</span> <span class="string">&quot;(u,t)&isin;E&quot;</span>
        <span class="keyword1">using</span> assms <span class="keyword1">by</span> <span class="delimiter">(</span>cases p rule<span class="delimiter">:</span> rev_cases<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> split_path_simps<span class="delimiter">)</span>


    <span class="keyword1">lemma</span> pathVertices_edge<span class="delimiter">:</span> <span class="string">&quot;isPath s p t ==&gt; e &isin; set p ==&gt; 
      &exist;vs1 vs2. pathVertices_fwd s p = vs1 @ fst e # snd e # vs2&quot;</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases e<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> in_set_conv_decomp split_path_simps<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>erule isPath_bwd_cases<span class="delimiter">[</span><span class="keyword2">where</span> s<span class="delimiter">=</span>s<span class="delimiter">]</span><span class="delimiter">;</span> auto<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>erule isPath_fwd_cases<span class="delimiter">[</span><span class="keyword2">where</span> t<span class="delimiter">=</span>t<span class="delimiter">]</span><span class="delimiter">;</span> auto<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>erule isPath_fwd_cases<span class="delimiter">[</span><span class="keyword2">where</span> t<span class="delimiter">=</span>t<span class="delimiter">]</span><span class="delimiter">;</span> auto<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">done</span></span>  


    <span class="comment">(* TODO: Really needed? *)</span>
    <span class="keyword1">lemma</span> pathVertices_edge_old<span class="delimiter">:</span> <span class="string">&quot;isPath u p v ==&gt; e &isin; set p ==&gt; 
      &exist;vs1 vs2. pathVertices u p = vs1 @ fst e # snd e # vs2&quot;</span>
      <span class="keyword1">proof</span> <span class="delimiter">(</span>induction p arbitrary<span class="delimiter">:</span> u<span class="delimiter">)</span>
        <span class="keyword3">case</span> Nil
          <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">by</span> auto
      <span class="keyword1">next</span>
        <span class="keyword3">case</span> <span class="delimiter">(</span>Cons x xs<span class="delimiter">)</span>
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;e = x &or; e &isin; set xs&quot;</span> <span class="keyword1">by</span> auto
          <span class="keyword3">thus</span> <span class="var">?case</span>
            <span class="keyword1">proof</span>
              <span class="keyword3">assume</span> <span class="string">&quot;e = x&quot;</span>
              <span class="keyword3">thus</span> <span class="var">?thesis</span>
                <span class="keyword1">proof</span> <span class="delimiter">(</span>cases <span class="string">&quot;set xs = {}&quot;</span><span class="delimiter">)</span>
                  <span class="keyword3">case</span> <span class="delimiter">(</span>True<span class="delimiter">)</span>
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;pathVertices u (x # xs) = [] @ fst e # snd e # []&quot;</span> 
                      <span class="keyword1">using</span> <span class="alt_string">`e = x`</span> <span class="keyword1">by</span> auto
                    <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
                <span class="keyword1">next</span>
                  <span class="keyword3">case</span> <span class="delimiter">(</span>False<span class="delimiter">)</span>
                    <span class="keyword1">then</span> <span class="keyword3">obtain</span> x&#39; xs&#39; <span class="keyword2">where</span> obt<span class="delimiter">:</span> <span class="string">&quot;xs = x&#39; # xs&#39;&quot;</span>
                      <span class="keyword1">by</span> <span class="delimiter">(</span>metis list.exhaust empty_set<span class="delimiter">)</span>
                    <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;isPath (snd x) xs v&quot;</span> <span class="keyword1">using</span> Cons.prems<span class="delimiter">(</span>1<span class="delimiter">)</span> isPath_head <span class="keyword1">by</span> auto
                    <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;snd e = fst x&#39;&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`e = x`</span> isPath_head <span class="keyword1">by</span> auto
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;pathVertices u (x # (xs)) = 
                      [] @ fst e # snd e # pathVertices (snd x&#39;) xs&#39;&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`e = x`</span> obt <span class="keyword1">by</span> auto
                    <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
                <span class="keyword1">qed</span>
            <span class="keyword1">next</span>
              <span class="keyword3">assume</span> <span class="string">&quot;e &isin; set xs&quot;</span>
              <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;isPath (snd x) xs v&quot;</span> <span class="keyword1">using</span> Cons.prems<span class="delimiter">(</span>1<span class="delimiter">)</span> isPath_head <span class="keyword1">by</span> auto
              <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;&exist;vs1 vs2. pathVertices (snd x) xs =
                vs1 @ fst e # snd e # vs2&quot;</span> <span class="keyword1">using</span> Cons.IH <span class="keyword1">by</span> auto
              <span class="keyword1">then</span> <span class="keyword3">obtain</span> vs1 vs2 <span class="keyword2">where</span> 
                obt<span class="delimiter">:</span> <span class="string">&quot;pathVertices (snd x) xs = vs1 @ fst e # snd e # vs2&quot;</span> <span class="keyword1">by</span> blast
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;pathVertices u (x # xs) = (fst x # vs1) @ fst e # snd e # vs2&quot;</span> <span class="keyword1">by</span> auto
              <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> metis
            <span class="keyword1">qed</span>
      <span class="keyword1">qed</span>
  <span class="keyword2">end</span> 
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^END^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  
  <span class="comment">(* Reachability lemmas *)</span>
  <span class="comment">(*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*)</span>
  <span class="comment">(*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*)</span>  
  <span class="keyword1">context</span> Graph
  <span class="keyword2">begin</span>
    <span class="keyword1">lemma</span> connected_refl<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;connected v v&quot;</span> 
      <span class="keyword1">unfolding</span> connected_def <span class="keyword1">by</span> <span class="delimiter">(</span>force intro<span class="delimiter">:</span> exI<span class="delimiter">[</span><span class="keyword2">where</span> x<span class="delimiter">=</span><span class="string">&quot;[]&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>

    <span class="keyword1">lemma</span> connected_append_edge<span class="delimiter">:</span> <span class="string">&quot;connected u v ==&gt; (v,w)&isin;E ==&gt; connected u w&quot;</span>
      <span class="keyword1">unfolding</span> connected_def <span class="keyword1">by</span> <span class="delimiter">(</span>auto intro<span class="delimiter">:</span> isPath_append_edge<span class="delimiter">)</span>

    <span class="keyword1">lemma</span> connected_inV_iff<span class="delimiter">:</span> <span class="string">&quot;[|connected u v|] ==&gt; v&isin;V &lt;-&gt; u&isin;V&quot;</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> connected_def<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>case_tac p<span class="delimiter">;</span> auto simp<span class="delimiter">:</span> V_def<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>case_tac p rule<span class="delimiter">:</span> rev_cases<span class="delimiter">;</span> auto simp<span class="delimiter">:</span> isPath_append V_def<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
      <span class="keyword1"><span class="improper">done</span></span>

    <span class="keyword1">lemma</span> connected_edgeRtc<span class="delimiter">:</span> <span class="string">&quot;connected u v &lt;-&gt; (u, v) &isin; E<span class="hidden">&#8679;</span><sup>*</sup>&quot;</span>  
    <span class="keyword1">proof</span>
      <span class="keyword3">assume</span> <span class="string">&quot;connected u v&quot;</span>
      <span class="keyword1">then</span> <span class="keyword3">obtain</span> p <span class="keyword2">where</span> <span class="string">&quot;isPath u p v&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp add<span class="delimiter">:</span> connected_def<span class="delimiter">)</span>
      <span class="keyword3">thus</span> <span class="string">&quot;(u,v)&isin;E<span class="hidden">&#8679;</span><sup>*</sup>&quot;</span>
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>induction p arbitrary<span class="delimiter">:</span> u<span class="delimiter">)</span>
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> intro<span class="delimiter">:</span> converse_rtrancl_into_rtrancl<span class="delimiter">)</span>
        <span class="keyword1"><span class="improper">done</span></span>
    <span class="keyword1">next</span>
      <span class="keyword3">assume</span> <span class="string">&quot;(u,v)&isin;E<span class="hidden">&#8679;</span><sup>*</sup>&quot;</span>
      <span class="keyword3">thus</span> <span class="string">&quot;connected u v&quot;</span>
        <span class="keyword1">proof</span> <span class="delimiter">(</span>induction rule<span class="delimiter">:</span> converse_rtrancl_induct<span class="delimiter">)</span>
          <span class="keyword3">case</span> <span class="delimiter">(</span>step y z<span class="delimiter">)</span>
            <span class="keyword1">from</span> step.IH <span class="keyword3">obtain</span> p <span class="keyword2">where</span> <span class="string">&quot;isPath z p v&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp add<span class="delimiter">:</span> connected_def<span class="delimiter">)</span>
            <span class="keyword1">moreover</span> <span class="keyword1">from</span> step.hyps <span class="keyword1">have</span> <span class="string">&quot;(y,z) &isin; E&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> <span class="delimiter">)</span>
            <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;isPath y ((y,z)#p) v&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isPath_head<span class="delimiter">)</span>
            <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">unfolding</span> connected_def <span class="keyword1">by</span> blast
        <span class="keyword1">qed</span> simp
    <span class="keyword1">qed</span>    


    <span class="keyword1">lemma</span> reachable_ss_V<span class="delimiter">:</span> <span class="string">&quot;s &isin; V ==&gt; reachableNodes s &sube; V&quot;</span>
      <span class="keyword1">proof</span>
        <span class="keyword3">assume</span> asm<span class="delimiter">:</span> <span class="string">&quot;s &isin; V&quot;</span>
        <span class="keyword3">fix</span> x
        <span class="keyword3">assume</span> <span class="string">&quot;x &isin; reachableNodes s&quot;</span>
        <span class="keyword1">then</span> <span class="keyword3">obtain</span> p <span class="keyword2">where</span> <span class="string">&quot;x &isin; {v. isPath s p v}&quot;</span>
          <span class="keyword1">unfolding</span> reachableNodes_def connected_def <span class="keyword1">by</span> blast
        <span class="keyword3">thus</span> <span class="string">&quot;x &isin; V&quot;</span> <span class="keyword1">using</span> asm
          <span class="keyword1">by</span> <span class="delimiter">(</span>induction p arbitrary<span class="delimiter">:</span> s<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isPath_head V_alt<span class="delimiter">)</span> 
      <span class="keyword1">qed</span>

    <span class="keyword1">lemma</span> reachableNodes_E_closed<span class="delimiter">:</span> <span class="string">&quot;E``reachableNodes s &sube; reachableNodes s&quot;</span>  
      <span class="keyword1">unfolding</span> reachableNodes_def <span class="keyword1">by</span> <span class="delimiter">(</span>auto intro<span class="delimiter">:</span> connected_append_edge<span class="delimiter">)</span>

    <span class="keyword1">corollary</span> reachableNodes_append_edge<span class="delimiter">:</span> 
      <span class="string">&quot;u&isin;reachableNodes s ==&gt; (u,v)&isin;E ==&gt; v&isin;reachableNodes s&quot;</span>
      <span class="keyword1">using</span> reachableNodes_E_closed <span class="keyword1">by</span> blast

  <span class="keyword2">end</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^END^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  
  
  
  
  <span class="comment">(* Simple path lemmas *)</span>
  <span class="comment">(*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*)</span>
  <span class="comment">(*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*)</span>
  <span class="keyword1">context</span> Graph
  <span class="keyword2">begin</span>          

    <span class="keyword1">lemma</span> isSimplePath_fwd<span class="delimiter">:</span> <span class="string">&quot;isSimplePath s p t &lt;-&gt; isPath s p t &and; distinct (pathVertices_fwd s p)&quot;</span>  
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_def pathVertices_fwd<span class="delimiter">)</span>

    <span class="keyword1">lemma</span> isSimplePath_singelton<span class="delimiter">[</span>split_path_simps<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;isSimplePath u [e] v &lt;-&gt; (e=(u,v) &and; u&ne;v &and; (u,v)&isin;E)&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_def isPath_head<span class="delimiter">)</span>

    <span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> Graph<span class="delimiter">)</span> isSimplePath_append<span class="delimiter">[</span>split_path_simps<span class="delimiter">]</span><span class="delimiter">:</span> 
      <span class="string">&quot;isSimplePath s (p1@p2) t 
        &lt;-&gt; (&exist;u. isSimplePath s p1 u &and; isSimplePath u p2 t &and; set (pathVertices_fwd s p1) &cap; set (pathVertices_fwd u p2) = {u})&quot;</span>  
      <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;_ &lt;-&gt; ?R&quot;</span><span class="delimiter">)</span>
      <span class="keyword1">unfolding</span> isSimplePath_fwd
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases p1 rule<span class="delimiter">:</span> rev_cases<span class="delimiter">;</span> simp<span class="delimiter">;</span> cases p2<span class="delimiter">;</span> simp<span class="delimiter">)</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> split_path_simps<span class="delimiter">)</span>
      
    <span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> Graph<span class="delimiter">)</span> isSimplePath_cons<span class="delimiter">[</span>split_path_simps<span class="delimiter">]</span><span class="delimiter">:</span> 
      <span class="string">&quot;isSimplePath s (e#p) t &lt;-&gt; (&exist;u. e=(s,u) &and; s&ne;u &and; (s,u)&isin;E &and; isSimplePath u p t &and; s&notin;set (pathVertices_fwd u p))&quot;</span>
      <span class="keyword1">using</span> isSimplePath_append<span class="delimiter">[</span>of s <span class="string">&quot;[e]&quot;</span> p t<span class="delimiter">,</span> simplified<span class="delimiter">]</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> split_path_simps<span class="delimiter">)</span>

    <span class="keyword1">lemma</span> simplePath_length_less_V<span class="delimiter">:</span>
      <span class="keyword2">assumes</span> FIN<span class="delimiter">:</span> <span class="string">&quot;finite V&quot;</span>
      <span class="keyword2">assumes</span> UIV<span class="delimiter">:</span> <span class="string">&quot;u&isin;V&quot;</span>
      <span class="keyword2">assumes</span> P<span class="delimiter">:</span> <span class="string">&quot;isSimplePath u p v&quot;</span> 
      <span class="keyword2">shows</span> <span class="string">&quot;length p &lt; card V&quot;</span>
    <span class="keyword1">proof</span> -
      <span class="keyword1">from</span> P <span class="keyword1">have</span> 1<span class="delimiter">:</span> <span class="string">&quot;isPath u p v&quot;</span> <span class="keyword2">and</span> 2<span class="delimiter">:</span> <span class="string">&quot;distinct (pathVertices u p)&quot;</span>
        <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_def<span class="delimiter">)</span>
      <span class="keyword1">from</span> pathVertices_edgeset<span class="delimiter">[</span>OF UIV 1<span class="delimiter">]</span> <span class="keyword1">have</span> <span class="string">&quot;set (pathVertices u p) &sube; V&quot;</span> <span class="keyword1">.</span>
      <span class="keyword1">with</span> 2 FIN <span class="keyword1">have</span> <span class="string">&quot;length (pathVertices u p) &le; card V&quot;</span>
        <span class="keyword1">using</span> distinct_card card_mono <span class="keyword1">by</span> metis
      <span class="keyword1">hence</span> <span class="string">&quot;length p + 1 &le; card V&quot;</span> <span class="keyword1">by</span> simp
      <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
    <span class="keyword1">qed</span>      

    <span class="keyword1">lemma</span> split_simple_path<span class="delimiter">:</span> <span class="string">&quot;isSimplePath u (p1@p2) v 
      ==&gt; (&exist;w. isSimplePath u p1 w &and; isSimplePath w p2 v)&quot;</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_def isPath_append<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule exI<span class="delimiter">;</span> intro conjI<span class="delimiter">;</span> assumption<span class="delimiter">?</span><span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases p1 rule<span class="delimiter">:</span> rev_cases<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
      <span class="keyword1"><span class="improper">apply</span></span> simp
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases p2<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> simp
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>clarsimp simp<span class="delimiter">:</span> pathVertices_alt isPath_append<span class="delimiter">)</span>

      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases p1 rule<span class="delimiter">:</span> rev_cases<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
      <span class="keyword1"><span class="improper">apply</span></span> simp
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases p2  rule<span class="delimiter">:</span> rev_cases<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> simp
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>clarsimp simp<span class="delimiter">:</span> pathVertices_alt isPath_append<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">done</span></span>  
      
    <span class="keyword1">lemma</span> simplePath_empty_conv<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;isSimplePath s [] t &lt;-&gt; s=t&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_def<span class="delimiter">)</span>

    <span class="keyword1">lemma</span> simplePath_same_conv<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;isSimplePath s p s &lt;-&gt; p=[]&quot;</span>  
      <span class="keyword1"><span class="improper">apply</span></span> rule
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases p<span class="delimiter">;</span> simp<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rename_tac e pp<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>case_tac pp rule<span class="delimiter">:</span> rev_cases<span class="delimiter">;</span> simp<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_def pathVertices_alt isPath_append<span class="delimiter">)</span> <span class="delimiter">[</span>2<span class="delimiter">]</span>
      <span class="keyword1"><span class="improper">apply</span></span> simp
      <span class="keyword1"><span class="improper">done</span></span>

    <span class="keyword1">lemma</span> isSPath_pathLE<span class="delimiter">:</span> <span class="string">&quot;isPath u p v ==&gt; &exist;p&#39;. isSimplePath u p&#39; v&quot;</span>
      <span class="keyword1">proof</span> <span class="delimiter">(</span>induction p arbitrary<span class="delimiter">:</span> u<span class="delimiter">)</span>
        <span class="keyword3">case</span> Nil
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;isSimplePath u [] v&quot;</span> <span class="keyword1">unfolding</span> isSimplePath_def <span class="keyword1">by</span> auto
          <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">by</span> auto
      <span class="keyword1">next</span>
        <span class="keyword3">case</span> <span class="delimiter">(</span>Cons e es<span class="delimiter">)</span>
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;isPath (snd e) es v&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.isPath_head<span class="delimiter">)</span>
          <span class="keyword1">then</span> <span class="keyword3">obtain</span> es&#39; <span class="keyword2">where</span> obt1<span class="delimiter">:</span> <span class="string">&quot;isSimplePath (snd e) es&#39; v&quot;</span> <span class="keyword1">using</span> Cons.IH <span class="keyword1">by</span> auto
          <span class="keyword1">have</span> fct0<span class="delimiter">:</span> <span class="string">&quot;fst e = u &and; e &isin; E&quot;</span> <span class="keyword1">using</span> Cons.prems <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.isPath_head<span class="delimiter">)</span>
          <span class="keyword1">have</span> fct1<span class="delimiter">:</span> <span class="string">&quot;isPath (snd e) es&#39; v&quot;</span> <span class="keyword1">using</span> obt1 isSimplePath_def <span class="keyword1">by</span> auto
          <span class="keyword1">have</span> fct2<span class="delimiter">:</span> <span class="string">&quot;distinct (pathVertices (snd e) es&#39;)&quot;</span> <span class="keyword1">using</span> obt1 isSimplePath_def <span class="keyword1">by</span> auto
          <span class="keyword1">have</span> <span class="string">&quot;distinct (pathVertices u (e # es&#39;)) &or; &not; distinct (pathVertices u (e # es&#39;))&quot;</span> <span class="keyword1">by</span> auto
          <span class="keyword3">thus</span> <span class="var">?case</span>
            <span class="keyword1">proof</span> 
              <span class="keyword3">assume</span> <span class="string">&quot;distinct (pathVertices u (e # es&#39;))&quot;</span>
              <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;isPath u (e # es&#39;) v&quot;</span> <span class="keyword1">using</span> fct0 fct1 <span class="keyword1">by</span> <span class="delimiter">(</span>metis isPath_head<span class="delimiter">)</span>
              <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;isSimplePath u (e # es&#39;) v&quot;</span> <span class="keyword1">unfolding</span> isSimplePath_def <span class="keyword1">by</span> auto
              <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> blast
            <span class="keyword1">next</span>
              <span class="keyword3">assume</span> <span class="string">&quot;&not; distinct (pathVertices u (e # es&#39;))&quot;</span>
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;fst e &isin; set (pathVertices (snd e) es&#39;)&quot;</span> <span class="keyword1">using</span> fct2 <span class="keyword1">by</span> auto
              <span class="keyword3">thus</span> <span class="var">?thesis</span>
                <span class="keyword1">proof</span> <span class="delimiter">(</span>cases <span class="string">&quot;es&#39; = []&quot;</span><span class="delimiter">)</span>
                  <span class="keyword3">case</span> True
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;e = (u, v)&quot;</span> <span class="keyword1">using</span> fct1 fct0 <span class="keyword1">by</span> <span class="delimiter">(</span>metis isPath.simps<span class="delimiter">(</span>1<span class="delimiter">)</span> prod.collapse<span class="delimiter">)</span>
                    <span class="keyword3">thus</span> <span class="var">?thesis</span>
                      <span class="keyword1">proof</span> <span class="delimiter">(</span>cases <span class="string">&quot;u &ne; v&quot;</span><span class="delimiter">)</span>
                        <span class="keyword3">case</span> True
                          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;distinct (pathVertices u [(u, v)])&quot;</span> <span class="keyword1">by</span> auto
                          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;isPath u [(u, v)] v&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`e = (u, v)`</span> fct0 <span class="keyword1">by</span> auto
                          <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;isSimplePath u [(u, v)] v&quot;</span> 
                            <span class="keyword1">unfolding</span> isSimplePath_def <span class="keyword1">by</span> auto
                          <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
                      <span class="keyword1">next</span>
                        <span class="keyword3">case</span> False
                          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;isPath u [] v&quot;</span> <span class="keyword1">by</span> auto
                          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;distinct (pathVertices u [])&quot;</span> <span class="keyword1">by</span> auto
                          <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;isSimplePath u [] v&quot;</span> <span class="keyword1">unfolding</span> isSimplePath_def <span class="keyword1">by</span> auto
                          <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
                      <span class="keyword1">qed</span>
                <span class="keyword1">next</span>
                  <span class="keyword3">case</span> False
                    <span class="keyword1">then</span> <span class="keyword3">obtain</span> x <span class="keyword2">where</span> <span class="string">&quot;fst e = x &and; x &isin; set ( map fst es&#39; @ [snd (last es&#39;)])&quot;</span> 
                      <span class="keyword1">using</span> <span class="alt_string">`fst e &isin; set (pathVertices (snd e) es&#39;)`</span> pathVertices_alt <span class="keyword1">by</span> auto
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(&exist;e&#39; &isin; set es&#39;. u = fst e&#39;) &or; u = snd (last es&#39;)&quot;</span> <span class="keyword1">using</span> fct0 <span class="keyword1">by</span> auto
                    <span class="keyword3">thus</span> <span class="var">?thesis</span>
                      <span class="keyword1">proof</span>
                        <span class="keyword3">assume</span> <span class="string">&quot;&exist;e&#39; &isin; set es&#39;. u = fst e&#39;&quot;</span>
                        <span class="keyword1">then</span> <span class="keyword3">obtain</span> e&#39; <span class="keyword2">where</span> <span class="string">&quot;e&#39; &isin; set es&#39; &and; u = fst e&#39;&quot;</span> <span class="keyword1">by</span> auto
                        <span class="keyword1">then</span> <span class="keyword3">obtain</span> w1 w2 <span class="keyword2">where</span> <span class="string">&quot;es&#39; = w1 @ (e&#39; # w2)&quot;</span> 
                          <span class="keyword1">by</span> <span class="delimiter">(</span>metis in_set_conv_decomp_first<span class="delimiter">)</span>
                        <span class="keyword1">then</span> <span class="keyword3">obtain</span> y  <span class="keyword2">where</span> <span class="string">&quot;isPath y (e&#39; # w2) v&quot;</span> 
                          <span class="keyword1">using</span> fct1 isPath_append <span class="keyword1">by</span> auto
                        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;y = u&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`e&#39; &isin; set es&#39; &and; u = fst e&#39;`</span> isPath_head <span class="keyword1">by</span> auto
                        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;isPath u (e&#39; # w2) v&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`isPath y (e&#39; # w2) v`</span> <span class="keyword1">by</span> auto
                        <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                          <span class="keyword1">note</span> pathVertices_append<span class="delimiter">[</span>of <span class="string">&quot;snd e&quot;</span> w1 <span class="string">&quot;e&#39; # w2&quot;</span><span class="delimiter">]</span>
                          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;pathVertices (snd e) es&#39; = butlast (pathVertices (snd e) w1) @ 
                            pathVertices (last (pathVertices (snd e) w1)) (e&#39; # w2)&quot;</span>
                            <span class="keyword1">using</span> <span class="alt_string">`es&#39; = w1 @ (e&#39; # w2)`</span> <span class="keyword1">by</span> auto
                          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;distinct ( pathVertices (last (pathVertices (snd e) w1))
                            (e&#39; # w2))&quot;</span> <span class="keyword1">using</span> fct2 <span class="keyword1">by</span> auto
                          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;pathVertices (last (pathVertices (snd e) w1))
                            (e&#39; # w2) = pathVertices u (e&#39; # w2)&quot;</span> <span class="keyword1">by</span> auto
                          <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;distinct (pathVertices u (e&#39; # w2))&quot;</span> <span class="keyword1">by</span> auto
                        <span class="keyword1">}</span>
                        <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;isSimplePath u (e&#39; # w2) v&quot;</span> 
                          <span class="keyword1">unfolding</span> isSimplePath_def <span class="keyword1">by</span> auto 
                        <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
                      <span class="keyword1">next</span>
                        <span class="keyword3">assume</span> <span class="string">&quot;u = snd (last es&#39;)&quot;</span>
                        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;u = v&quot;</span> <span class="keyword1">using</span> False fct1 
                          <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.isPath_tail snoc_eq_iff_butlast<span class="delimiter">)</span>
                        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;isPath u [] v&quot;</span> <span class="keyword1">by</span> auto
                        <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;distinct (pathVertices u [])&quot;</span> <span class="keyword1">by</span> auto
                        <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;isSimplePath u [] v&quot;</span> <span class="keyword1">unfolding</span> isSimplePath_def <span class="keyword1">by</span> auto
                        <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
                      <span class="keyword1">qed</span>
                <span class="keyword1">qed</span>
            <span class="keyword1">qed</span>
      <span class="keyword1">qed</span>  

    <span class="keyword1">lemma</span> isSPath_no_selfloop<span class="delimiter">:</span> <span class="string">&quot;isSimplePath u p v ==&gt; (u1, u1) &notin; set p&quot;</span>
      <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
        <span class="keyword3">assume</span> asm<span class="delimiter">:</span> <span class="string">&quot;isSimplePath u p v&quot;</span>
        <span class="keyword3">assume</span> <span class="string">&quot;&not; (u1, u1) &notin; set p&quot;</span>
        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(u1, u1) &isin; set p&quot;</span> <span class="keyword1">by</span> blast
        <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;isPath u p v&quot;</span> <span class="keyword1">using</span> asm isSimplePath_def <span class="keyword1">by</span> auto
        <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;&exist;vs1 vs2. pathVertices_fwd u p = vs1 @ u1 # u1 # vs2&quot;</span> 
          <span class="keyword1">using</span> pathVertices_edge <span class="keyword1">by</span> auto
        <span class="keyword1">then</span> <span class="keyword3">obtain</span> vs1 vs2 <span class="keyword2">where</span> <span class="string">&quot;pathVertices_fwd u p = vs1 @ u1 # u1 # vs2&quot;</span> <span class="keyword1">by</span> blast
        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not; distinct (pathVertices_fwd u p)&quot;</span> 
          <span class="keyword1">by</span> <span class="delimiter">(</span>metis distinct_append distinct_length_2_or_more<span class="delimiter">)</span>
        <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> asm isSimplePath_fwd <span class="keyword1">by</span> auto
      <span class="keyword1">qed</span>
      
    <span class="comment">(* TODO: There should be a much simpler proof! *)</span>  
    <span class="keyword1">lemma</span> isSPath_sg_outgoing<span class="delimiter">:</span> <span class="string">&quot;[|isSimplePath u p v; (u1, v1) &isin; set p; v1 &ne; v2|] ==&gt; (u1, v2) &notin; set p&quot;</span>
      <span class="keyword1">proof</span> -
        <span class="keyword3">assume</span> asm1<span class="delimiter">:</span> <span class="string">&quot;isSimplePath u p v&quot;</span>
        <span class="keyword3">assume</span> asm2<span class="delimiter">:</span> <span class="string">&quot;(u1, v1) &isin; set p&quot;</span>
        <span class="keyword3">assume</span> asm3<span class="delimiter">:</span> <span class="string">&quot;v1 &ne; v2&quot;</span>
        <span class="keyword3">show</span> <span class="var">?thesis</span>
          <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
            <span class="keyword3">assume</span> asm_s<span class="delimiter">:</span> <span class="string">&quot;&not; (u1, v2) &notin; set p&quot;</span>
            <span class="keyword3">obtain</span> w1 w2 <span class="keyword2">where</span> obt1<span class="delimiter">:</span> <span class="string">&quot;p = w1 @ (u1, v1) # w2&quot;</span> 
              <span class="keyword1">using</span> asm2 <span class="keyword1">by</span> <span class="delimiter">(</span>metis in_set_conv_decomp<span class="delimiter">)</span>
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(u1, v2) = (u1, v1) &or; ((u1, v2) &isin; (set w1) &or; (u1, v2) &isin; (set w2))&quot;</span> 
              <span class="keyword1">using</span> asm_s <span class="keyword1">by</span> <span class="delimiter">(</span>metis Un_iff set_ConsD set_append<span class="delimiter">)</span>
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(u1, v2) &isin; (set w1) &or; (u1, v2) &isin; (set w2)&quot;</span> <span class="keyword1">using</span> asm3 <span class="keyword1">by</span> auto
            <span class="keyword1">then</span> <span class="keyword3">show</span> <span class="string">&quot;False&quot;</span>
              <span class="keyword1">proof</span>
                <span class="keyword3">assume</span> <span class="string">&quot;(u1, v2) &isin; (set w1)&quot;</span>
                <span class="keyword1">note</span> pathVertices_append<span class="delimiter">[</span>of u w1 <span class="string">&quot;(u1, v1) # w2&quot;</span><span class="delimiter">]</span>
                <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                  <span class="keyword1">have</span> <span class="string">&quot;isPath u p v&quot;</span> <span class="keyword1">using</span> asm1 isSimplePath_def <span class="keyword1">by</span> auto
                  <span class="keyword1">then</span> <span class="keyword3">obtain</span> x <span class="keyword2">where</span> obt2<span class="delimiter">:</span> <span class="string">&quot;isPath u w1 x&quot;</span> 
                    <span class="keyword1">using</span> obt1 isPath_append<span class="delimiter">[</span>of u w1 <span class="string">&quot;(u1, v1) # w2&quot;</span><span class="delimiter">]</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">then</span> <span class="keyword3">obtain</span> vs1 vs2 <span class="keyword2">where</span> <span class="string">&quot;pathVertices u w1 = vs1 @ u1 # v2 # vs2&quot;</span> 
                    <span class="keyword1">using</span> pathVertices_edge_old<span class="delimiter">[</span>OF obt2 <span class="alt_string">`(u1, v2) &isin; (set w1)`</span><span class="delimiter">]</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&exist;vs1 vs2. butlast (pathVertices u w1) = vs1 @ u1 # vs2&quot;</span>
                    <span class="keyword1">by</span> <span class="delimiter">(</span>metis butlast.simps<span class="delimiter">(</span>2<span class="delimiter">)</span> butlast_append list.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword1">}</span>
                <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                  <span class="keyword1">have</span> <span class="string">&quot;pathVertices (last (pathVertices u w1)) ((u1, v1) # w2) = 
                    u1 # pathVertices v1 w2&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;?L = _&quot;</span><span class="delimiter">)</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&exist; vs1. ?L = u1 # vs1&quot;</span> <span class="keyword1">by</span> auto
                <span class="keyword1">}</span>
                <span class="keyword1">ultimately</span> <span class="keyword3">obtain</span> vs1 vs2 vs3 <span class="keyword2">where</span> <span class="string">&quot;pathVertices u p = vs1 @ u1 # vs2 @ u1 # vs3&quot;</span>
                  <span class="keyword1">using</span> obt1 <span class="keyword1">by</span> auto
                <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not; distinct (pathVertices u p)&quot;</span>
                  <span class="keyword1">by</span> <span class="delimiter">(</span>metis distinct.simps<span class="delimiter">(</span>2<span class="delimiter">)</span> distinct_append in_set_conv_decomp<span class="delimiter">)</span>
                <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> asm1 isSimplePath_def <span class="keyword1">by</span> auto 
              <span class="keyword1">next</span>
                <span class="keyword3">assume</span> <span class="string">&quot;(u1, v2) &isin; (set w2)&quot;</span>
                <span class="keyword1">note</span> pathVertices_append<span class="delimiter">[</span>of u <span class="string">&quot;w1 @ [(u1, v1)]&quot;</span> w2<span class="delimiter">]</span>
                <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                 <span class="keyword1">have</span> <span class="string">&quot;p = (w1 @ [(u1, v1)]) @ w2&quot;</span> <span class="keyword1">using</span> obt1 <span class="keyword1">by</span> auto
                 <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;isPath u ((w1 @ [(u1, v1)]) @ w2) v&quot;</span> <span class="keyword1">using</span> asm1 isSimplePath_def <span class="keyword1">by</span> auto
                 <span class="keyword1">then</span> <span class="keyword3">obtain</span> x <span class="keyword2">where</span> obt2<span class="delimiter">:</span> <span class="string">&quot;isPath u (w1 @ [(u1, v1)]) x &and; isPath x w2 v&quot;</span> 
                    <span class="keyword1">using</span> isPath_append<span class="delimiter">[</span>of u <span class="string">&quot;w1 @ [(u1, v1)]&quot;</span> w2 v<span class="delimiter">]</span> <span class="keyword1">by</span> auto
                 <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;x = v1&quot;</span> <span class="keyword1">using</span> isPath_tail <span class="keyword1">by</span> auto
                 <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;last (pathVertices u (w1 @ [(u1, v1)])) = v1&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;?L = _&quot;</span><span class="delimiter">)</span>
                  <span class="keyword1">using</span> pathVertices_alt <span class="keyword1">by</span> auto
                 <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;isPath ?L w2 v&quot;</span> <span class="keyword1">using</span> obt2 <span class="keyword1">by</span> auto
                 <span class="keyword1">note</span> pathVertices_edge_old<span class="delimiter">[</span>OF this <span class="alt_string">`(u1, v2) &isin; (set w2)`</span><span class="delimiter">]</span> 
                 <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&exist; vs1 vs2. pathVertices (last (pathVertices u 
                  (w1 @ [(u1, v1)]))) w2 = vs1 @ u1 # v2 # vs2&quot;</span> <span class="keyword1">by</span> auto 
                <span class="keyword1">}</span>
                <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                  <span class="keyword1">have</span> <span class="string">&quot;w1 @ [(u1, v1)] &ne; []&quot;</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;pathVertices u (w1 @ [(u1, v1)]) = map fst (w1 @ [(u1, v1)]) @ 
                    [snd (last (w1 @ [(u1, v1)]))]&quot;</span> <span class="keyword1">using</span> pathVertices_alt <span class="keyword1">by</span> auto
                  <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;map fst (w1 @ [(u1, v1)]) @ [snd (last (w1 @ [(u1, v1)]))] =
                    map fst w1 @ u1 # [v1]&quot;</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;&exist;vs1. butlast (pathVertices u (w1 @ [(u1, v1)])) = 
                    vs1 @ [u1]&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis append_Cons append_Nil append_assoc snoc_eq_iff_butlast<span class="delimiter">)</span>
                <span class="keyword1">}</span>
                <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;p = (w1 @ [(u1, v1)]) @ w2&quot;</span> <span class="keyword1">using</span> obt1 <span class="keyword1">by</span> auto
                <span class="keyword1">ultimately</span> <span class="keyword3">obtain</span> vs1 vs2 vs3 <span class="keyword2">where</span> <span class="string">&quot;pathVertices u p = vs1 @ [u1] @ vs2 @ 
                  u1 # v2 # vs3&quot;</span> <span class="keyword1">by</span> auto
                <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not; distinct (pathVertices u p)&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis append_Cons append_Nil
                  distinct.simps<span class="delimiter">(</span>2<span class="delimiter">)</span> distinct_append in_set_conv_decomp<span class="delimiter">)</span>
                <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> asm1 isSimplePath_def <span class="keyword1">by</span> auto 
              <span class="keyword1">qed</span>
          <span class="keyword1">qed</span>
      <span class="keyword1">qed</span>
      
    <span class="comment">(* TODO: There should be a much simpler proof! *)</span>  
    <span class="keyword1">lemma</span> isSPath_sg_incoming<span class="delimiter">:</span> <span class="string">&quot;[|isSimplePath u p v; (u1, v1) &isin; set p; u1 &ne; u2|] ==&gt; (u2, v1) &notin; set p&quot;</span>
      <span class="keyword1">proof</span> -
        <span class="keyword3">assume</span> asm1<span class="delimiter">:</span> <span class="string">&quot;isSimplePath u p v&quot;</span>
        <span class="keyword3">assume</span> asm2<span class="delimiter">:</span> <span class="string">&quot;(u1, v1) &isin; set p&quot;</span>
        <span class="keyword3">assume</span> asm3<span class="delimiter">:</span> <span class="string">&quot;u1 &ne; u2&quot;</span>
        <span class="keyword3">show</span> <span class="var">?thesis</span>
          <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
            <span class="keyword3">assume</span> asm_s<span class="delimiter">:</span> <span class="string">&quot;&not; (u2, v1) &notin; set p&quot;</span>
            <span class="keyword3">obtain</span> w1 w2 <span class="keyword2">where</span> obt1<span class="delimiter">:</span> <span class="string">&quot;p = w1 @ (u1, v1) # w2&quot;</span> 
              <span class="keyword1">using</span> asm2 <span class="keyword1">by</span> <span class="delimiter">(</span>metis in_set_conv_decomp<span class="delimiter">)</span>
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(u2, v1) = (u1, v1) &or; ((u2, v1) &isin; (set w1) &or; (u2, v1) &isin; (set w2))&quot;</span> 
              <span class="keyword1">using</span> asm_s <span class="keyword1">by</span> <span class="delimiter">(</span>metis Un_iff set_ConsD set_append<span class="delimiter">)</span>
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(u2, v1) &isin; (set w1) &or; (u2, v1) &isin; (set w2)&quot;</span> <span class="keyword1">using</span> asm3 <span class="keyword1">by</span> auto
            <span class="keyword1">then</span> <span class="keyword3">show</span> <span class="string">&quot;False&quot;</span>
              <span class="keyword1">proof</span>
                <span class="keyword3">assume</span> <span class="string">&quot;(u2, v1) &isin; (set w1)&quot;</span>
                <span class="keyword1">note</span> pathVertices_append<span class="delimiter">[</span>of u w1 <span class="string">&quot;(u1, v1) # w2&quot;</span><span class="delimiter">]</span>
                <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                  <span class="keyword1">have</span> <span class="string">&quot;isPath u p v&quot;</span> <span class="keyword1">using</span> asm1 isSimplePath_def <span class="keyword1">by</span> auto
                  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;isPath u w1 u1&quot;</span> 
                    <span class="keyword1">using</span> obt1 isPath_append<span class="delimiter">[</span>of u w1 <span class="string">&quot;(u1, v1) # w2&quot;</span><span class="delimiter">]</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">then</span> <span class="keyword3">obtain</span> vs1 vs2 <span class="keyword2">where</span> obt2<span class="delimiter">:</span> <span class="string">&quot;pathVertices u w1 = vs1 @ u2 # v1 # vs2&quot;</span> 
                    <span class="keyword1">using</span> pathVertices_edge_old<span class="delimiter">[</span>OF _ <span class="alt_string">`(u2, v1) &isin; (set w1)`</span><span class="delimiter">]</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis fst_conv snd_conv<span class="delimiter">)</span>
                  <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                    <span class="keyword1">have</span> <span class="string">&quot;snd (last w1) = u1&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`isPath u w1 u1`</span> <span class="alt_string">`(u2, v1) &isin; set w1`</span> 
                      <span class="keyword1">by</span> <span class="delimiter">(</span>metis isPath_tail append_butlast_last_id empty_iff list.set<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="keyword1">have</span> <span class="string">&quot;vs2 &ne; []&quot;</span>
                      <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
                        <span class="keyword3">assume</span> <span class="string">&quot;&not; vs2 &ne; []&quot;</span>
                        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;pathVertices u w1 = vs1 @ u2 # v1 # []&quot;</span> <span class="keyword1">using</span> obt2 <span class="keyword1">by</span> auto
                        <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;pathVertices u w1 = map fst w1 @ [snd (last w1)]&quot;</span> 
                          <span class="keyword1">using</span> <span class="alt_string">`(u2, v1) &isin; (set w1)`</span> pathVertices_alt<span class="delimiter">[</span>of w1 u<span class="delimiter">]</span> 
                          <span class="keyword1">by</span> <span class="delimiter">(</span>metis empty_iff list.set<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span> 
                        <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;snd (last w1) = v1&quot;</span> 
                          <span class="keyword1">by</span> <span class="delimiter">(</span>metis last.simps last_appendR list.distinct<span class="delimiter">(</span>2<span class="delimiter">)</span><span class="delimiter">)</span>
                        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;u1 = v1&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`snd (last w1) = u1`</span> <span class="keyword1">by</span> auto
                        <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> isSPath_no_selfloop<span class="delimiter">[</span>OF asm1<span class="delimiter">]</span> asm2 <span class="keyword1">by</span> auto 
                      <span class="keyword1">qed</span>
                  <span class="keyword1">}</span>
                  <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;&exist;vs1 vs2. butlast (pathVertices u w1) = vs1 @ u2 # v1 # vs2&quot;</span>
                    <span class="keyword1">by</span> <span class="delimiter">(</span>metis butlast.simps<span class="delimiter">(</span>2<span class="delimiter">)</span> butlast_append list.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword1">}</span>
                <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                  <span class="keyword1">have</span> <span class="string">&quot;pathVertices (last (pathVertices u w1)) ((u1, v1) # w2) = 
                    pathVertices u1 ((u1, v1) # w2)&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;?L = _&quot;</span><span class="delimiter">)</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                    <span class="keyword1">have</span> <span class="string">&quot;isPath u p v&quot;</span> <span class="keyword1">using</span> asm1 isSimplePath_def <span class="keyword1">by</span> auto
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;isPath u1 ((u1, v1) # w2) v&quot;</span> 
                      <span class="keyword1">using</span> obt1 isPath_append<span class="delimiter">[</span>of u w1 <span class="string">&quot;(u1, v1) # w2&quot;</span><span class="delimiter">]</span> <span class="keyword1">by</span> auto
                    <span class="keyword1">note</span> pathVertices_edge_old<span class="delimiter">[</span>OF this<span class="delimiter">]</span>
                  <span class="keyword1">}</span>
                  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&exist; vs1 vs2. ?L = vs1 @ u1 # v1 # vs2&quot;</span> <span class="keyword1">by</span> auto
                <span class="keyword1">}</span>
                <span class="keyword1">ultimately</span> <span class="keyword3">obtain</span> vs1 vs2 vs3 vs4 <span class="keyword2">where</span> 
                  <span class="string">&quot;pathVertices u p = vs1 @ u2 # v1 # vs2 @ vs3 @ u1 # v1 # vs4&quot;</span> <span class="keyword1">using</span> obt1 <span class="keyword1">by</span> auto
                <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not; distinct (pathVertices u p)&quot;</span> <span class="keyword1">by</span> auto
                <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> asm1 isSimplePath_def <span class="keyword1">by</span> auto 
              <span class="keyword1">next</span>
                <span class="keyword3">assume</span> <span class="string">&quot;(u2, v1) &isin; (set w2)&quot;</span>
                <span class="keyword1">note</span> pathVertices_append<span class="delimiter">[</span>of u <span class="string">&quot;w1 @ [(u1, v1)]&quot;</span> w2<span class="delimiter">]</span>
                <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                  <span class="keyword1">have</span> <span class="string">&quot;isPath u p v&quot;</span> <span class="keyword1">using</span> asm1 isSimplePath_def <span class="keyword1">by</span> auto
                  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;isPath v1 w2 v&quot;</span> 
                    <span class="keyword1">using</span> obt1 isPath_append<span class="delimiter">[</span>of u w1 <span class="string">&quot;(u1, v1) # w2&quot;</span><span class="delimiter">]</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">{</span>
                    <span class="keyword3">obtain</span> x w2&#39; <span class="keyword2">where</span> obt2<span class="delimiter">:</span> <span class="string">&quot;w2 = x # w2&#39;&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`(u2, v1) &isin; (set w2)`</span>
                      <span class="keyword1">by</span> <span class="delimiter">(</span>metis empty_iff list.collapse list.set<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;fst x = v1&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.isPath_head <span class="alt_string">`isPath v1 w2 v`</span><span class="delimiter">)</span>
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;x &ne; (u2, v1)&quot;</span> <span class="keyword1">using</span> isSPath_no_selfloop<span class="delimiter">[</span>OF asm1<span class="delimiter">]</span> obt1 obt2
                      <span class="keyword1">by</span> <span class="delimiter">(</span>metis asm_s fst_conv<span class="delimiter">)</span>
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(u2, v1) &isin; set w2&#39;&quot;</span> <span class="keyword1">using</span> obt2 <span class="alt_string">`(u2, v1) &isin; (set w2)`</span>
                      <span class="keyword1">by</span> <span class="delimiter">(</span>metis set_ConsD<span class="delimiter">)</span>
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&exist;x w2&#39;. w2 = (v1, x) # w2&#39; &and; (u2, v1) &isin; (set w2&#39;)&quot;</span>
                      <span class="keyword1">using</span> obt2 <span class="alt_string">`fst x = v1`</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis PairE fst_conv<span class="delimiter">)</span>
                  <span class="keyword1">}</span> 
                  <span class="keyword1">from</span> this <span class="keyword3">obtain</span> x w2&#39; <span class="keyword2">where</span> obt2<span class="delimiter">:</span> 
                    <span class="string">&quot;w2 = (v1, x) # w2&#39; &and; (u2, v1) &isin; set w2&#39;&quot;</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;isPath x w2&#39; v &and; (u2, v1) &isin; set w2&#39;&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`isPath v1 w2 v`</span> <span class="keyword1">by</span> auto 
                  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&exist;vs1 vs2. pathVertices x w2&#39; = vs1 @ u2 # v1 # vs2&quot;</span>
                    <span class="keyword1">using</span> pathVertices_edge_old <span class="keyword1">by</span> auto
                  <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;pathVertices (last (pathVertices u (w1 @ [(u1, v1)]))) w2 = 
                    v1 # pathVertices x w2&#39;&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;?L= _&quot;</span><span class="delimiter">)</span> <span class="keyword1">using</span> obt2 <span class="keyword1">by</span> auto
                  <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;&exist;vs1 vs2. ?L = v1 # vs1 @ u2 # v1 # vs2&quot;</span> <span class="keyword1">by</span> auto
                <span class="keyword1">}</span>
                <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;p = (w1 @ [(u1, v1)]) @ w2&quot;</span> <span class="keyword1">using</span> obt1 <span class="keyword1">by</span> auto
                <span class="keyword1">ultimately</span> <span class="keyword3">obtain</span> vs1 vs2 vs3 <span class="keyword2">where</span> 
                  <span class="string">&quot;pathVertices u p = vs1 @ v1 # vs2 @ u2 # v1 # vs3&quot;</span> <span class="keyword1">by</span> auto
                <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not; distinct (pathVertices u p)&quot;</span> <span class="keyword1">by</span> auto
                <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> asm1 isSimplePath_def <span class="keyword1">by</span> auto 
              <span class="keyword1">qed</span>
          <span class="keyword1">qed</span>
      <span class="keyword1">qed</span>  
      
    <span class="comment">(* TODO: There should be a much simpler proof! *)</span>  
    <span class="keyword1">lemma</span> isSPath_no_returning<span class="delimiter">:</span> <span class="string">&quot;[|isSimplePath u p v; (u1, v1) &isin; set p|] ==&gt;
      (&exist;es1 es2. p = es1 @ (v2, u1) # (u1, v1) # es2 &or; (v2, u1) &notin; set p)&quot;</span>
      <span class="keyword1">proof</span> -
        <span class="keyword3">assume</span> asm1<span class="delimiter">:</span> <span class="string">&quot;isSimplePath u p v&quot;</span>
        <span class="keyword3">assume</span> asm2<span class="delimiter">:</span> <span class="string">&quot;(u1, v1) &isin; set p&quot;</span>
        <span class="keyword3">show</span> <span class="var">?thesis</span>
          <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
            <span class="keyword3">assume</span> asm_s<span class="delimiter">:</span> <span class="string">&quot;&not; (&exist;es1 es2. p = es1 @ (v2, u1) # (u1, v1) # es2 &or; (v2, u1) &notin; set p)&quot;</span>
            <span class="keyword1">have</span> asm_s1<span class="delimiter">:</span> <span class="string">&quot;&forall; es1 es2. p &ne; es1 @ (v2, u1) # (u1, v1) # es2&quot;</span> <span class="keyword1">using</span> asm_s <span class="keyword1">by</span> auto
            <span class="keyword1">have</span> asm_s2<span class="delimiter">:</span> <span class="string">&quot;(v2, u1) &isin; set p&quot;</span> <span class="keyword1">using</span> asm_s <span class="keyword1">by</span> auto 
            <span class="keyword3">obtain</span> w1 w2 <span class="keyword2">where</span> obt1<span class="delimiter">:</span> <span class="string">&quot;p = w1 @ (u1, v1) # w2&quot;</span> 
              <span class="keyword1">using</span> asm2 <span class="keyword1">by</span> <span class="delimiter">(</span>metis in_set_conv_decomp<span class="delimiter">)</span>
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(v2, u1) = (u1, v1) &or; ((v2, u1) &isin; (set w1) &or; (v2, u1) &isin; (set w2))&quot;</span> 
              <span class="keyword1">using</span> asm_s2 <span class="keyword1">by</span> <span class="delimiter">(</span>metis Un_iff set_ConsD set_append<span class="delimiter">)</span>
            <span class="keyword1">then</span> <span class="keyword3">show</span> <span class="string">&quot;False&quot;</span>
              <span class="keyword1">proof</span> 
                <span class="keyword3">assume</span> <span class="string">&quot;(v2, u1) = (u1, v1)&quot;</span>
                <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(u1, u1) &isin; set p&quot;</span> <span class="keyword1">using</span> asm2 <span class="keyword1">by</span> auto 
                <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> asm1 isSPath_no_selfloop <span class="keyword1">by</span> auto
              <span class="keyword1">next</span>
                <span class="keyword3">assume</span> <span class="string">&quot;(v2, u1) &isin; (set w1) &or; (v2, u1) &isin; (set w2)&quot;</span>
                <span class="keyword3">thus</span> <span class="var">?thesis</span>
                  <span class="keyword1">proof</span>
                    <span class="keyword3">assume</span> <span class="string">&quot;(v2, u1) &isin; (set w1)&quot;</span>
                    <span class="keyword1">have</span> <span class="string">&quot;pathVertices u p = butlast (pathVertices u w1) @  pathVertices (last 
                      (pathVertices u w1)) ((u1, v1) # w2)&quot;</span> <span class="keyword1">using</span> obt1 pathVertices_append <span class="keyword1">by</span> auto
                    <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                      <span class="keyword1">have</span> <span class="string">&quot;set w1 &ne; {}&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`(v2, u1) &isin; (set w1)`</span> <span class="keyword1">by</span> auto
                      <span class="keyword1">{</span>
                        <span class="keyword3">obtain</span> x <span class="keyword2">where</span> <span class="string">&quot;isPath u w1 x&quot;</span> 
                          <span class="keyword1">using</span> obt1 asm1 isSimplePath_def isPath_append <span class="keyword1">by</span> auto
                        <span class="keyword1">note</span> pathVertices_edge_old<span class="delimiter">[</span>OF this <span class="alt_string">`(v2, u1) &isin; (set w1)`</span><span class="delimiter">]</span>
                      <span class="keyword1">}</span>
                      <span class="keyword1">then</span> <span class="keyword3">obtain</span> vs1 vs2 <span class="keyword2">where</span> 
                        obt2<span class="delimiter">:</span> <span class="string">&quot;pathVertices u w1 = vs1 @ fst (v2, u1) # snd (v2, u1) # vs2&quot;</span> <span class="keyword1">by</span> auto
                      <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;vs2 &ne; []&quot;</span>
                        <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
                          <span class="keyword3">assume</span> <span class="string">&quot;&not; vs2 &ne; []&quot;</span>
                          <span class="keyword1">then</span> <span class="keyword1">have</span> fct1<span class="delimiter">:</span> <span class="string">&quot;pathVertices u w1 = vs1 @ [v2, u1]&quot;</span> <span class="keyword1">using</span> obt2 <span class="keyword1">by</span> auto
                          <span class="keyword1">{</span>
                            <span class="keyword1">have</span> <span class="string">&quot;pathVertices u w1 = map fst w1 @ [snd (last w1)]&quot;</span> 
                              <span class="keyword1">using</span> pathVertices_alt <span class="alt_string">`set w1 &ne; {}`</span> <span class="keyword1">by</span> auto
                            <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;map fst w1 = map fst (butlast w1) @ [fst (last w1)]&quot;</span> 
                              <span class="keyword1">using</span> <span class="alt_string">`set w1 &ne; {}`</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis last_map empty_set map_butlast
                              snoc_eq_iff_butlast zip_Nil zip_map_fst_snd<span class="delimiter">)</span>
                            <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;pathVertices u w1 = 
                              map fst (butlast w1) @ fst (last w1) # snd (last w1) # []&quot;</span> <span class="keyword1">by</span> auto
                          <span class="keyword1">}</span>  <span class="keyword1">note</span> fct2 <span class="delimiter">=</span> this
                          <span class="keyword1">have</span> <span class="string">&quot;map fst (butlast w1) @ [fst (last w1)] = vs1 @ [v2]&quot;</span> <span class="keyword1">using</span> fct1
                            fct2 <span class="keyword1">by</span> <span class="delimiter">(</span>metis butlast.simps<span class="delimiter">(</span>2<span class="delimiter">)</span> butlast_append list.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span> 
                          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;fst (last w1) = v2&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis last_snoc<span class="delimiter">)</span>
                          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;snd (last w1) = u1&quot;</span> <span class="keyword1">using</span> fct1 fct2  
                            <span class="keyword1">by</span> <span class="delimiter">(</span>metis append_Cons append_Nil last_appendR last_snoc<span class="delimiter">)</span>
                          <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;last w1 = (v2, u1)&quot;</span> <span class="keyword1">by</span> auto
                          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;(v2, u1) &ne; last w1&quot;</span>
                            <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
                              <span class="keyword3">assume</span> <span class="string">&quot;&not; (v2, u1) &ne; last w1&quot;</span>
                              <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;butlast w1 @ [last w1] = w1&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`set w1 &ne; {}`</span> 
                                <span class="keyword1">by</span> <span class="delimiter">(</span>metis append_butlast_last_id list.set<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span>
                              <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;p = butlast w1 @ (v2, u1) # (u1, v1) # w2&quot;</span> 
                                <span class="keyword1">using</span> obt1 <span class="keyword1">by</span> auto
                              <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> asm_s1 <span class="keyword1">by</span> auto
                            <span class="keyword1">qed</span>
                          <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">by</span> metis
                        <span class="keyword1">qed</span>
                      <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;&exist; vs1&#39; vs2&#39;. butlast (pathVertices u w1) = 
                        vs1&#39; @ v2 # u1 # vs2&#39;&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis butlast.simps<span class="delimiter">(</span>2<span class="delimiter">)</span>
                        butlast_append fst_conv list.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span> snd_conv<span class="delimiter">)</span>
                    <span class="keyword1">}</span>
                    <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;&exist;vs3&#39;. pathVertices (last (pathVertices u w1)) ((u1, v1) # w2) = 
                      u1 # vs3&#39;&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.pathVertices.simps<span class="delimiter">(</span>2<span class="delimiter">)</span> fst_conv<span class="delimiter">)</span>
                    <span class="keyword1">ultimately</span> <span class="keyword3">obtain</span> vs1 vs2 vs3 <span class="keyword2">where</span> <span class="string">&quot;pathVertices u p = 
                      (vs1 @ v2 # u1 # vs2) @ (u1 # vs3)&quot;</span> <span class="keyword1">by</span> auto
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not; distinct (pathVertices u p)&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis append_Cons append_assoc
                      distinct.simps<span class="delimiter">(</span>2<span class="delimiter">)</span> distinct_append in_set_conv_decomp<span class="delimiter">)</span>
                    <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> asm1 isSimplePath_def <span class="keyword1">by</span> auto
                  <span class="keyword1">next</span>
                    <span class="keyword3">assume</span> <span class="string">&quot;(v2, u1) &isin; (set w2)&quot;</span>
                    <span class="keyword1">have</span> <span class="string">&quot;pathVertices u p = butlast (pathVertices u w1) @  pathVertices (last 
                      (pathVertices u w1)) ((u1, v1) # w2)&quot;</span> <span class="keyword1">using</span> obt1 pathVertices_append <span class="keyword1">by</span> auto
                    <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;pathVertices (last (pathVertices u w1)) ((u1, v1) # w2) = u1 # 
                      (pathVertices v1 w2)&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.pathVertices.simps<span class="delimiter">(</span>2<span class="delimiter">)</span> fst_conv snd_conv<span class="delimiter">)</span>
                    <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                      <span class="keyword1">have</span> <span class="string">&quot;isPath v1 w2 v&quot;</span> <span class="keyword1">using</span> asm1 isSimplePath_def
                        <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.isPath.simps<span class="delimiter">(</span>2<span class="delimiter">)</span> Graph.isPath_append obt1<span class="delimiter">)</span>
                      <span class="keyword1">note</span> pathVertices_edge_old<span class="delimiter">[</span>OF this <span class="alt_string">`(v2, u1) &isin; (set w2)`</span><span class="delimiter">]</span>
                      <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot; &exist;vs1 vs2. pathVertices v1 w2 = vs1 @ v2 # u1 # vs2&quot;</span> <span class="keyword1">by</span> auto
                    <span class="keyword1">}</span>
                    <span class="keyword1">ultimately</span> <span class="keyword3">obtain</span> vs1 vs2 vs3 <span class="keyword2">where</span> 
                      <span class="string">&quot;pathVertices u p = vs1 @ (u1 # vs2 @ v2 # u1 # vs3 )&quot;</span> <span class="keyword1">by</span> auto
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not; distinct (pathVertices u p)&quot;</span> <span class="keyword1">by</span> auto
                    <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> asm1 isSimplePath_def <span class="keyword1">by</span> auto
                  <span class="keyword1">qed</span>
              <span class="keyword1">qed</span>
          <span class="keyword1">qed</span>
      <span class="keyword1">qed</span>
      
    <span class="keyword1">lemma</span> isSPath_nt_parallel<span class="delimiter">:</span>
      <span class="keyword2">assumes</span> SP<span class="delimiter">:</span> <span class="string">&quot;isSimplePath s p t&quot;</span>
      <span class="keyword2">assumes</span> EIP<span class="delimiter">:</span> <span class="string">&quot;e&isin;set p&quot;</span>
      <span class="keyword2">shows</span> <span class="string">&quot;prod.swap e &notin; set p&quot;</span>
    <span class="keyword1">proof</span> -  
      <span class="keyword1">from</span> SP <span class="keyword1">have</span> P<span class="delimiter">:</span> <span class="string">&quot;isPath s p t&quot;</span> <span class="keyword2">and</span> D<span class="delimiter">:</span> <span class="string">&quot;distinct (pathVertices_fwd s p)&quot;</span>
        <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_fwd<span class="delimiter">)</span>
    
      <span class="keyword3">show</span> <span class="string">&quot;prod.swap e &notin; set p&quot;</span>  
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases e<span class="delimiter">)</span> <span class="keyword1">using</span> D EIP
        <span class="keyword1">by</span> <span class="delimiter">(</span>auto 
          dest<span class="delimiter">!</span><span class="delimiter">:</span> pathVertices_edge<span class="delimiter">[</span>OF P<span class="delimiter">]</span> 
          elim<span class="delimiter">!</span><span class="delimiter">:</span> list_match_lel_lel list_Cons_eq_append_cases<span class="delimiter">)</span>
    
    <span class="keyword1">qed</span>

    <span class="keyword1">lemma</span> isSPath_nt_parallel_old<span class="delimiter">:</span> 
      <span class="string">&quot;isSimplePath u p v ==&gt; (&forall;(u, v) &isin; set p. (v, u) &notin; set p)&quot;</span>
      <span class="keyword1">using</span> isSPath_nt_parallel<span class="delimiter">[</span>of u p v<span class="delimiter">]</span> <span class="keyword1">by</span> auto

    <span class="keyword1">corollary</span> isSPath_nt_parallel_pf<span class="delimiter">:</span> 
      <span class="string">&quot;isSimplePath s p t ==&gt; set p &cap; (set p)&macr; = {}&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto dest<span class="delimiter">:</span> isSPath_nt_parallel<span class="delimiter">)</span>
      
    <span class="keyword1">lemma</span> isSPath_distinct<span class="delimiter">:</span> <span class="string">&quot;isSimplePath u p v ==&gt; distinct p&quot;</span>
      <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
        <span class="keyword3">assume</span> asm<span class="delimiter">:</span> <span class="string">&quot;isSimplePath u p v&quot;</span>
        <span class="keyword3">assume</span> <span class="string">&quot;&not; distinct (p)&quot;</span>
        <span class="keyword1">then</span> <span class="keyword3">obtain</span> us vs ws x <span class="keyword2">where</span> obt1<span class="delimiter">:</span> <span class="string">&quot;p = us @ (x # vs @ [x]) @  ws&quot;</span>
          <span class="keyword1">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>mono_tags<span class="delimiter">,</span> hide_lams<span class="delimiter">)</span> append_Cons append_assoc not_distinct_decomp<span class="delimiter">)</span>
        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;p &ne; []&quot;</span> <span class="keyword1">by</span> auto
        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;pathVertices u p = map fst p @ [snd (last p)]&quot;</span> <span class="keyword1">using</span> pathVertices_alt <span class="keyword1">by</span> auto
        <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;map fst p = map fst us @ fst x # map fst vs @ [fst x] @ map fst ws&quot;</span>
          <span class="keyword1">using</span> obt1 <span class="keyword1">by</span> <span class="delimiter">(</span>metis append_Cons append_Nil append_assoc list.simps<span class="delimiter">(</span>9<span class="delimiter">)</span> map_append<span class="delimiter">)</span>
        <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;pathVertices u p = map fst us @ fst x # map fst vs @ [fst x] @ 
          map fst ws @ [snd (last p)]&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis append_Cons append_assoc<span class="delimiter">)</span>
        <span class="keyword1">then</span> <span class="keyword3">obtain</span> vs1 vs2 vs3 <span class="keyword2">where</span> <span class="string">&quot;pathVertices u p = vs1 @ fst x # vs2 @ fst x # vs3&quot;</span> <span class="keyword1">by</span> auto
        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not; distinct (pathVertices u p)&quot;</span> <span class="keyword1">by</span> auto
        <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> asm isSimplePath_def <span class="keyword1">by</span> auto
      <span class="keyword1">qed</span>


    <span class="keyword1">text</span> <span class="cartouche">&#8249;Edges adjacent to a node that does not lie on a path 
      are not contained in that path:&#8250;</span>  
    <span class="keyword1">lemma</span> adjacent_edges_not_on_path<span class="delimiter">:</span>
      <span class="keyword2">assumes</span> PATH<span class="delimiter">:</span> <span class="string">&quot;isPath s p t&quot;</span>
      <span class="keyword2">assumes</span> VNV<span class="delimiter">:</span> <span class="string">&quot;v&notin;set (pathVertices_fwd s p)&quot;</span>
      <span class="keyword2">shows</span> <span class="string">&quot;adjacent v &cap; set p = {}&quot;</span> 
    <span class="keyword1">proof</span> -
      <span class="keyword1">from</span> VNV <span class="keyword1">have</span> <span class="string">&quot;&forall;u. (u,v)&notin;set p &and; (v,u)&notin;set p&quot;</span>
        <span class="keyword1">by</span> <span class="delimiter">(</span>auto dest<span class="delimiter">:</span> pathVertices_edge<span class="delimiter">[</span>OF PATH<span class="delimiter">]</span><span class="delimiter">)</span>
      <span class="keyword3">thus</span> <span class="string">&quot;adjacent v &cap; set p = {}&quot;</span>
        <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> incoming_def outgoing_def adjacent_def<span class="delimiter">)</span>
    <span class="keyword1">qed</span>    

    <span class="keyword1">corollary</span> 
      <span class="keyword2">assumes</span> <span class="string">&quot;isPath s p t&quot;</span>
      <span class="keyword2">assumes</span> <span class="string">&quot;v&notin;set (pathVertices_fwd s p)&quot;</span>
      <span class="keyword2">shows</span> incoming_edges_not_on_path<span class="delimiter">:</span> <span class="string">&quot;incoming v &cap; set p = {}&quot;</span> 
        <span class="keyword2">and</span> outgoing_edges_not_on_path<span class="delimiter">:</span> <span class="string">&quot;outgoing v &cap; set p = {}&quot;</span>
      <span class="keyword1">using</span> adjacent_edges_not_on_path<span class="delimiter">[</span>OF assms<span class="delimiter">]</span>
      <span class="keyword1">unfolding</span> adjacent_def <span class="keyword1">by</span> auto

    <span class="keyword1">text</span> <span class="cartouche">&#8249;A simple path over a vertex can be split at this vertex, 
      and there are exactly two edges on the path touching this vertex.&#8250;</span>  
    <span class="keyword1">lemma</span> adjacent_edges_on_simple_path<span class="delimiter">:</span>
      <span class="keyword2">assumes</span> SPATH<span class="delimiter">:</span> <span class="string">&quot;isSimplePath s p t&quot;</span>
      <span class="keyword2">assumes</span> VNV<span class="delimiter">:</span> <span class="string">&quot;v&isin;set (pathVertices_fwd s p)&quot;</span> <span class="string">&quot;v&ne;s&quot;</span> <span class="string">&quot;v&ne;t&quot;</span>
      <span class="keyword2">obtains</span> p1 u w p2 <span class="keyword2">where</span> 
        <span class="string">&quot;p = p1@(u,v)#(v,w)#p2&quot;</span> 
        <span class="string">&quot;incoming v &cap; set p = {(u,v)}&quot;</span> 
        <span class="string">&quot;outgoing v &cap; set p = {(v,w)}&quot;</span>
    <span class="keyword1">proof</span> -
      <span class="keyword1">from</span> SPATH <span class="keyword1">have</span> PATH<span class="delimiter">:</span> <span class="string">&quot;isPath s p t&quot;</span> <span class="keyword2">and</span> DIST<span class="delimiter">:</span> <span class="string">&quot;distinct (pathVertices_fwd s p)&quot;</span> 
        <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_def pathVertices_fwd<span class="delimiter">)</span>
      <span class="keyword1">from</span> split_path_at_vertex<span class="delimiter">[</span>OF VNV<span class="delimiter">(</span>1<span class="delimiter">)</span> PATH<span class="delimiter">]</span> <span class="keyword3">obtain</span> p1 p2 <span class="keyword2">where</span> 
        <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;p=p1@p2&quot;</span> <span class="keyword2">and</span> P1<span class="delimiter">:</span> <span class="string">&quot;isPath s p1 v&quot;</span> <span class="keyword2">and</span> P2<span class="delimiter">:</span> <span class="string">&quot;isPath v p2 t&quot;</span> <span class="keyword1">.</span>
      <span class="keyword1">from</span> <span class="cartouche">&#8249;v&ne;s&#8250;</span> P1 <span class="keyword3">obtain</span> p1&#39; u <span class="keyword2">where</span> 
        <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;p1=p1&#39;@[(u,v)]&quot;</span> <span class="keyword2">and</span> P1&#39;<span class="delimiter">:</span> <span class="string">&quot;isPath s p1&#39; u&quot;</span> <span class="keyword2">and</span> UV<span class="delimiter">:</span> <span class="string">&quot;(u,v)&isin;E&quot;</span>
        <span class="keyword1">by</span> <span class="delimiter">(</span>cases p1 rule<span class="delimiter">:</span> rev_cases<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> split_path_simps<span class="delimiter">)</span>
      <span class="keyword1">from</span> <span class="cartouche">&#8249;v&ne;t&#8250;</span> P2 <span class="keyword3">obtain</span> w p2&#39; <span class="keyword2">where</span> 
        <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;p2=(v,w)#p2&#39;&quot;</span> <span class="keyword2">and</span> VW<span class="delimiter">:</span> <span class="string">&quot;(v,w)&isin;E&quot;</span> <span class="keyword2">and</span> P2&#39;<span class="delimiter">:</span> <span class="string">&quot;isPath w p2&#39; t&quot;</span>
        <span class="keyword1">by</span> <span class="delimiter">(</span>cases p2<span class="delimiter">)</span> <span class="delimiter">(</span>auto<span class="delimiter">)</span>
      <span class="keyword3">show</span> thesis
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule that<span class="delimiter">[</span>of p1&#39; u w p2&#39;<span class="delimiter">]</span><span class="delimiter">)</span>
        <span class="keyword1"><span class="improper">apply</span></span> simp
        <span class="keyword1">using</span> 
          isSPath_sg_outgoing<span class="delimiter">[</span>OF SPATH<span class="delimiter">,</span> of v w<span class="delimiter">]</span> 
          isSPath_sg_incoming<span class="delimiter">[</span>OF SPATH<span class="delimiter">,</span> of u v<span class="delimiter">]</span>
          isPath_edgeset<span class="delimiter">[</span>OF PATH<span class="delimiter">]</span>
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>fastforce simp<span class="delimiter">:</span> incoming_def outgoing_def<span class="delimiter">)</span><span class="delimiter">+</span>
        <span class="keyword1"><span class="improper">done</span></span>
    <span class="keyword1">qed</span>



  <span class="keyword2">end</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^END^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  
  
  <span class="comment">(* Distance lemmas *)</span>
  <span class="comment">(*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*)</span>
  <span class="comment">(*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*)</span>
  <span class="keyword1">context</span> Graph
  <span class="keyword2">begin</span>
    <span class="keyword1">lemma</span> connected_by_dist<span class="delimiter">:</span> <span class="string">&quot;connected v v&#39; = (&exist;d. dist v d v&#39;)&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dist_def connected_def<span class="delimiter">)</span>

    <span class="keyword1">lemma</span> isPath_distD<span class="delimiter">:</span> <span class="string">&quot;isPath u p v ==&gt; dist u (length p) v&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dist_def<span class="delimiter">)</span>

    <span class="keyword1">lemma</span>
      <span class="keyword2">shows</span> connectedI<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;dist v d v&#39; ==&gt; connected v v&#39;&quot;</span>
        <span class="keyword2">and</span> connectedI_id<span class="delimiter">[</span>intro<span class="delimiter">!</span><span class="delimiter">,</span> simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;connected v v&quot;</span>
        <span class="keyword2">and</span> connectedI_succ<span class="delimiter">:</span> <span class="string">&quot;connected v v&#39; ==&gt; (v&#39;,v&#39;&#39;) &isin; E ==&gt; connected v v&#39;&#39;&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dist_def connected_def intro<span class="delimiter">:</span> isPath_append_edge<span class="delimiter">)</span>
      
  
    <span class="keyword1">lemma</span> min_distI2<span class="delimiter">:</span> 
      <span class="string">&quot;[| connected v v&#39; ; !!d. [| dist v d v&#39;; !!d&#39;. dist v d&#39; v&#39; ==&gt; d &le; d&#39; |] ==&gt; Q d |] 
        ==&gt; Q (min_dist v v&#39;)&quot;</span>
      <span class="keyword1">unfolding</span> min_dist_def
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule LeastI2_wellorder<span class="delimiter">[</span><span class="keyword2">where</span> Q<span class="delimiter">=</span>Q <span class="keyword2">and</span> a<span class="delimiter">=</span><span class="string">&quot;SOME d. dist v d v&#39;&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> connected_by_dist intro<span class="delimiter">:</span> someI<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">done</span></span>
  
    <span class="keyword1">lemma</span> min_distI_eq<span class="delimiter">:</span>
      <span class="string">&quot;[| dist v d v&#39;; !!d&#39;. dist v d&#39; v&#39; ==&gt; d &le; d&#39; |] ==&gt; min_dist v v&#39; = d&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>force intro<span class="delimiter">:</span> min_distI2 simp<span class="delimiter">:</span> connected_by_dist<span class="delimiter">)</span>
  
    <span class="keyword1">text</span> <span class="verbatim">{* Two nodes are connected by a path of length @{text &quot;0&quot;}, 
      iff they are equal. *}</span>
    <span class="keyword1">lemma</span> dist_z_iff<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;dist v 0 v&#39; &lt;-&gt; v&#39;=v&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dist_def<span class="delimiter">)</span>
  

    <span class="keyword1">lemma</span> dist_z<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;dist v 0 v&quot;</span> <span class="keyword1">by</span> simp
    <span class="keyword1">lemma</span> dist_suc<span class="delimiter">:</span> <span class="string">&quot;[|dist v d v&#39;; (v&#39;,v&#39;&#39;)&isin;E|] ==&gt; dist v (Suc d) v&#39;&#39;&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dist_def intro<span class="delimiter">:</span> isPath_append_edge<span class="delimiter">)</span>

    <span class="keyword1">lemma</span> dist_cases<span class="delimiter">[</span>case_names dist_z dist_suc<span class="delimiter">,</span> consumes 1<span class="delimiter">,</span> cases pred<span class="delimiter">]</span><span class="delimiter">:</span>
      <span class="keyword2">assumes</span> <span class="string">&quot;dist v d v&#39;&quot;</span>
      <span class="keyword2">obtains</span> <span class="string">&quot;v=v&#39;&quot;</span> <span class="string">&quot;d=0&quot;</span>
       <span class="delimiter">|</span> vh dd <span class="keyword2">where</span> <span class="string">&quot;d=Suc dd&quot;</span> <span class="string">&quot;dist v dd vh&quot;</span> <span class="string">&quot;(vh,v&#39;)&isin;E&quot;</span>
      <span class="keyword1">using</span> assms 
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases d<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dist_def length_Suc_rev_conv isPath_append<span class="delimiter">)</span> 
      <span class="keyword1"><span class="improper">apply</span></span> force
      <span class="keyword1"><span class="improper">done</span></span>


    <span class="keyword1">text</span> <span class="verbatim">{* The same holds for @{text &quot;min_dist&quot;}, i.e., 
      the shortest path between two nodes has length @{text &quot;0&quot;}, 
      iff these nodes are equal. *}</span>
    <span class="keyword1">lemma</span> min_dist_z<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;min_dist v v = 0&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>rule min_distI2<span class="delimiter">)</span> auto
  
    <span class="keyword1">lemma</span> min_dist_z_iff<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;connected v v&#39; ==&gt; min_dist v v&#39; = 0 &lt;-&gt; v&#39;=v&quot;</span> 
      <span class="keyword1">by</span> <span class="delimiter">(</span>rule min_distI2<span class="delimiter">)</span> <span class="delimiter">(</span>auto<span class="delimiter">)</span>
      
    <span class="keyword1">lemma</span> min_dist_is_dist<span class="delimiter">:</span> <span class="string">&quot;connected v v&#39; ==&gt; dist v (min_dist v v&#39;) v&#39;&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto intro<span class="delimiter">:</span> min_distI2<span class="delimiter">)</span>
    <span class="keyword1">lemma</span> min_dist_minD<span class="delimiter">:</span> <span class="string">&quot;dist v d v&#39; ==&gt; min_dist v v&#39; &le; d&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto intro<span class="delimiter">:</span> min_distI2<span class="delimiter">)</span>
  
    <span class="keyword1">text</span> <span class="verbatim">{* We also provide introduction and destruction rules for the
      pattern @{text &quot;min_dist v v&#39; = Suc d&quot;}.
      *}</span>
  
    <span class="keyword1">lemma</span> min_dist_succ<span class="delimiter">:</span> 
      <span class="string">&quot;[| connected v v&#39;; (v&#39;,v&#39;&#39;) &isin; E |] ==&gt; min_dist v v&#39;&#39; &le; Suc (min_dist v v&#39;) &quot;</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule min_distI2<span class="delimiter">[</span><span class="keyword2">where</span> v&#39;<span class="delimiter">=</span>v&#39;<span class="delimiter">]</span><span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto intro<span class="delimiter">!</span><span class="delimiter">:</span> min_dist_minD intro<span class="delimiter">:</span> dist_suc<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">done</span></span>
  
    <span class="keyword1">lemma</span> min_dist_suc<span class="delimiter">:</span>
      <span class="keyword2">assumes</span> c<span class="delimiter">:</span> <span class="string">&quot;connected v v&#39;&quot;</span> <span class="string">&quot;min_dist v v&#39; = Suc d&quot;</span>
      <span class="keyword2">shows</span> <span class="string">&quot;&exist;v&#39;&#39;. connected v v&#39;&#39; &and; (v&#39;&#39;,v&#39;) &isin; E &and; min_dist v v&#39;&#39; = d&quot;</span>
    <span class="keyword1">proof</span> -
      <span class="keyword1">from</span> min_dist_is_dist<span class="delimiter">[</span>OF c<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">]</span>
      <span class="keyword1">have</span> <span class="string">&quot;min_dist v v&#39; = Suc d --&gt; ?thesis&quot;</span>
      <span class="keyword1">proof</span> cases
        <span class="keyword3">case</span> <span class="delimiter">(</span>dist_suc v&#39;&#39; d&#39;<span class="delimiter">)</span> <span class="keyword1">then</span> <span class="keyword3">show</span> <span class="var">?thesis</span>
          <span class="keyword1">using</span> min_dist_succ<span class="delimiter">[</span>of v v&#39;&#39; v&#39;<span class="delimiter">]</span> min_dist_minD<span class="delimiter">[</span>of v d v&#39;&#39;<span class="delimiter">]</span>
          <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> connectedI<span class="delimiter">)</span>
      <span class="keyword1">qed</span> simp
      <span class="keyword1">with</span> c <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">by</span> simp
    <span class="keyword1">qed</span>
  
    <span class="keyword1">text</span> <span class="verbatim">{*
      If there is a node with a shortest path of length @{text &quot;d&quot;}, 
      then, for any @{text &quot;d&#39;&lt;d&quot;}, there is also a node with a shortest path
      of length @{text &quot;d&#39;&quot;}.
      *}</span>
    <span class="keyword1">lemma</span> min_dist_less<span class="delimiter">:</span>
      <span class="keyword2">assumes</span> <span class="string">&quot;connected src v&quot;</span> <span class="string">&quot;min_dist src v = d&quot;</span> <span class="keyword2">and</span> <span class="string">&quot;d&#39; &lt; d&quot;</span>
      <span class="keyword2">shows</span> <span class="string">&quot;&exist;v&#39;. connected src v&#39; &and; min_dist src v&#39; = d&#39;&quot;</span>
      <span class="keyword1">using</span> assms
    <span class="keyword1">proof</span> <span class="delimiter">(</span>induct d arbitrary<span class="delimiter">:</span> v<span class="delimiter">)</span>
      <span class="keyword3">case</span> <span class="delimiter">(</span>Suc d<span class="delimiter">)</span> <span class="keyword1">with</span> min_dist_suc<span class="delimiter">[</span>of src v<span class="delimiter">]</span> <span class="keyword3">show</span> <span class="var">?case</span>
        <span class="keyword1">by</span> <span class="delimiter">(</span>cases <span class="string">&quot;d&#39; = d&quot;</span><span class="delimiter">)</span> auto
    <span class="keyword1">qed</span> auto
  
    <span class="keyword1">text</span> <span class="verbatim">{*
      Lemma @{text &quot;min_dist_less&quot;} can be weakened to @{text &quot;d&#39;&le;d&quot;}.
      *}</span>
  
    <span class="keyword1">corollary</span> min_dist_le<span class="delimiter">:</span>
      <span class="keyword2">assumes</span> c<span class="delimiter">:</span> <span class="string">&quot;connected src v&quot;</span> <span class="keyword2">and</span> d&#39;<span class="delimiter">:</span> <span class="string">&quot;d&#39; &le; min_dist src v&quot;</span>
      <span class="keyword2">shows</span> <span class="string">&quot;&exist;v&#39;. connected src v&#39; &and; min_dist src v&#39; = d&#39;&quot;</span>
      <span class="keyword1">using</span> min_dist_less<span class="delimiter">[</span>OF c<span class="delimiter">,</span> of <span class="string">&quot;min_dist src v&quot;</span> d&#39;<span class="delimiter">]</span> d&#39; c
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> le_less<span class="delimiter">)</span>


    <span class="keyword1">lemma</span> dist_trans<span class="delimiter">[</span>trans<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;dist u d1 w ==&gt; dist w d2 v ==&gt; dist u (d1+d2) v&quot;</span>  
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>clarsimp simp<span class="delimiter">:</span> dist_def<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rename_tac p1 p2<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule_tac x<span class="delimiter">=</span><span class="string">&quot;p1@p2&quot;</span> <span class="keyword2">in</span> exI<span class="delimiter">)</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isPath_append<span class="delimiter">)</span>


    <span class="keyword1">lemma</span> min_dist_split<span class="delimiter">:</span>
      <span class="keyword2">assumes</span> D1<span class="delimiter">:</span> <span class="string">&quot;dist u d1 w&quot;</span> <span class="keyword2">and</span> D2<span class="delimiter">:</span> <span class="string">&quot;dist w d2 v&quot;</span> <span class="keyword2">and</span> MIN<span class="delimiter">:</span> <span class="string">&quot;min_dist u v = d1+d2&quot;</span>
      <span class="keyword2">shows</span> <span class="string">&quot;min_dist u w = d1&quot;</span> <span class="string">&quot;min_dist w v = d2&quot;</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>metis assms ab_semigroup_add_class.add.commute add_le_cancel_left dist_trans min_distI_eq min_dist_minD<span class="delimiter">)</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>metis assms add_le_cancel_left dist_trans min_distI_eq min_dist_minD<span class="delimiter">)</span>
      
    <span class="keyword1">lemma</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Manual proof&#8250;</span>
      <span class="keyword2">assumes</span> D1<span class="delimiter">:</span> <span class="string">&quot;dist u d1 w&quot;</span> <span class="keyword2">and</span> D2<span class="delimiter">:</span> <span class="string">&quot;dist w d2 v&quot;</span> <span class="keyword2">and</span> MIN<span class="delimiter">:</span> <span class="string">&quot;min_dist u v = d1+d2&quot;</span>
      <span class="keyword2">shows</span> <span class="string">&quot;min_dist u w = d1&quot;</span> <span class="string">&quot;min_dist w v = d2&quot;</span>
    <span class="keyword1">proof</span> -
      <span class="keyword1">from</span> min_dist_minD<span class="delimiter">[</span>OF <span class="cartouche">&#8249;dist u d1 w&#8250;</span><span class="delimiter">]</span> <span class="keyword1">have</span> <span class="string">&quot;min_dist u w &le; d1&quot;</span> <span class="keyword1">.</span>
      <span class="keyword1">moreover</span> <span class="keyword1">{</span>
        <span class="keyword1">have</span> <span class="string">&quot;dist u (min_dist u w) w&quot;</span>
          <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule min_dist_is_dist<span class="delimiter">)</span>
          <span class="keyword1">using</span> D1 <span class="keyword1">by</span> auto
        <span class="keyword1">also</span> <span class="keyword1">note</span> D2
        <span class="keyword1">finally</span> <span class="keyword1">have</span> <span class="string">&quot;dist u (min_dist u w + d2) v&quot;</span> <span class="keyword1">.</span>
        <span class="keyword1">moreover</span> <span class="keyword3">assume</span> <span class="string">&quot;min_dist u w &lt; d1&quot;</span>
        <span class="keyword1">moreover</span> <span class="keyword1">note</span> MIN
        <span class="keyword1">ultimately</span> <span class="keyword1">have</span> False <span class="keyword1">by</span> <span class="delimiter">(</span>auto dest<span class="delimiter">:</span> min_dist_minD<span class="delimiter">)</span>
      <span class="keyword1">}</span> <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="string">&quot;min_dist u w = d1&quot;</span>
        <span class="keyword1">unfolding</span> not_less<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="keyword1">using</span> nat_neq_iff <span class="keyword1">by</span> blast

      <span class="keyword1">from</span> min_dist_minD<span class="delimiter">[</span>OF <span class="cartouche">&#8249;dist w d2 v&#8250;</span><span class="delimiter">]</span> <span class="keyword1">have</span> <span class="string">&quot;min_dist w v &le; d2&quot;</span> <span class="keyword1">.</span>
      <span class="keyword1">moreover</span> <span class="keyword1">{</span>
        <span class="keyword1">note</span> D1
        <span class="keyword1">also</span> <span class="keyword1">have</span> <span class="string">&quot;dist w (min_dist w v) v&quot;</span>
          <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule min_dist_is_dist<span class="delimiter">)</span>
          <span class="keyword1">using</span> D2 <span class="keyword1">by</span> auto
        <span class="keyword1">finally</span> <span class="keyword1">have</span> <span class="string">&quot;dist u (d1 + min_dist w v) v&quot;</span> <span class="keyword1">.</span>
        <span class="keyword1">moreover</span> <span class="keyword3">assume</span> <span class="string">&quot;min_dist w v &lt; d2&quot;</span>
        <span class="keyword1">moreover</span> <span class="keyword1">note</span> MIN
        <span class="keyword1">ultimately</span> <span class="keyword1">have</span> False <span class="keyword1">by</span> <span class="delimiter">(</span>auto dest<span class="delimiter">:</span> min_dist_minD<span class="delimiter">)</span>
      <span class="keyword1">}</span> <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="string">&quot;min_dist w v = d2&quot;</span>
        <span class="keyword1">unfolding</span> not_less<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="keyword1">using</span> nat_neq_iff <span class="keyword1">by</span> blast
    <span class="keyword1">qed</span>    


  <span class="keyword2">end</span>
  
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^END^^^^^^^^^^^^^^^^^^^^^^^^*)</span>


  <span class="comment">(* Shortest Path Lemmas *)</span>
  <span class="comment">(*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*)</span>
  <span class="comment">(*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*)</span>
  <span class="keyword1">context</span> Graph
  <span class="keyword2">begin</span>
    <span class="delimiter">--</span> <span class="cartouche">&#8249;Characterization of shortest path in terms of minimum distance&#8250;</span>
    <span class="keyword1">lemma</span> isShortestPath_min_dist_def<span class="delimiter">:</span> <span class="string">&quot;isShortestPath u p v &lt;-&gt; isPath u p v &and; length p = min_dist u v&quot;</span>  
      <span class="keyword1">unfolding</span> isShortestPath_def min_dist_def dist_def
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule iffI<span class="delimiter">;</span> clarsimp<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule Least_equality<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">;</span> auto<span class="delimiter">;</span> fail<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule Least_le<span class="delimiter">;</span> auto<span class="delimiter">;</span> fail<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">done</span></span>      

    <span class="keyword1">lemma</span> obtain_shortest_path<span class="delimiter">:</span> 
      <span class="keyword2">assumes</span> CONN<span class="delimiter">:</span> <span class="string">&quot;connected u v&quot;</span>  
      <span class="keyword2">obtains</span> p <span class="keyword2">where</span> <span class="string">&quot;isShortestPath u p v&quot;</span>
      <span class="keyword1">using</span> min_dist_is_dist<span class="delimiter">[</span>OF CONN<span class="delimiter">]</span>
      <span class="keyword1">unfolding</span> dist_def isShortestPath_min_dist_def
      <span class="keyword1">by</span> blast

    <span class="keyword1">lemma</span> shortestPath_is_simple<span class="delimiter">:</span>
      <span class="keyword2">assumes</span> <span class="string">&quot;isShortestPath s p t&quot;</span>
      <span class="keyword2">shows</span> <span class="string">&quot;isSimplePath s p t&quot;</span>
    <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
      <span class="keyword1">from</span> assms <span class="keyword1">have</span> PATH<span class="delimiter">:</span> <span class="string">&quot;isPath s p t&quot;</span> 
        <span class="keyword2">and</span> SHORTEST<span class="delimiter">:</span> <span class="string">&quot;&forall;p&#39;. isPath s p&#39; t --&gt; length p &le; length p&#39;&quot;</span>
        <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isShortestPath_def<span class="delimiter">)</span>

      <span class="keyword3">assume</span> <span class="string">&quot;&not;isSimplePath s p t&quot;</span>  
      <span class="keyword1">with</span> PATH <span class="keyword1">have</span> <span class="string">&quot;&not;distinct (pathVertices_fwd s p)&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_fwd<span class="delimiter">)</span>

      <span class="keyword1">then</span> <span class="keyword3">obtain</span> pv1 u pv2 pv3 <span class="keyword2">where</span> PV<span class="delimiter">:</span> <span class="string">&quot;pathVertices_fwd s p = pv1@u#pv2@u#pv3&quot;</span> 
        <span class="keyword1">by</span> <span class="delimiter">(</span>auto dest<span class="delimiter">:</span> not_distinct_decomp<span class="delimiter">)</span>

      <span class="keyword1">from</span> split_path_at_vertex_complete<span class="delimiter">[</span>OF PATH PV<span class="delimiter">]</span> <span class="keyword3">obtain</span> p1 p23 <span class="keyword2">where</span>
        <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;p=p1@p23&quot;</span> <span class="keyword2">and</span> 
          P1<span class="delimiter">:</span> <span class="string">&quot;isPath s p1 u&quot;</span> <span class="string">&quot;pathVertices_fwd s p1 = pv1@[u]&quot;</span> <span class="keyword2">and</span>
          P23<span class="delimiter">:</span> <span class="string">&quot;isPath u p23 t&quot;</span> <span class="string">&quot;pathVertices_fwd u p23 = (u#pv2)@u#pv3&quot;</span>
          <span class="keyword1">by</span> auto
          
      <span class="keyword1">from</span> split_path_at_vertex_complete<span class="delimiter">[</span>OF P23<span class="delimiter">]</span> <span class="keyword3">obtain</span> p2 p3 <span class="keyword2">where</span>
        <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;p23 = p2@p3&quot;</span> <span class="keyword2">and</span>
        P2<span class="delimiter">:</span> <span class="string">&quot;isPath u p2 u&quot;</span> <span class="string">&quot;pathVertices_fwd u p2 = u#pv2@[u]&quot;</span> <span class="keyword2">and</span>
        P3<span class="delimiter">:</span> <span class="string">&quot;isPath u p3 t&quot;</span> <span class="string">&quot;pathVertices_fwd u p3 = u#pv3&quot;</span>
        <span class="keyword1">by</span> auto

      <span class="keyword1">from</span> P1<span class="delimiter">(</span>1<span class="delimiter">)</span> P3<span class="delimiter">(</span>1<span class="delimiter">)</span> <span class="keyword1">have</span> SHORTER_PATH<span class="delimiter">:</span> <span class="string">&quot;isPath s (p1@p3) t&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isPath_append<span class="delimiter">)</span>
      
      <span class="keyword1">from</span> P2 <span class="keyword1">have</span> <span class="string">&quot;p2&ne;[]&quot;</span> <span class="keyword1">by</span> auto
      <span class="keyword1">hence</span> LESS<span class="delimiter">:</span> <span class="string">&quot;length (p1@p3) &lt; length p&quot;</span> <span class="keyword1">by</span> auto
      <span class="keyword1">with</span> SHORTER_PATH SHORTEST <span class="keyword3">show</span> False <span class="keyword1">by</span> auto
    <span class="keyword1">qed</span>    

    <span class="keyword1">text</span> <span class="cartouche">&#8249;We provide yet another characterization of shortest paths:&#8250;</span>
    <span class="keyword1">lemma</span> isShortestPath_alt<span class="delimiter">:</span> <span class="string">&quot;isShortestPath u p v &lt;-&gt; isSimplePath u p v &and; length p = min_dist u v&quot;</span>
      <span class="keyword1">using</span> shortestPath_is_simple isShortestPath_min_dist_def
      <span class="keyword1">unfolding</span> isSimplePath_def <span class="keyword1">by</span> auto

    <span class="keyword1">lemma</span> shortestPath_is_path<span class="delimiter">:</span> <span class="string">&quot;isShortestPath u p v ==&gt; isPath u p v&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isShortestPath_def<span class="delimiter">)</span>
      
    <span class="keyword1">text</span> <span class="cartouche">&#8249;In a finite graph, the length of a shortest path is less 
      than the number of nodes&#8250;</span>  
    <span class="keyword1">lemma</span> isShortestPath_length_less_V<span class="delimiter">:</span>   
      <span class="keyword2">assumes</span> FIN<span class="delimiter">:</span> <span class="string">&quot;finite V&quot;</span> <span class="keyword2">and</span> SV<span class="delimiter">:</span> <span class="string">&quot;s&isin;V&quot;</span>
      <span class="keyword2">assumes</span> PATH<span class="delimiter">:</span> <span class="string">&quot;isShortestPath s p t&quot;</span>
      <span class="keyword2">shows</span> <span class="string">&quot;length p &lt; card V&quot;</span>
      <span class="keyword1">using</span> simplePath_length_less_V<span class="delimiter">[</span>OF FIN SV<span class="delimiter">]</span>
      <span class="keyword1">using</span> shortestPath_is_simple<span class="delimiter">[</span>OF PATH<span class="delimiter">]</span> <span class="keyword1">.</span>

    <span class="keyword1">corollary</span> min_dist_less_V<span class="delimiter">:</span>
      <span class="keyword2">assumes</span> FIN<span class="delimiter">:</span> <span class="string">&quot;finite V&quot;</span>
      <span class="keyword2">assumes</span> SV<span class="delimiter">:</span> <span class="string">&quot;s&isin;V&quot;</span>
      <span class="keyword2">assumes</span> CONN<span class="delimiter">:</span> <span class="string">&quot;connected s t&quot;</span>
      <span class="keyword2">shows</span> <span class="string">&quot;min_dist s t &lt; card V&quot;</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule obtain_shortest_path<span class="delimiter">[</span>OF CONN<span class="delimiter">]</span><span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>frule isShortestPath_length_less_V<span class="delimiter">[</span>OF FIN SV<span class="delimiter">]</span><span class="delimiter">)</span>
      <span class="keyword1">unfolding</span> isShortestPath_min_dist_def <span class="keyword1">by</span> auto

    <span class="keyword1">lemma</span> split_shortest_path<span class="delimiter">:</span> <span class="string">&quot;isShortestPath u (p1@p2) v 
      ==&gt; (&exist;w. isShortestPath u p1 w &and; isShortestPath w p2 v)&quot;</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isShortestPath_min_dist_def isPath_append<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule exI<span class="delimiter">;</span> intro conjI<span class="delimiter">;</span> assumption<span class="delimiter">?</span><span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>drule isPath_distD<span class="delimiter">)</span><span class="delimiter">+</span> <span class="keyword1">using</span> min_dist_split <span class="keyword1"><span class="improper">apply</span></span> auto <span class="delimiter">[</span><span class="delimiter">]</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>drule isPath_distD<span class="delimiter">)</span><span class="delimiter">+</span> <span class="keyword1">using</span> min_dist_split <span class="keyword1"><span class="improper">apply</span></span> auto <span class="delimiter">[</span><span class="delimiter">]</span>
      <span class="keyword1"><span class="improper">done</span></span>

    <span class="keyword1">text</span> <span class="cartouche">&#8249;Edges in a shortest path connect nodes with increasing 
      minimum distance from the source&#8250;</span>
    <span class="keyword1">lemma</span> isShortestPath_level_edge<span class="delimiter">:</span>  
      <span class="keyword2">assumes</span> SP<span class="delimiter">:</span> <span class="string">&quot;isShortestPath s p t&quot;</span> 
      <span class="keyword2">assumes</span> EIP<span class="delimiter">:</span> <span class="string">&quot;(u,v)&isin;set p&quot;</span>
      <span class="keyword2">shows</span> 
        <span class="string">&quot;connected s u&quot;</span> <span class="string">&quot;connected u v&quot;</span> <span class="string">&quot;connected v t&quot;</span> <span class="keyword2">and</span>
        <span class="string">&quot;min_dist s v = min_dist s u + 1&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="var">?G1</span><span class="delimiter">)</span> <span class="keyword2">and</span>
        <span class="string">&quot;min_dist u t = 1 + min_dist v t&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="var">?G2</span><span class="delimiter">)</span> <span class="keyword2">and</span>
        <span class="string">&quot;min_dist s t = min_dist s u + 1 + min_dist v t&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="var">?G3</span><span class="delimiter">)</span> 
    <span class="keyword1">proof</span> -  
      <span class="delimiter">--</span> <span class="cartouche">&#8249;Split the original path at the edge&#8250;</span>
      <span class="keyword1">from</span> EIP <span class="keyword3">obtain</span> p1 p2 <span class="keyword2">where</span> <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;p=p1@(u,v)#p2&quot;</span>
        <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> in_set_conv_decomp<span class="delimiter">)</span>
      <span class="keyword1">from</span> <span class="cartouche">&#8249;isShortestPath s p t&#8250;</span> <span class="keyword1">have</span> 
        MIN<span class="delimiter">:</span> <span class="string">&quot;min_dist s t = length p&quot;</span> <span class="keyword2">and</span> P<span class="delimiter">:</span> <span class="string">&quot;isPath s p t&quot;</span> <span class="keyword2">and</span> DV<span class="delimiter">:</span> <span class="string">&quot;distinct (pathVertices s p)&quot;</span>
        <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isShortestPath_alt isSimplePath_def<span class="delimiter">)</span>
      <span class="keyword1">from</span> P <span class="keyword1">have</span> DISTS<span class="delimiter">:</span> <span class="string">&quot;dist s (length p1) u&quot;</span> <span class="string">&quot;dist u 1 v&quot;</span> <span class="string">&quot;dist v (length p2) t&quot;</span>
        <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isPath_append dist_def intro<span class="delimiter">:</span> exI<span class="delimiter">[</span><span class="keyword2">where</span> x<span class="delimiter">=</span><span class="string">&quot;[(u,v)]&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>
        
      <span class="keyword1">from</span> DISTS <span class="keyword3">show</span> <span class="string">&quot;connected s u&quot;</span> <span class="string">&quot;connected u v&quot;</span> <span class="string">&quot;connected v t&quot;</span> <span class="keyword1">by</span> auto

      <span class="delimiter">--</span> <span class="cartouche">&#8249;Express the minimum distances in terms of the split original path&#8250;</span>  
      <span class="keyword1">from</span> MIN <span class="keyword1">have</span> MIN&#39;<span class="delimiter">:</span> <span class="string">&quot;min_dist s t = length p1 + 1 + length p2&quot;</span> <span class="keyword1">by</span> auto
      
      <span class="keyword1">from</span> min_dist_split<span class="delimiter">[</span>OF dist_trans<span class="delimiter">[</span>OF DISTS<span class="delimiter">(</span>1<span class="delimiter">,</span>2<span class="delimiter">)</span><span class="delimiter">]</span> DISTS<span class="delimiter">(</span>3<span class="delimiter">)</span> MIN&#39;<span class="delimiter">]</span> <span class="keyword1">have</span>
        MDSV<span class="delimiter">:</span> <span class="string">&quot;min_dist s v = length p1 + 1&quot;</span> <span class="keyword2">and</span> <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;length p2 = min_dist v t&quot;</span> <span class="keyword1">by</span> simp_all
      <span class="keyword1">from</span> min_dist_split<span class="delimiter">[</span>OF DISTS<span class="delimiter">(</span>1<span class="delimiter">)</span> dist_trans<span class="delimiter">[</span>OF DISTS<span class="delimiter">(</span>2<span class="delimiter">,</span>3<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span> MIN&#39; <span class="keyword1">have</span>
        MDUT<span class="delimiter">:</span> <span class="string">&quot;min_dist u t = 1 + length p2&quot;</span> <span class="keyword2">and</span> <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;length p1 = min_dist s u&quot;</span> <span class="keyword1">by</span> simp_all

      <span class="keyword1">from</span> MDSV MDUT MIN&#39; <span class="keyword3">show</span> <span class="var">?G1</span> <span class="var">?G2</span> <span class="var">?G3</span> <span class="keyword1">by</span> auto  
    <span class="keyword1">qed</span>  

  <span class="keyword2">end</span>


<span class="keyword2">end</span>
</pre>

</div>
</body>
</html>
