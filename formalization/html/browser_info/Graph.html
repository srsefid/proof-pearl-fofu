<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Graph (Isabelle2015: May 2015)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Graph</h1>

<span class="command">theory</span> <span class="name">Graph</span><br/>
<span class="keyword">imports</span> <a href="Fofu_Abs_Base.html"><span class="name">Fofu_Abs_Base</span></a><br/>

</div>
<div class="source">
<pre><span class="keyword1">section</span> <span class="cartouche">&#8249;Directed Graphs&#8250;</span>
<span class="keyword1">theory</span> Graph
<span class="keyword2">imports</span> Fofu_Abs_Base
<span class="keyword2">begin</span>
<span class="keyword1">text</span> <span class="cartouche">&#8249;
  We define a specialized graph library for graphs that are induced by 
  capacity matrices.
&#8250;</span>

<span class="keyword1">subsection</span> <span class="cartouche">&#8249;Definitions&#8250;</span>

<span class="keyword1">subsubsection</span> <span class="cartouche">&#8249;Basic Definitions&#8250;</span>
<span class="keyword1">text</span> <span class="cartouche">&#8249;
  We fix the nodes to be natural numbers.
&#8250;</span>  
  <span class="keyword1">type_synonym</span> node <span class="delimiter">=</span> nat 
  <span class="keyword1">type_synonym</span> edge <span class="delimiter">=</span> <span class="string">&quot;node &times; node&quot;</span>

<span class="keyword1">text</span> <span class="cartouche">&#8249;
  The capacities are left polymorphic, however, they
  are restricted to linearly ordered domains.
&#8250;</span>
<span class="keyword1">type_synonym</span> <span class="tfree">&#39;capacity</span> graph <span class="delimiter">=</span> <span class="string">&quot;edge =&gt; &#39;capacity&quot;</span>
  
<span class="keyword1">locale</span> Graph <span class="delimiter">=</span> <span class="keyword2">fixes</span> c <span class="delimiter">::</span> <span class="string">&quot;&#39;capacity::linordered_idom graph&quot;</span>
<span class="keyword2">begin</span>
<span class="keyword1">definition</span> E <span class="delimiter">::</span> <span class="string">&quot;edge set&quot;</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Edges of the graph&#8250;</span>
<span class="keyword2">where</span> <span class="string">&quot;E &equiv; {(u, v). c (u, v) &ne; 0}&quot;</span>

<span class="keyword1">definition</span> V <span class="delimiter">::</span> <span class="string">&quot;node set&quot;</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Nodes of the graph. Exactly the nodes 
  that have adjacent edges.&#8250;</span>
<span class="keyword2">where</span> <span class="string">&quot;V &equiv; {u. &exist;v. (u, v) &isin; E &or; (v, u) &isin; E}&quot;</span>

<span class="keyword1">definition</span> incoming <span class="delimiter">::</span> <span class="string">&quot;node =&gt; edge set&quot;</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Incoming edges into a node&#8250;</span>
<span class="keyword2">where</span> <span class="string">&quot;incoming v &equiv; {(u, v) | u. (u, v) &isin; E}&quot;</span>

<span class="keyword1">definition</span> outgoing <span class="delimiter">::</span> <span class="string">&quot;node =&gt; edge set&quot;</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Outgoing edges from a node&#8250;</span>
<span class="keyword2">where</span> <span class="string">&quot;outgoing v &equiv; {(v, u) | u. (v, u) &isin; E}&quot;</span>
  
<span class="keyword1">definition</span> adjacent <span class="delimiter">::</span> <span class="string">&quot;node =&gt; edge set&quot;</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Adjacent edges of a node&#8250;</span>
<span class="keyword2">where</span> <span class="string">&quot;adjacent v &equiv; incoming v &cup; outgoing v&quot;</span>

<span class="keyword1">definition</span> incoming&#39; <span class="delimiter">::</span> <span class="string">&quot;node set =&gt; edge set&quot;</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Incoming edges into 
  a set of nodes&#8250;</span>
<span class="keyword2">where</span> <span class="string">&quot;incoming&#39; k &equiv; {(u, v) | u v. u &notin; k &and; v &isin; k &and; (u, v) &isin; E}&quot;</span>
  
<span class="keyword1">definition</span> outgoing&#39; <span class="delimiter">::</span> <span class="string">&quot;node set =&gt; edge set&quot;</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Outgoing edges from 
  a set of nodes&#8250;</span>
<span class="keyword2">where</span> <span class="string">&quot;outgoing&#39; k &equiv; {(v, u) | u v. u &notin; k &and; v &isin; k &and; (v, u) &isin; E}&quot;</span>
  
<span class="keyword1">definition</span> adjacent&#39; <span class="delimiter">::</span> <span class="string">&quot;node set =&gt; edge set&quot;</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Edges adjacent to a 
  set of nodes&#8250;</span>
<span class="keyword2">where</span> <span class="string">&quot;adjacent&#39; k &equiv; incoming&#39; k &cup; outgoing&#39; k&quot;</span>

<span class="keyword1">definition</span> is_adj_map <span class="delimiter">::</span> <span class="string">&quot;(node =&gt; node list) =&gt; bool&quot;</span> <span class="keyword2">where</span>
  <span class="string">&quot;is_adj_map ps &equiv; (&forall;u. distinct (ps u) &and; set (ps u) = E``{u} &cup; E&macr;``{u})&quot;</span>

<span class="keyword2">end</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Graph&#8250;</span>

<span class="comment">(*&lt;*)</span> <span class="comment">(* Old syntax*)</span>
<span class="keyword1">locale</span> Graph_Loc_Syntax <span class="delimiter">=</span> Graph
<span class="keyword2">begin</span>
  <span class="keyword1">notation</span> incoming <span class="delimiter">(</span><span class="string">&quot;&delta;<span class="hidden">&#8679;</span><sup>+</sup>(_)&quot;</span> 1000<span class="delimiter">)</span> 
  <span class="keyword1">notation</span> outgoing <span class="delimiter">(</span><span class="string">&quot;&delta;<span class="hidden">&#8679;</span><sup>-</sup>(_)&quot;</span> 1000<span class="delimiter">)</span>
  <span class="keyword1">notation</span> adjacent <span class="delimiter">(</span><span class="string">&quot;&delta;(_)&quot;</span> 1000<span class="delimiter">)</span> 
  <span class="keyword1">notation</span> incoming&#39; <span class="delimiter">(</span><span class="string">&quot;&Delta;<span class="hidden">&#8679;</span><sup>+</sup>(_)&quot;</span> 1000<span class="delimiter">)</span> 
  <span class="keyword1">notation</span> outgoing&#39; <span class="delimiter">(</span><span class="string">&quot;&Delta;<span class="hidden">&#8679;</span><sup>-</sup>(_)&quot;</span> 1000<span class="delimiter">)</span>
  <span class="keyword1">notation</span> adjacent&#39; <span class="delimiter">(</span><span class="string">&quot;&Delta;(_)&quot;</span> 1000<span class="delimiter">)</span> 
<span class="keyword2">end</span>

<span class="keyword1">locale</span> Graph_Syntax <span class="keyword2">begin</span>
  <span class="keyword1">abbreviation</span> Graph_E <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; edge set&quot;</span>
    <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ E\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span>
  <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> E\&lt;rbrace&gt; &equiv; Graph.E c&quot;</span>
    
  <span class="keyword1">abbreviation</span> Graph_V <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node set&quot;</span> 
    <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ V\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span> 
  <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> V\&lt;rbrace&gt; &equiv; Graph.V c&quot;</span>
    
  <span class="keyword1">abbreviation</span> Graph_incoming <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node =&gt; edge set&quot;</span> 
    <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &delta;<span class="hidden">&#8679;</span><sup>+</sup>(_)\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span> 
  <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &delta;<span class="hidden">&#8679;</span><sup>+</sup> u\&lt;rbrace&gt; &equiv; Graph.incoming c u&quot;</span>
    
  <span class="keyword1">abbreviation</span> Graph_outgoing <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node =&gt; edge set&quot;</span> 
    <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &delta;<span class="hidden">&#8679;</span><sup>-</sup>(_)\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span>
  <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &delta;<span class="hidden">&#8679;</span><sup>-</sup> u\&lt;rbrace&gt; &equiv; Graph.outgoing c u&quot;</span>
    
  <span class="keyword1">abbreviation</span> Graph_delta <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node =&gt; edge set&quot;</span>
    <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &delta;(_)\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span> 
  <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &delta; u\&lt;rbrace&gt; &equiv; Graph.adjacent c u&quot;</span>
    
  <span class="keyword1">abbreviation</span> Graph_incoming&#39; <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node set =&gt; edge set&quot;</span> 
    <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &Delta;<span class="hidden">&#8679;</span><sup>+</sup>(_)\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span>
  <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &Delta;<span class="hidden">&#8679;</span><sup>+</sup> u\&lt;rbrace&gt; &equiv; Graph.incoming&#39; c u&quot;</span>  
  
  <span class="keyword1">abbreviation</span> Graph_outgoing&#39; <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node set =&gt; edge set&quot;</span> 
    <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &Delta;<span class="hidden">&#8679;</span><sup>-</sup>(_)\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span> 
  <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &Delta;<span class="hidden">&#8679;</span><sup>-</sup> u\&lt;rbrace&gt; &equiv; Graph.outgoing&#39; c u&quot;</span>
    
  <span class="keyword1">abbreviation</span> Graph_delta&#39; <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node set =&gt; edge set&quot;</span> 
    <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &Delta;(_)\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span> 
  <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &Delta; u\&lt;rbrace&gt; &equiv; Graph.adjacent&#39; c u&quot;</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
  <span class="comment">(*^^^^^^^^^^^^^^^^^^^^^^^END^^^^^^^^^^^^^^^^^^^^^^^^*)</span>
<span class="keyword2">end</span>  
<span class="comment">(*&gt;*)</span>

<span class="keyword1">subsubsection</span> <span class="cartouche">&#8249;Finite Graphs&#8250;</span>
<span class="keyword1">locale</span> Finite_Graph <span class="delimiter">=</span> Graph <span class="delimiter">+</span>
  <span class="keyword2">assumes</span> finite_V<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;finite V&quot;</span>

<span class="keyword1">subsubsection</span> <span class="cartouche">&#8249;Paths&#8250;</span>
<span class="keyword1">type_synonym</span> path <span class="delimiter">=</span> <span class="string">&quot;edge list&quot;</span>

<span class="keyword1">context</span> Graph
<span class="keyword2">begin</span>
  <span class="keyword1">fun</span> isPath <span class="delimiter">::</span> <span class="string">&quot;node =&gt; path =&gt; node =&gt; bool&quot;</span> 
  <span class="keyword2">where</span>
    <span class="string">&quot;isPath u [] v &lt;-&gt; u = v&quot;</span>
  <span class="delimiter">|</span> <span class="string">&quot;isPath u ((x,y)#p) v &lt;-&gt; u = x &and; (x, y) &isin; E &and; isPath y p v&quot;</span>

  <span class="keyword1">fun</span> pathVertices <span class="delimiter">::</span> <span class="string">&quot;node =&gt; path =&gt; node list&quot;</span>
  <span class="keyword2">where</span>
    <span class="string">&quot;pathVertices u [] = [u]&quot;</span>
  <span class="delimiter">|</span> <span class="string">&quot;pathVertices u (e # es) = fst e # (pathVertices (snd e) es)&quot;</span>
  
  <span class="comment">(* TODO: This characterization is probably nicer to work with! Exchange! *)</span>
  <span class="keyword1">definition</span> <span class="delimiter">(</span><span class="keyword2">in</span> Graph<span class="delimiter">)</span> pathVertices_fwd <span class="delimiter">::</span> <span class="string">&quot;node =&gt; edge list =&gt; node list&quot;</span> 
    <span class="keyword2">where</span> <span class="string">&quot;pathVertices_fwd u p = u#map snd p&quot;</span>

  <span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> Graph<span class="delimiter">)</span> pathVertices_fwd<span class="delimiter">:</span> 
    <span class="keyword2">assumes</span> <span class="string">&quot;isPath u p v&quot;</span>
    <span class="keyword2">shows</span> <span class="string">&quot;pathVertices u p = pathVertices_fwd u p&quot;</span>
    <span class="keyword1">unfolding</span> pathVertices_fwd_def
    <span class="keyword1">using</span> assms <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>induction p arbitrary<span class="delimiter">:</span> u<span class="delimiter">)</span>
    <span class="keyword1">by</span> auto


  <span class="keyword1">definition</span> connected <span class="delimiter">::</span> <span class="string">&quot;node =&gt; node =&gt; bool&quot;</span> 
    <span class="keyword2">where</span> <span class="string">&quot;connected u v &equiv; &exist;p. isPath u p v&quot;</span> 
  
  <span class="keyword1">abbreviation</span> <span class="delimiter">(</span>input<span class="delimiter">)</span> <span class="string">&quot;isReachable &equiv; connected&quot;</span> <span class="comment">(* Deprecated *)</span>

  <span class="keyword1">definition</span> reachableNodes <span class="delimiter">::</span> <span class="string">&quot;node =&gt; node set&quot;</span>  
    <span class="keyword2">where</span> <span class="string">&quot;reachableNodes u &equiv; {v. connected u v}&quot;</span>
  
  <span class="keyword1">definition</span> isShortestPath <span class="delimiter">::</span> <span class="string">&quot;node =&gt; path =&gt; node =&gt; bool&quot;</span> 
    <span class="keyword2">where</span> <span class="string">&quot;isShortestPath u p v 
    &equiv; isPath u p v &and; (&forall;p&#39;. isPath u p&#39; v --&gt; length p &le; length p&#39;)&quot;</span>
      
  <span class="keyword1">definition</span> isSimplePath <span class="delimiter">::</span> <span class="string">&quot;node =&gt; path =&gt; node =&gt; bool&quot;</span> 
    <span class="keyword2">where</span> <span class="string">&quot;isSimplePath u p v &equiv; isPath u p v &and; distinct (pathVertices u p)&quot;</span>

  <span class="keyword1">definition</span> dist <span class="delimiter">::</span> <span class="string">&quot;node =&gt; nat =&gt; node =&gt; bool&quot;</span> 
    <span class="delimiter">--</span> <span class="cartouche">&#8249;There is a path of given length between the nodes&#8250;</span>
    <span class="keyword2">where</span> <span class="string">&quot;dist v d v&#39; &equiv; &exist;p. isPath v p v&#39; &and; length p = d&quot;</span>

  <span class="keyword1">definition</span> min_dist <span class="delimiter">::</span> <span class="string">&quot;node =&gt; node =&gt; nat&quot;</span>
    <span class="delimiter">--</span> <span class="cartouche">&#8249;Minimum distance between two connected nodes&#8250;</span>
    <span class="keyword2">where</span> <span class="string">&quot;min_dist v v&#39; = (LEAST d. dist v d v&#39;)&quot;</span>

<span class="keyword2">end</span>  

<span class="comment">(*&lt;*)</span> <span class="comment">(* Old syntax *)</span>
<span class="keyword1">context</span> Graph_Loc_Syntax <span class="keyword2">begin</span>
  <span class="keyword1">notation</span> isPath <span class="delimiter">(</span><span class="string">&quot;&lang;\&lt;leadsto&gt;/ _,/ _,/ _&rang;&quot;</span>  1000<span class="delimiter">)</span>
  <span class="keyword1">notation</span> connected <span class="delimiter">(</span><span class="string">&quot;&lang;_/ \&lt;leadsto&gt;/ _&rang;&quot;</span> 1000<span class="delimiter">)</span>
  <span class="keyword1">notation</span> reachableNodes <span class="delimiter">(</span><span class="string">&quot;&lang;&lowast;/ _&rang;&quot;</span> 1000<span class="delimiter">)</span>
  <span class="keyword1">notation</span> isShortestPath <span class="delimiter">(</span><span class="string">&quot;&lang;-&gt;/ _,/ _,/ _&rang;&quot;</span> 1000<span class="delimiter">)</span> 
  <span class="keyword1">notation</span> isSimplePath <span class="delimiter">(</span><span class="string">&quot;&lang;=&gt;/ _,/ _,/ _&rang;&quot;</span> 1000<span class="delimiter">)</span>
<span class="keyword2">end</span>

<span class="keyword1">context</span> Graph_Syntax <span class="keyword2">begin</span>  
  <span class="keyword1">abbreviation</span> Graph_isPath <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node =&gt; path =&gt; node =&gt; bool&quot;</span> 
    <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &lang;\&lt;leadsto&gt; _, _, _&rang;\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span>
  <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &lang;\&lt;leadsto&gt; u, p, v&rang;\&lt;rbrace&gt; &equiv; Graph.isPath c u p v&quot;</span>
    
  <span class="keyword1">abbreviation</span> Graph_connected <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node =&gt; node =&gt; bool&quot;</span> 
    <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &lang;_/ \&lt;leadsto&gt;/ _&rang;\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span> 
  <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &lang;u \&lt;leadsto&gt; v&rang;\&lt;rbrace&gt; &equiv; Graph.connected c u v&quot;</span>
    
  <span class="keyword1">abbreviation</span> Graph_reachableNodes <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node =&gt; node set&quot;</span> 
    <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &lang;&lowast;/ _&rang;\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span> 
  <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &lang;&lowast; u&rang;\&lt;rbrace&gt; &equiv; Graph.reachableNodes c u&quot;</span>
    
  <span class="keyword1">abbreviation</span> Graph_isShortestPath <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node =&gt; path =&gt; node =&gt; bool&quot;</span> 
    <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &lang;-&gt; _, _, _&rang;\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span>
  <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &lang;-&gt; u, p, v&rang;\&lt;rbrace&gt; &equiv; Graph.isShortestPath c u p v&quot;</span>
    
  <span class="keyword1">abbreviation</span> Graph_isSimplePath <span class="delimiter">::</span> <span class="string">&quot;&#39;c::linordered_idom graph =&gt; node =&gt; path =&gt; node =&gt; bool&quot;</span>
    <span class="delimiter">(</span><span class="string">&quot;\&lt;lbrace&gt;_/ \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub>/ &lang;=&gt; _, _, _&rang;\&lt;rbrace&gt;&quot;</span> 1000<span class="delimiter">)</span> 
  <span class="keyword2">where</span> <span class="string">&quot;\&lt;lbrace&gt;c \&lt;parallel&gt;<span class="hidden">&#8681;</span><sub>G</sub> &lang;=&gt; u, p, v&rang;\&lt;rbrace&gt; &equiv; Graph.isSimplePath c u p v&quot;</span>
<span class="keyword2">end</span>  
<span class="comment">(*&gt;*)</span>

<span class="keyword1">subsection</span> <span class="cartouche">&#8249;Properties&#8250;</span>

<span class="keyword1">subsubsection</span> <span class="cartouche">&#8249;Basic Properties&#8250;</span>
<span class="keyword1">context</span> Graph
<span class="keyword2">begin</span>

<span class="keyword1">lemma</span> V_alt<span class="delimiter">:</span> <span class="string">&quot;V = fst`E &cup; snd`E&quot;</span> <span class="keyword1">unfolding</span> V_def <span class="keyword1">by</span> force

<span class="keyword1">lemma</span> E_ss_VxV<span class="delimiter">:</span> <span class="string">&quot;E &sube; V&times;V&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> V_def<span class="delimiter">)</span>

<span class="keyword1">lemma</span> Vfin_imp_Efin<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="keyword2">assumes</span> <span class="string">&quot;finite V&quot;</span> <span class="keyword2">shows</span> <span class="string">&quot;finite E&quot;</span>
  <span class="keyword1">using</span> E_ss_VxV assms <span class="keyword1">by</span> <span class="delimiter">(</span>auto intro<span class="delimiter">:</span> finite_subset<span class="delimiter">)</span>

<span class="keyword1">lemma</span> Efin_imp_Vfin<span class="delimiter">:</span> <span class="string">&quot;finite E ==&gt; finite V&quot;</span>
  <span class="keyword1">unfolding</span> V_alt <span class="keyword1">by</span> auto

<span class="keyword1">lemma</span> zero_cap_simp<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;(u,v)&notin;E ==&gt; c (u,v) = 0&quot;</span>  
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> E_def<span class="delimiter">)</span>

<span class="keyword1">lemma</span> succ_ss_V<span class="delimiter">:</span> <span class="string">&quot;E``{u} &sube; V&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> V_def<span class="delimiter">)</span>

<span class="keyword1">lemma</span> pred_ss_V<span class="delimiter">:</span> <span class="string">&quot;E&macr;``{u} &sube; V&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> V_def<span class="delimiter">)</span>


<span class="keyword1">lemma</span> 
  incoming_edges<span class="delimiter">:</span> <span class="string">&quot;incoming u &sube; E&quot;</span> <span class="keyword2">and</span>
  outgoing_edges<span class="delimiter">:</span> <span class="string">&quot;outgoing u &sube; E&quot;</span> <span class="keyword2">and</span>
  incoming&#39;_edges<span class="delimiter">:</span> <span class="string">&quot;incoming&#39; U &sube; E&quot;</span> <span class="keyword2">and</span>
  outgoing&#39;_edges<span class="delimiter">:</span> <span class="string">&quot;outgoing&#39; U &sube; E&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> incoming_def outgoing_def incoming&#39;_def outgoing&#39;_def<span class="delimiter">)</span>
  
<span class="keyword1">lemma</span> 
  incoming_alt<span class="delimiter">:</span> <span class="string">&quot;incoming u = (&lambda;v. (v,u))`(E&macr;``{u})&quot;</span> <span class="keyword2">and</span>
  outgoing_alt<span class="delimiter">:</span> <span class="string">&quot;outgoing u = Pair u`(E``{u})&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> incoming_def outgoing_def<span class="delimiter">)</span>

<span class="keyword1">lemma</span> 
  finite_incoming<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;finite V ==&gt; finite (incoming u)&quot;</span> <span class="keyword2">and</span>
  finite_outgoing<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;finite V ==&gt; finite (outgoing u)&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> incoming_alt outgoing_alt intro<span class="delimiter">:</span> finite_Image<span class="delimiter">)</span>

<span class="keyword1">lemma</span> 
  finite_incoming&#39;<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;finite V ==&gt; finite (incoming&#39; U)&quot;</span> <span class="keyword2">and</span>
  finite_outgoing&#39;<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;finite V ==&gt; finite (outgoing&#39; U)&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto 
    intro<span class="delimiter">:</span> finite_subset<span class="delimiter">[</span>OF incoming&#39;_edges<span class="delimiter">]</span> 
    intro<span class="delimiter">:</span> finite_subset<span class="delimiter">[</span>OF outgoing&#39;_edges<span class="delimiter">]</span><span class="delimiter">)</span>


<span class="keyword1">subsubsection</span> <span class="cartouche">&#8249;Summations over Edges and Nodes&#8250;</span>  
<span class="keyword1">text</span> <span class="cartouche">&#8249;We provide useful alternative characterizations for summation over 
    all incoming or outgoing edges.&#8250;</span>
<span class="keyword1">lemma</span> sum_outgoing_pointwise<span class="delimiter">:</span> <span class="string">&quot;(&sum;e&isin;outgoing u. g e) = (&sum;v&isin;E``{u}. g (u,v))&quot;</span>  
<span class="keyword1">proof</span> -
  <span class="keyword1">have</span> <span class="string">&quot;(&sum;e&isin;outgoing u. g e) = (&sum;e&isin;(&lambda;v. (u,v))`(E``{u}). g e)&quot;</span>  
    <span class="keyword1">by</span> <span class="delimiter">(</span>rule setsum.cong<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> outgoing_def<span class="delimiter">)</span>
  <span class="keyword1">also</span> <span class="keyword1">have</span> <span class="string">&quot;&hellip; = (&sum;v&isin;E``{u}. g (u,v))&quot;</span>  
    <span class="keyword1">by</span> <span class="delimiter">(</span>subst setsum.reindex<span class="delimiter">)</span> auto
  <span class="keyword1">finally</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">.</span>
<span class="keyword1">qed</span>  

<span class="keyword1">lemma</span> sum_incoming_pointwise<span class="delimiter">:</span> <span class="string">&quot;(&sum;e&isin;incoming u. g e) = (&sum;v&isin;E&macr;``{u}. g (v,u))&quot;</span>  
<span class="keyword1">proof</span> -
  <span class="keyword1">have</span> <span class="string">&quot;(&sum;e&isin;incoming u. g e) = (&sum;e&isin;(&lambda;v. (v,u))`(E&macr;``{u}). g e)&quot;</span>  
    <span class="keyword1">by</span> <span class="delimiter">(</span>rule setsum.cong<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> incoming_def<span class="delimiter">)</span>
  <span class="keyword1">also</span> <span class="keyword1">have</span> <span class="string">&quot;&hellip; = (&sum;v&isin;E&macr;``{u}. g (v,u))&quot;</span>  
    <span class="keyword1">by</span> <span class="delimiter">(</span>subst setsum.reindex<span class="delimiter">)</span> auto
  <span class="keyword1">finally</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">.</span>
<span class="keyword1">qed</span>  

<span class="keyword1">text</span> <span class="cartouche">&#8249;Extend summations over incoming/outgoing edges to summations over
  all nodes, provided the summed-up function is zero for non-edges.&#8250;</span>
<span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> Finite_Graph<span class="delimiter">)</span> sum_incoming_extend<span class="delimiter">:</span>  
  <span class="keyword2">assumes</span> <span class="string">&quot;!!v. [| v&isin;V; (v,u)&notin;E |] ==&gt; g (v,u) = 0&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;(&sum;e&isin;incoming u. g e) = (&sum;v&isin;V. g (v,u))&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>subst sum_incoming_pointwise<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule setsum.mono_neutral_left<span class="delimiter">)</span>
  <span class="keyword1">using</span> assms pred_ss_V <span class="keyword1">by</span> auto

<span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> Finite_Graph<span class="delimiter">)</span> sum_outgoing_extend<span class="delimiter">:</span>  
  <span class="keyword2">assumes</span> <span class="string">&quot;!!v. [| v&isin;V; (u,v)&notin;E |] ==&gt; g (u,v) = 0&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;(&sum;e&isin;outgoing u. g e) = (&sum;v&isin;V. g (u,v))&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>subst sum_outgoing_pointwise<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule setsum.mono_neutral_left<span class="delimiter">)</span>
  <span class="keyword1">using</span> assms succ_ss_V <span class="keyword1">by</span> auto

<span class="keyword1">text</span> <span class="cartouche">&#8249;When summation is done over something that satisfies the capacity 
  constraint, e.g., a flow, the summation can be extended to all 
  outgoing/incoming edges, as the additional edges must have zero capacity.&#8250;</span>
<span class="comment">(* TODO: Historical lemmas. Get rid of &forall; quantifier. *)</span>
<span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> Finite_Graph<span class="delimiter">)</span> sum_outgoing_alt<span class="delimiter">:</span> <span class="string">&quot;[|&forall;e. 0 &le; g e &and; g e &le; c e|] ==&gt;
  &forall;v &isin; V. (&sum;e &isin; outgoing v. g e) = (&sum;u &isin; V. g (v, u))&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule ballI<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule sum_outgoing_extend<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> clarsimp
  <span class="keyword1">by</span> <span class="delimiter">(</span>metis antisym zero_cap_simp<span class="delimiter">)</span>
  
<span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> Finite_Graph<span class="delimiter">)</span> sum_incoming_alt<span class="delimiter">:</span> <span class="string">&quot;[|&forall;e. 0 &le; g e &and; g e &le; c e|] ==&gt;
  &forall;v &isin; V. (&sum;e &isin; incoming v. g e) = (&sum;u &isin; V. g (u, v))&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule ballI<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule sum_incoming_extend<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> clarsimp
  <span class="keyword1">by</span> <span class="delimiter">(</span>metis antisym zero_cap_simp<span class="delimiter">)</span>


<span class="keyword1">subsubsection</span> <span class="cartouche">&#8249;Finite Graphs&#8250;</span>

<span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> Finite_Graph<span class="delimiter">)</span> finite_E<span class="delimiter">[</span>simp<span class="delimiter">,</span>intro<span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;finite E&quot;</span> <span class="keyword1">by</span> simp

<span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> Graph<span class="delimiter">)</span> Finite_Graph_EI<span class="delimiter">:</span> <span class="string">&quot;finite E ==&gt; Finite_Graph c&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> unfold_locales
  <span class="keyword1">by</span> <span class="delimiter">(</span>rule Efin_imp_Vfin<span class="delimiter">)</span>
  
<span class="keyword1">subsubsection</span> <span class="cartouche">&#8249;Paths&#8250;</span>

<span class="keyword1">named_theorems</span> split_path_simps <span class="cartouche">&#8249;Simplification lemmas to split paths&#8250;</span>

<span class="keyword1">lemma</span> transfer_path<span class="delimiter">:</span>
  <span class="delimiter">--</span> <span class="cartouche">&#8249;Transfer path to another graph&#8250;</span>
  <span class="keyword2">assumes</span> <span class="string">&quot;set p&cap;E &sube; Graph.E c&#39;&quot;</span>
  <span class="keyword2">assumes</span> <span class="string">&quot;isPath u p v&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;Graph.isPath c&#39; u p v&quot;</span>
  <span class="keyword1">using</span> assms
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>induction u p v rule<span class="delimiter">:</span> isPath.induct<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> Graph.isPath.simps<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">done</span></span>

<span class="keyword1">lemma</span> isPath_append<span class="delimiter">[</span>split_path_simps<span class="delimiter">]</span><span class="delimiter">:</span> 
  <span class="string">&quot;isPath u (p1 @ p2) v &lt;-&gt; (&exist;w. isPath u p1 w &and; isPath w p2 v)&quot;</span>  
  <span class="keyword1">by</span> <span class="delimiter">(</span>induction p1 arbitrary<span class="delimiter">:</span> u<span class="delimiter">)</span> auto 
  
<span class="keyword1">lemma</span> isPath_head<span class="delimiter">[</span>split_path_simps<span class="delimiter">]</span><span class="delimiter">:</span> 
  <span class="string">&quot;isPath u (e#p) v &lt;-&gt; fst e = u &and; e &isin; E &and; isPath (snd e) p v&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>cases e<span class="delimiter">)</span> auto

<span class="keyword1">lemma</span> isPath_head2<span class="delimiter">:</span> 
  <span class="string">&quot;isPath u (e#p) v ==&gt; (p = [] &or; (p &ne; [] &and; fst (hd p) = snd e))&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.isPath_head list.collapse<span class="delimiter">)</span>
  
<span class="keyword1">lemma</span> isPath_tail<span class="delimiter">:</span> 
  <span class="string">&quot;isPath u (p@[e]) v &lt;-&gt; isPath u p (fst e) &and; e &isin; E &and; snd e = v&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>induction p<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isPath_append isPath_head<span class="delimiter">)</span>

<span class="keyword1">lemma</span> isPath_tail2<span class="delimiter">:</span> 
  <span class="string">&quot;isPath u (p@[e]) v ==&gt; (p = [] &or; (p &ne; [] &and; snd (last p) = fst e))&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.isPath_tail append_butlast_last_id<span class="delimiter">)</span>
      
<span class="comment">(* TODO: Really needed? *)</span>  
<span class="keyword1">lemma</span> isPath_append_edge<span class="delimiter">:</span> 
  <span class="string">&quot;isPath v p v&#39; ==&gt; (v&#39;,v&#39;&#39;)&isin;E ==&gt; isPath v (p@[(v&#39;,v&#39;&#39;)]) v&#39;&#39;&quot;</span>  
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isPath_append<span class="delimiter">)</span>

<span class="keyword1">lemma</span> isPath_edgeset<span class="delimiter">:</span> <span class="string">&quot;[|isPath u p v; e &isin; set p|] ==&gt; e &isin; E&quot;</span>
  <span class="keyword1">using</span> E_def 
  <span class="keyword1">by</span> <span class="delimiter">(</span>metis isPath_head isPath_append in_set_conv_decomp_first<span class="delimiter">)</span>
  
<span class="keyword1">lemma</span> isPath_rtc<span class="delimiter">:</span> <span class="string">&quot;isPath u p v ==&gt; (u, v) &isin; E<span class="hidden">&#8679;</span><sup>*</sup>&quot;</span>
<span class="keyword1">proof</span> <span class="delimiter">(</span>induction p arbitrary<span class="delimiter">:</span> u<span class="delimiter">)</span>
  <span class="keyword3">case</span> Nil
  <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">by</span> auto
<span class="keyword1">next</span>
  <span class="keyword3">case</span> <span class="delimiter">(</span>Cons e es<span class="delimiter">)</span>
  <span class="keyword3">obtain</span> u1 u2 <span class="keyword2">where</span> <span class="string">&quot;e = (u1, u2)&quot;</span> <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases e<span class="delimiter">)</span> <span class="keyword1">by</span> auto
  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;u = u1 &and; isPath u2 es v &and; (u1, u2) &isin; E&quot;</span>
    <span class="keyword1">using</span> isPath.simps<span class="delimiter">(</span>2<span class="delimiter">)</span> Cons.prems <span class="keyword1">by</span> auto
  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(u, u2) &isin; E&quot;</span> <span class="keyword2">and</span> <span class="string">&quot;(u2, v) &isin; E<span class="hidden">&#8679;</span><sup>*</sup>&quot;</span> <span class="keyword1">using</span> Cons.IH <span class="keyword1">by</span> auto
  <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">by</span> auto 
<span class="keyword1">qed</span>
  
<span class="keyword1">lemma</span> rtc_isPath<span class="delimiter">:</span> <span class="string">&quot;(u, v) &isin; E<span class="hidden">&#8679;</span><sup>*</sup> ==&gt; (&exist;p. isPath u p v)&quot;</span>
<span class="keyword1">proof</span> <span class="delimiter">(</span>induction rule<span class="delimiter">:</span> rtrancl.induct<span class="delimiter">)</span>
  <span class="keyword3">case</span> <span class="delimiter">(</span>rtrancl_refl a<span class="delimiter">)</span>
  <span class="keyword1">have</span> <span class="string">&quot;isPath a [] a&quot;</span> <span class="keyword1">by</span> simp
  <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">by</span> blast
<span class="keyword1">next</span>
  <span class="keyword3">case</span> <span class="delimiter">(</span>rtrancl_into_rtrancl u u&#39; v<span class="delimiter">)</span>
  <span class="keyword1">then</span> <span class="keyword3">obtain</span> p1 <span class="keyword2">where</span> <span class="string">&quot;isPath u p1 u&#39;&quot;</span> <span class="keyword1">by</span> blast
  <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;(u&#39;, v) &isin; E&quot;</span> <span class="keyword1">using</span> rtrancl_into_rtrancl.hyps<span class="delimiter">(</span>2<span class="delimiter">)</span> <span class="keyword1">by</span> simp
  <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;isPath u (p1 @ [(u&#39;, v)]) v&quot;</span> <span class="keyword1">using</span> isPath_tail <span class="keyword1">by</span> simp
  <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">by</span> blast
<span class="keyword1">qed</span>
    
<span class="keyword1">lemma</span> rtci_isPath<span class="delimiter">:</span> <span class="string">&quot;(v, u) &isin; (E&macr;)<span class="hidden">&#8679;</span><sup>*</sup> ==&gt; (&exist;p. isPath u p v)&quot;</span>
<span class="keyword1">proof</span> -
  <span class="keyword3">assume</span> <span class="string">&quot;(v,u)&isin;(E&macr;)<span class="hidden">&#8679;</span><sup>*</sup>&quot;</span> 
  <span class="keyword1">hence</span> <span class="string">&quot;(u,v)&isin;E<span class="hidden">&#8679;</span><sup>*</sup>&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>rule rtrancl_converseD<span class="delimiter">)</span>
  <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> <span class="delimiter">(</span>rule rtc_isPath<span class="delimiter">)</span>
<span class="keyword1">qed</span>      
  
<span class="keyword1">lemma</span> isPath_ex_edge1<span class="delimiter">:</span> 
  <span class="keyword2">assumes</span> <span class="string">&quot;isPath u p v&quot;</span>
  <span class="keyword2">assumes</span> <span class="string">&quot;(u1, v1) &isin; set p&quot;</span>
  <span class="keyword2">assumes</span> <span class="string">&quot;u1 &ne; u&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;&exist;u2. (u2, u1) &isin; set p&quot;</span>
<span class="keyword1">proof</span> -
  <span class="keyword3">obtain</span> w1 w2 <span class="keyword2">where</span> obt1<span class="delimiter">:</span> <span class="string">&quot;p = w1 @ [(u1, v1)] @ w2&quot;</span> <span class="keyword1">using</span> assms<span class="delimiter">(</span>2<span class="delimiter">)</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>metis append_Cons append_Nil in_set_conv_decomp_first<span class="delimiter">)</span>
  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;isPath u w1 u1&quot;</span> <span class="keyword1">using</span> assms<span class="delimiter">(</span>1<span class="delimiter">)</span> isPath_append <span class="keyword1">by</span> auto
  <span class="keyword1">have</span> <span class="string">&quot;w1 &ne; []&quot;</span>
    <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
      <span class="keyword3">assume</span> <span class="string">&quot;&not; w1 &ne; []&quot;</span>
      <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;u = u1&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`isPath u w1 u1`</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis isPath.simps<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> assms<span class="delimiter">(</span>3<span class="delimiter">)</span> <span class="keyword1">by</span> blast
    <span class="keyword1">qed</span>
  <span class="keyword1">then</span> <span class="keyword3">obtain</span> e w1&#39; <span class="keyword2">where</span> obt2<span class="delimiter">:</span><span class="string">&quot;w1 = w1&#39; @ [e]&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis append_butlast_last_id<span class="delimiter">)</span>
  <span class="keyword1">then</span> <span class="keyword3">obtain</span> u2 <span class="keyword2">where</span> <span class="string">&quot;e = (u2, u1)&quot;</span> 
    <span class="keyword1">using</span> <span class="alt_string">`isPath u w1 u1`</span> isPath_tail <span class="keyword1">by</span> <span class="delimiter">(</span>metis prod.collapse<span class="delimiter">)</span>
  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;p = w1&#39; @ (u2, u1) # (u1, v1) # w2&quot;</span> <span class="keyword1">using</span> obt1 obt2 <span class="keyword1">by</span> auto 
  <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
<span class="keyword1">qed</span>

<span class="keyword1">lemma</span> isPath_ex_edge2<span class="delimiter">:</span> 
  <span class="keyword2">assumes</span> <span class="string">&quot;isPath u p v&quot;</span>
  <span class="keyword2">assumes</span> <span class="string">&quot;(u1, v1) &isin; set p&quot;</span>
  <span class="keyword2">assumes</span> <span class="string">&quot;v1 &ne; v&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;&exist;v2. (v1, v2) &isin; set p&quot;</span>
<span class="keyword1">proof</span> -
  <span class="keyword3">obtain</span> w1 w2 <span class="keyword2">where</span> obt1<span class="delimiter">:</span> <span class="string">&quot;p = w1 @ [(u1, v1)] @ w2&quot;</span> <span class="keyword1">using</span> assms<span class="delimiter">(</span>2<span class="delimiter">)</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>metis append_Cons append_Nil in_set_conv_decomp_first<span class="delimiter">)</span>
  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;isPath v1 w2 v&quot;</span> <span class="keyword1">using</span> assms<span class="delimiter">(</span>1<span class="delimiter">)</span> isPath_append <span class="keyword1">by</span> auto
  <span class="keyword1">have</span> <span class="string">&quot;w2 &ne; []&quot;</span>
    <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
      <span class="keyword3">assume</span> <span class="string">&quot;&not; w2 &ne; []&quot;</span>
      <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;v = v1&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`isPath v1 w2 v`</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis isPath.simps<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> assms<span class="delimiter">(</span>3<span class="delimiter">)</span> <span class="keyword1">by</span> blast
    <span class="keyword1">qed</span>
  <span class="keyword1">then</span> <span class="keyword3">obtain</span> e w2&#39; <span class="keyword2">where</span> obt2<span class="delimiter">:</span><span class="string">&quot;w2 =  e # w2&#39;&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis neq_Nil_conv<span class="delimiter">)</span>
  <span class="keyword1">then</span> <span class="keyword3">obtain</span> v2 <span class="keyword2">where</span> <span class="string">&quot;e = (v1, v2)&quot;</span> 
    <span class="keyword1">using</span> <span class="alt_string">`isPath v1 w2 v`</span> isPath_head <span class="keyword1">by</span> <span class="delimiter">(</span>metis prod.collapse<span class="delimiter">)</span>
  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;p = w1 @ (u1, v1) # (v1, v2) # w2&#39;&quot;</span> <span class="keyword1">using</span> obt1 obt2 <span class="keyword1">by</span> auto
  <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
<span class="keyword1">qed</span>

<span class="keyword1">subsubsection</span> <span class="cartouche">&#8249;Vertices of Paths&#8250;</span>

<span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> Graph<span class="delimiter">)</span> pathVertices_fwd_simps<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> 
  <span class="string">&quot;pathVertices_fwd s ([]) = [s]&quot;</span>  
  <span class="string">&quot;pathVertices_fwd s (e#p) = s#pathVertices_fwd (snd e) p&quot;</span>  
  <span class="string">&quot;pathVertices_fwd s (p@[e]) = pathVertices_fwd s p@[snd e]&quot;</span>
  <span class="string">&quot;pathVertices_fwd s (p1@e#p2) 
    = pathVertices_fwd s p1 @ pathVertices_fwd (snd e) p2&quot;</span>
  <span class="string">&quot;s&isin;set (pathVertices_fwd s p)&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> pathVertices_fwd_def<span class="delimiter">)</span>

<span class="keyword1">lemma</span> pathVertices_alt<span class="delimiter">:</span> <span class="string">&quot;p &ne; [] 
    ==&gt; pathVertices u p = map fst p @ [snd (last p)]&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>induction p arbitrary<span class="delimiter">:</span> u<span class="delimiter">)</span> auto

<span class="keyword1">lemma</span> pathVertices_singleton_iff<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;pathVertices s p = [u] &lt;-&gt; (p=[] &and; s=u)&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases p rule<span class="delimiter">:</span> rev_cases<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> pathVertices_alt<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">done</span></span>

<span class="keyword1">lemma</span> length_pathVertices_eq<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;length (pathVertices u p) = length p + 1&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases <span class="string">&quot;p=[]&quot;</span><span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> pathVertices_alt<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">done</span></span>

<span class="keyword1">lemma</span> pathVertices_edgeset<span class="delimiter">:</span> <span class="string">&quot;[|u&isin;V; isPath u p v|] ==&gt; set (pathVertices u p) &sube; V&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases p rule<span class="delimiter">:</span> rev_cases<span class="delimiter">;</span> simp<span class="delimiter">)</span>
  <span class="keyword1">using</span> isPath_edgeset<span class="delimiter">[</span>of u p v<span class="delimiter">]</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>fastforce simp<span class="delimiter">:</span> pathVertices_alt V_def<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">done</span></span>

<span class="keyword1">lemma</span> pathVertices_append<span class="delimiter">:</span> <span class="string">&quot;pathVertices u (p1 @ p2) = 
butlast (pathVertices u p1) @ pathVertices (last (pathVertices u p1)) p2&quot;</span>
<span class="keyword1">proof</span> <span class="delimiter">(</span>induction p1 arbitrary<span class="delimiter">:</span> u<span class="delimiter">)</span>
  <span class="keyword3">case</span> Nil
    <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">by</span> auto
<span class="keyword1">next</span>
  <span class="keyword3">case</span> <span class="delimiter">(</span>Cons e es<span class="delimiter">)</span>
  <span class="keyword1">have</span> <span class="string">&quot;pathVertices u ((e # es) @ p2) =  fst e # pathVertices (snd e) (es @ p2)&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.pathVertices.simps<span class="delimiter">(</span>2<span class="delimiter">)</span> append_Cons<span class="delimiter">)</span>
  <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;pathVertices (snd e) (es @ p2) 
    = butlast (pathVertices (snd e) es) 
      @ pathVertices (last (pathVertices (snd e) es)) p2&quot;</span> 
    <span class="keyword1">using</span> Cons.IH <span class="keyword1">by</span> auto
  <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;fst e # butlast (pathVertices (snd e) es) = 
    butlast (fst e # pathVertices (snd e) es)&quot;</span> 
    <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.pathVertices.simps<span class="delimiter">(</span>1<span class="delimiter">)</span>
        Graph.pathVertices_alt Nil_is_append_conv butlast.simps<span class="delimiter">(</span>2<span class="delimiter">)</span> 
        list.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;fst e # pathVertices (snd e) es = pathVertices u (e # es)&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.pathVertices.simps<span class="delimiter">(</span>2<span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;last (pathVertices (snd e) es) = last (pathVertices u (e # es))&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.pathVertices.simps<span class="delimiter">(</span>1<span class="delimiter">)</span> Graph.pathVertices_alt 
    last.simps last_snoc list.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?case</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis append_Cons<span class="delimiter">)</span>
<span class="keyword1">qed</span>

<span class="keyword1">lemma</span> split_path_at_vertex<span class="delimiter">:</span> 
  <span class="keyword2">assumes</span> <span class="string">&quot;u&isin;set (pathVertices_fwd s p)&quot;</span>
  <span class="keyword2">assumes</span> <span class="string">&quot;isPath s p t&quot;</span>
  <span class="keyword2">obtains</span> p1 p2 <span class="keyword2">where</span> <span class="string">&quot;p=p1@p2&quot;</span> <span class="string">&quot;isPath s p1 u&quot;</span> <span class="string">&quot;isPath u p2 t&quot;</span>
  <span class="keyword1">using</span> assms
  <span class="keyword1"><span class="improper">apply</span></span> -
  <span class="comment">(*unfolding pathVertices_fwd*)</span>
  <span class="keyword1">unfolding</span> pathVertices_fwd_def
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> in_set_conv_decomp isPath_append<span class="delimiter">)</span> 
  <span class="keyword1"><span class="improper">apply</span></span> force
  <span class="keyword1">by</span> <span class="delimiter">(</span>metis Graph.isPath_append_edge append_Cons append_Nil append_assoc<span class="delimiter">)</span>


<span class="keyword1">lemma</span> split_path_at_vertex_complete<span class="delimiter">:</span> 
  <span class="keyword2">assumes</span> <span class="string">&quot;isPath s p t&quot;</span> <span class="string">&quot;pathVertices_fwd s p = pv1@u#pv2&quot;</span> 
  <span class="keyword2">obtains</span> p1 p2 <span class="keyword2">where</span> 
    <span class="string">&quot;p=p1@p2&quot;</span> 
    <span class="string">&quot;isPath s p1 u&quot;</span> <span class="string">&quot;pathVertices_fwd s p1 = pv1@[u]&quot;</span> 
    <span class="string">&quot;isPath u p2 t&quot;</span> <span class="string">&quot;pathVertices_fwd u p2 = u#pv2&quot;</span> 
<span class="keyword1">proof</span> -
  <span class="keyword1">from</span> assms <span class="keyword1">have</span> PV<span class="delimiter">:</span> <span class="string">&quot;pathVertices s p = pv1@u#pv2&quot;</span> 
    <span class="keyword1">by</span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> pathVertices_fwd<span class="delimiter">)</span>
  <span class="keyword1">then</span> <span class="keyword3">obtain</span> p1 p2 <span class="keyword2">where</span> 
    <span class="string">&quot;p=p1@p2&quot;</span> 
    <span class="string">&quot;isPath s p1 u&quot;</span> <span class="string">&quot;pathVertices s p1 = pv1@[u]&quot;</span> 
    <span class="string">&quot;isPath u p2 t&quot;</span> <span class="string">&quot;pathVertices u p2 = u#pv2&quot;</span>
  <span class="keyword1">proof</span> -
    <span class="keyword3">show</span> thesis
    <span class="keyword1">using</span> assms<span class="delimiter">(</span>1<span class="delimiter">)</span> PV
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases p rule<span class="delimiter">:</span> rev_cases<span class="delimiter">;</span> clarsimp simp<span class="delimiter">:</span> pathVertices_alt<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule that<span class="delimiter">[</span>of <span class="string">&quot;[]&quot;</span> <span class="string">&quot;[]&quot;</span><span class="delimiter">]</span><span class="delimiter">;</span> simp<span class="delimiter">)</span>

      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases pv2<span class="delimiter">;</span> clarsimp<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule that<span class="delimiter">[</span>of p <span class="string">&quot;[]&quot;</span><span class="delimiter">]</span><span class="delimiter">;</span> 
        auto simp add<span class="delimiter">:</span> isPath_append pathVertices_alt
      <span class="delimiter">)</span>  

      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>clarsimp simp<span class="delimiter">:</span> append_eq_append_conv2<span class="delimiter">;</span> 
        auto elim<span class="delimiter">!</span><span class="delimiter">:</span> map_eq_concE map_eq_consE list_append_eq_Cons_cases
            simp<span class="delimiter">:</span> isPath_append<span class="delimiter">)</span>

        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rename_tac l<span class="delimiter">)</span>
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>erule that<span class="delimiter">)</span> 
        <span class="keyword1"><span class="improper">apply</span></span> auto <span class="delimiter">[</span>4<span class="delimiter">]</span>
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>case_tac l rule<span class="delimiter">:</span> rev_cases<span class="delimiter">;</span> 
          auto simp add<span class="delimiter">:</span> pathVertices_alt isPath_append<span class="delimiter">)</span>

        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rename_tac l<span class="delimiter">)</span>
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>erule that<span class="delimiter">)</span> 
        <span class="keyword1"><span class="improper">apply</span></span> auto <span class="delimiter">[</span>4<span class="delimiter">]</span>
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>case_tac l rule<span class="delimiter">:</span> rev_cases<span class="delimiter">;</span> 
          auto simp add<span class="delimiter">:</span> pathVertices_alt isPath_append<span class="delimiter">)</span>

        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rename_tac l u1 u2 u3<span class="delimiter">)</span>
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>erule that<span class="delimiter">)</span>  
        <span class="keyword1"><span class="improper">apply</span></span> auto <span class="delimiter">[</span>4<span class="delimiter">]</span>
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>case_tac l rule<span class="delimiter">:</span> rev_cases<span class="delimiter">;</span> 
          auto simp add<span class="delimiter">:</span> pathVertices_alt isPath_append<span class="delimiter">)</span>
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isPath_append<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> pathVertices_alt<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
        
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rename_tac l<span class="delimiter">)</span>
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>erule that<span class="delimiter">)</span> <span class="keyword1"><span class="improper">apply</span></span> auto <span class="delimiter">[</span>4<span class="delimiter">]</span>
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>case_tac l rule<span class="delimiter">:</span> rev_cases<span class="delimiter">;</span> 
          auto simp add<span class="delimiter">:</span> pathVertices_alt isPath_append<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">done</span></span>
  <span class="keyword1">qed</span>
  <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1"><span class="improper">apply</span></span> - <span class="keyword1">unfolding</span> pathVertices_fwd <span class="keyword1">using</span> that <span class="keyword1">.</span>
<span class="keyword1">qed</span>

<span class="keyword1">lemma</span> isPath_fwd_cases<span class="delimiter">:</span> 
  <span class="keyword2">assumes</span> <span class="string">&quot;isPath s p t&quot;</span>
  <span class="keyword2">obtains</span> <span class="string">&quot;p=[]&quot;</span> <span class="string">&quot;t=s&quot;</span>
    <span class="delimiter">|</span> p&#39; u <span class="keyword2">where</span> <span class="string">&quot;p=(s,u)#p&#39;&quot;</span> <span class="string">&quot;(s,u)&isin;E&quot;</span> <span class="string">&quot;isPath u p&#39; t&quot;</span>
    <span class="keyword1">using</span> assms <span class="keyword1">by</span> <span class="delimiter">(</span>cases p<span class="delimiter">)</span> <span class="delimiter">(</span>auto<span class="delimiter">)</span>

<span class="keyword1">lemma</span> isPath_bwd_cases<span class="delimiter">:</span> 
  <span class="keyword2">assumes</span> <span class="string">&quot;isPath s p t&quot;</span>
  <span class="keyword2">obtains</span> <span class="string">&quot;p=[]&quot;</span> <span class="string">&quot;t=s&quot;</span>
    <span class="delimiter">|</span> p&#39; u <span class="keyword2">where</span> <span class="string">&quot;p=p&#39;@[(u,t)]&quot;</span> <span class="string">&quot;isPath s p&#39; u&quot;</span> <span class="string">&quot;(u,t)&isin;E&quot;</span>
    <span class="keyword1">using</span> assms <span class="keyword1">by</span> <span class="delimiter">(</span>cases p rule<span class="delimiter">:</span> rev_cases<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> split_path_simps<span class="delimiter">)</span>


<span class="keyword1">lemma</span> pathVertices_edge<span class="delimiter">:</span> <span class="string">&quot;isPath s p t ==&gt; e &isin; set p ==&gt; 
  &exist;vs1 vs2. pathVertices_fwd s p = vs1 @ fst e # snd e # vs2&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases e<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> in_set_conv_decomp split_path_simps<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>erule isPath_bwd_cases<span class="delimiter">[</span><span class="keyword2">where</span> s<span class="delimiter">=</span>s<span class="delimiter">]</span><span class="delimiter">;</span> auto<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>erule isPath_fwd_cases<span class="delimiter">[</span><span class="keyword2">where</span> t<span class="delimiter">=</span>t<span class="delimiter">]</span><span class="delimiter">;</span> auto<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>erule isPath_fwd_cases<span class="delimiter">[</span><span class="keyword2">where</span> t<span class="delimiter">=</span>t<span class="delimiter">]</span><span class="delimiter">;</span> auto<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">done</span></span>  


<span class="comment">(* TODO: Really needed? *)</span>
<span class="keyword1">lemma</span> pathVertices_edge_old<span class="delimiter">:</span> <span class="string">&quot;isPath u p v ==&gt; e &isin; set p ==&gt; 
  &exist;vs1 vs2. pathVertices u p = vs1 @ fst e # snd e # vs2&quot;</span>
  <span class="keyword1">unfolding</span> pathVertices_fwd
  <span class="keyword1">by</span> <span class="delimiter">(</span>rule pathVertices_edge<span class="delimiter">)</span>

<span class="keyword1">subsubsection</span> <span class="cartouche">&#8249;Reachability&#8250;</span>

<span class="keyword1">lemma</span> connected_refl<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;connected v v&quot;</span> 
  <span class="keyword1">unfolding</span> connected_def <span class="keyword1">by</span> <span class="delimiter">(</span>force intro<span class="delimiter">:</span> exI<span class="delimiter">[</span><span class="keyword2">where</span> x<span class="delimiter">=</span><span class="string">&quot;[]&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>

<span class="keyword1">lemma</span> connected_append_edge<span class="delimiter">:</span> <span class="string">&quot;connected u v ==&gt; (v,w)&isin;E ==&gt; connected u w&quot;</span>
  <span class="keyword1">unfolding</span> connected_def <span class="keyword1">by</span> <span class="delimiter">(</span>auto intro<span class="delimiter">:</span> isPath_append_edge<span class="delimiter">)</span>

<span class="keyword1">lemma</span> connected_inV_iff<span class="delimiter">:</span> <span class="string">&quot;[|connected u v|] ==&gt; v&isin;V &lt;-&gt; u&isin;V&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> connected_def<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>case_tac p<span class="delimiter">;</span> auto simp<span class="delimiter">:</span> V_def<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>case_tac p rule<span class="delimiter">:</span> rev_cases<span class="delimiter">;</span> auto simp<span class="delimiter">:</span> isPath_append V_def<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
  <span class="keyword1"><span class="improper">done</span></span>

<span class="keyword1">lemma</span> connected_edgeRtc<span class="delimiter">:</span> <span class="string">&quot;connected u v &lt;-&gt; (u, v) &isin; E<span class="hidden">&#8679;</span><sup>*</sup>&quot;</span>  
  <span class="keyword1">using</span> isPath_rtc rtc_isPath
  <span class="keyword1">unfolding</span> connected_def <span class="keyword1">by</span> blast

<span class="keyword1">lemma</span> reachable_ss_V<span class="delimiter">:</span> <span class="string">&quot;s &isin; V ==&gt; reachableNodes s &sube; V&quot;</span>
<span class="keyword1">proof</span>
  <span class="keyword3">assume</span> asm<span class="delimiter">:</span> <span class="string">&quot;s &isin; V&quot;</span>
  <span class="keyword3">fix</span> x
  <span class="keyword3">assume</span> <span class="string">&quot;x &isin; reachableNodes s&quot;</span>
  <span class="keyword1">then</span> <span class="keyword3">obtain</span> p <span class="keyword2">where</span> <span class="string">&quot;x &isin; {v. isPath s p v}&quot;</span>
    <span class="keyword1">unfolding</span> reachableNodes_def connected_def <span class="keyword1">by</span> blast
  <span class="keyword3">thus</span> <span class="string">&quot;x &isin; V&quot;</span> <span class="keyword1">using</span> asm
    <span class="keyword1">by</span> <span class="delimiter">(</span>induction p arbitrary<span class="delimiter">:</span> s<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isPath_head V_alt<span class="delimiter">)</span> 
<span class="keyword1">qed</span>

<span class="keyword1">lemma</span> reachableNodes_E_closed<span class="delimiter">:</span> <span class="string">&quot;E``reachableNodes s &sube; reachableNodes s&quot;</span>  
  <span class="keyword1">unfolding</span> reachableNodes_def <span class="keyword1">by</span> <span class="delimiter">(</span>auto intro<span class="delimiter">:</span> connected_append_edge<span class="delimiter">)</span>

<span class="keyword1">corollary</span> reachableNodes_append_edge<span class="delimiter">:</span> 
  <span class="string">&quot;u&isin;reachableNodes s ==&gt; (u,v)&isin;E ==&gt; v&isin;reachableNodes s&quot;</span>
  <span class="keyword1">using</span> reachableNodes_E_closed <span class="keyword1">by</span> blast


<span class="keyword1">subsubsection</span> <span class="cartouche">&#8249;Simple Paths&#8250;</span>

<span class="keyword1">lemma</span> isSimplePath_fwd<span class="delimiter">:</span> <span class="string">&quot;isSimplePath s p t 
  &lt;-&gt; isPath s p t &and; distinct (pathVertices_fwd s p)&quot;</span>  
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_def pathVertices_fwd<span class="delimiter">)</span>

<span class="keyword1">lemma</span> isSimplePath_singelton<span class="delimiter">[</span>split_path_simps<span class="delimiter">]</span><span class="delimiter">:</span> 
  <span class="string">&quot;isSimplePath u [e] v &lt;-&gt; (e=(u,v) &and; u&ne;v &and; (u,v)&isin;E)&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_def isPath_head<span class="delimiter">)</span>

<span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> Graph<span class="delimiter">)</span> isSimplePath_append<span class="delimiter">[</span>split_path_simps<span class="delimiter">]</span><span class="delimiter">:</span> 
  <span class="string">&quot;isSimplePath s (p1@p2) t 
    &lt;-&gt; (&exist;u. 
      isSimplePath s p1 u 
    &and; isSimplePath u p2 t 
    &and; set (pathVertices_fwd s p1) &cap; set (pathVertices_fwd u p2) = {u})&quot;</span>  
  <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;_ &lt;-&gt; ?R&quot;</span><span class="delimiter">)</span>
  <span class="keyword1">unfolding</span> isSimplePath_fwd
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases p1 rule<span class="delimiter">:</span> rev_cases<span class="delimiter">;</span> simp<span class="delimiter">;</span> cases p2<span class="delimiter">;</span> simp<span class="delimiter">)</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> split_path_simps<span class="delimiter">)</span>
  
<span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> Graph<span class="delimiter">)</span> isSimplePath_cons<span class="delimiter">[</span>split_path_simps<span class="delimiter">]</span><span class="delimiter">:</span> 
  <span class="string">&quot;isSimplePath s (e#p) t 
  &lt;-&gt; (&exist;u. e=(s,u) &and; s&ne;u &and; (s,u)&isin;E 
        &and; isSimplePath u p t &and; s&notin;set (pathVertices_fwd u p))&quot;</span>
  <span class="keyword1">using</span> isSimplePath_append<span class="delimiter">[</span>of s <span class="string">&quot;[e]&quot;</span> p t<span class="delimiter">,</span> simplified<span class="delimiter">]</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> split_path_simps<span class="delimiter">)</span>

<span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> Finite_Graph<span class="delimiter">)</span> simplePath_length_less_V<span class="delimiter">:</span>
  <span class="keyword2">assumes</span> UIV<span class="delimiter">:</span> <span class="string">&quot;u&isin;V&quot;</span>
  <span class="keyword2">assumes</span> P<span class="delimiter">:</span> <span class="string">&quot;isSimplePath u p v&quot;</span> 
  <span class="keyword2">shows</span> <span class="string">&quot;length p &lt; card V&quot;</span>
<span class="keyword1">proof</span> -
  <span class="keyword1">from</span> P <span class="keyword1">have</span> 1<span class="delimiter">:</span> <span class="string">&quot;isPath u p v&quot;</span> <span class="keyword2">and</span> 2<span class="delimiter">:</span> <span class="string">&quot;distinct (pathVertices u p)&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_def<span class="delimiter">)</span>
  <span class="keyword1">from</span> pathVertices_edgeset<span class="delimiter">[</span>OF UIV 1<span class="delimiter">]</span> <span class="keyword1">have</span> <span class="string">&quot;set (pathVertices u p) &sube; V&quot;</span> <span class="keyword1">.</span>
  <span class="keyword1">with</span> 2 finite_V <span class="keyword1">have</span> <span class="string">&quot;length (pathVertices u p) &le; card V&quot;</span>
    <span class="keyword1">using</span> distinct_card card_mono <span class="keyword1">by</span> metis
  <span class="keyword1">hence</span> <span class="string">&quot;length p + 1 &le; card V&quot;</span> <span class="keyword1">by</span> simp
  <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
<span class="keyword1">qed</span>      

<span class="keyword1">lemma</span> split_simple_path<span class="delimiter">:</span> <span class="string">&quot;isSimplePath u (p1@p2) v 
  ==&gt; (&exist;w. isSimplePath u p1 w &and; isSimplePath w p2 v)&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_def isPath_append<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule exI<span class="delimiter">;</span> intro conjI<span class="delimiter">;</span> assumption<span class="delimiter">?</span><span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases p1 rule<span class="delimiter">:</span> rev_cases<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
  <span class="keyword1"><span class="improper">apply</span></span> simp
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases p2<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> simp
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>clarsimp simp<span class="delimiter">:</span> pathVertices_alt isPath_append<span class="delimiter">)</span>

  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases p1 rule<span class="delimiter">:</span> rev_cases<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
  <span class="keyword1"><span class="improper">apply</span></span> simp
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases p2  rule<span class="delimiter">:</span> rev_cases<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> simp
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>clarsimp simp<span class="delimiter">:</span> pathVertices_alt isPath_append<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">done</span></span>  
      
<span class="keyword1">lemma</span> simplePath_empty_conv<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;isSimplePath s [] t &lt;-&gt; s=t&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_def<span class="delimiter">)</span>

<span class="keyword1">lemma</span> simplePath_same_conv<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;isSimplePath s p s &lt;-&gt; p=[]&quot;</span>  
  <span class="keyword1"><span class="improper">apply</span></span> rule
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases p<span class="delimiter">;</span> simp<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rename_tac e pp<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>case_tac pp rule<span class="delimiter">:</span> rev_cases<span class="delimiter">;</span> simp<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_def pathVertices_alt isPath_append<span class="delimiter">)</span> <span class="delimiter">[</span>2<span class="delimiter">]</span>
  <span class="keyword1"><span class="improper">apply</span></span> simp
  <span class="keyword1"><span class="improper">done</span></span>

<span class="keyword1">lemma</span> isSPath_pathLE<span class="delimiter">:</span> <span class="string">&quot;isPath s p t ==&gt; &exist;p&#39;. isSimplePath s p&#39; t&quot;</span>
<span class="keyword1">proof</span> <span class="delimiter">(</span>induction p rule<span class="delimiter">:</span> length_induct<span class="delimiter">)</span>
  <span class="keyword3">case</span> <span class="delimiter">(</span>1 p<span class="delimiter">)</span>
  <span class="keyword1">hence</span> IH<span class="delimiter">:</span> <span class="string">&quot;!!p&#39;. [|length p&#39; &lt; length p; isPath s p&#39; t|] 
    ==&gt; &exist;p&#39;. isSimplePath s p&#39; t&quot;</span>
    <span class="keyword2">and</span> PATH<span class="delimiter">:</span> <span class="string">&quot;isPath s p t&quot;</span>
    <span class="keyword1">by</span> auto

  <span class="keyword3">show</span> <span class="string">&quot;&exist;p. isSimplePath s p t&quot;</span>  
  <span class="keyword1">proof</span> cases
    <span class="keyword3">assume</span> <span class="string">&quot;distinct (pathVertices_fwd s p)&quot;</span>
    <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> PATH <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_fwd<span class="delimiter">)</span>
  <span class="keyword1">next</span>
    <span class="keyword3">assume</span> <span class="string">&quot;&not;(distinct (pathVertices_fwd s p))&quot;</span>  
    <span class="keyword1">then</span> <span class="keyword3">obtain</span> pv1 pv2 pv3 u <span class="keyword2">where</span> <span class="string">&quot;pathVertices_fwd s p = pv1@u#pv2@u#pv3&quot;</span> 
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto dest<span class="delimiter">:</span> not_distinct_decomp<span class="delimiter">)</span>
    <span class="keyword1">then</span> <span class="keyword3">obtain</span> p1 p2 p3 <span class="keyword2">where</span>
      <span class="string">&quot;p = p1@p2@p3&quot;</span> <span class="string">&quot;p2&ne;[]&quot;</span> <span class="string">&quot;isPath s p1 u&quot;</span> <span class="string">&quot;isPath u p3 t&quot;</span>
      <span class="keyword1">using</span> PATH
      <span class="keyword1"><span class="improper">apply</span></span> -
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>erule <span class="delimiter">(</span>1<span class="delimiter">)</span> split_path_at_vertex_complete<span class="delimiter">[</span><span class="keyword2">where</span> s<span class="delimiter">=</span>s<span class="delimiter">]</span><span class="delimiter">;</span> simp<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>erule split_path_at_vertex_complete<span class="delimiter">[</span>of _ _ t <span class="string">&quot;u#pv2&quot;</span> u pv3<span class="delimiter">]</span><span class="delimiter">;</span> simp<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto intro<span class="delimiter">:</span> that<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">done</span></span>
    <span class="keyword1">hence</span> <span class="string">&quot;length (p1@p3) &lt; length p&quot;</span> <span class="string">&quot;isPath s (p1@p3) t&quot;</span>  
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> split_path_simps<span class="delimiter">)</span>
    <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">by</span> <span class="delimiter">(</span>rule IH<span class="delimiter">)</span>
  <span class="keyword1">qed</span>
<span class="keyword1">qed</span>  
      

<span class="keyword1">lemma</span> isSPath_no_selfloop<span class="delimiter">:</span> <span class="string">&quot;isSimplePath u p v ==&gt; (u1, u1) &notin; set p&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> in_set_conv_decomp split_path_simps<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">done</span></span>

<span class="keyword1">lemma</span> isSPath_sg_outgoing<span class="delimiter">:</span> <span class="string">&quot;[|isSimplePath u p v; (u1, v1) &isin; set p; v1 &ne; v2|] 
  ==&gt; (u1, v2) &notin; set p&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto 
    simp<span class="delimiter">:</span> in_set_conv_decomp isSimplePath_def pathVertices_alt
    elim<span class="delimiter">!</span><span class="delimiter">:</span> Misc.list_match_lel_lel<span class="delimiter">)</span>

<span class="keyword1">lemma</span> isSPath_sg_incoming<span class="delimiter">:</span> 
  <span class="string">&quot;[|isSimplePath u p v; (u1, v1) &isin; set p; u1 &ne; u2|] ==&gt; (u2, v1) &notin; set p&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto 
    simp<span class="delimiter">:</span> in_set_conv_decomp isSimplePath_fwd pathVertices_fwd_def
    elim<span class="delimiter">!</span><span class="delimiter">:</span> Misc.list_match_lel_lel<span class="delimiter">)</span>

    <span class="comment">(* TODO: There should be a much simpler proof! 
      Unused lemma.
    *)</span>  
<span class="comment">(*
    lemma isSPath_no_returning: &quot;[|isSimplePath u p v; (u1, v1) &isin; set p|] ==&gt;
      (&exist;es1 es2. p = es1 @ (v2, u1) # (u1, v1) # es2 &or; (v2, u1) &notin; set p)&quot;
      proof -
        assume asm1: &quot;isSimplePath u p v&quot;
        assume asm2: &quot;(u1, v1) &isin; set p&quot;
        show ?thesis
          proof (rule ccontr)
            assume asm_s: &quot;&not; (&exist;es1 es2. p = es1 @ (v2, u1) # (u1, v1) # es2 &or; (v2, u1) &notin; set p)&quot;
            have asm_s1: &quot;&forall; es1 es2. p &ne; es1 @ (v2, u1) # (u1, v1) # es2&quot; using asm_s by auto
            have asm_s2: &quot;(v2, u1) &isin; set p&quot; using asm_s by auto 
            obtain w1 w2 where obt1: &quot;p = w1 @ (u1, v1) # w2&quot; 
              using asm2 by (metis in_set_conv_decomp)
            then have &quot;(v2, u1) = (u1, v1) &or; ((v2, u1) &isin; (set w1) &or; (v2, u1) &isin; (set w2))&quot; 
              using asm_s2 by (metis Un_iff set_ConsD set_append)
            then show &quot;False&quot;
              proof 
                assume &quot;(v2, u1) = (u1, v1)&quot;
                then have &quot;(u1, u1) &isin; set p&quot; using asm2 by auto 
                thus ?thesis using asm1 isSPath_no_selfloop by auto
              next
                assume &quot;(v2, u1) &isin; (set w1) &or; (v2, u1) &isin; (set w2)&quot;
                thus ?thesis
                  proof
                    assume &quot;(v2, u1) &isin; (set w1)&quot;
                    have &quot;pathVertices u p = butlast (pathVertices u w1) @  pathVertices (last 
                      (pathVertices u w1)) ((u1, v1) # w2)&quot; using obt1 pathVertices_append by auto
                    moreover {
                      have &quot;set w1 &ne; {}&quot; using `(v2, u1) &isin; (set w1)` by auto
                      {
                        obtain x where &quot;isPath u w1 x&quot; 
                          using obt1 asm1 isSimplePath_def isPath_append by auto
                        note pathVertices_edge_old[OF this `(v2, u1) &isin; (set w1)`]
                      }
                      then obtain vs1 vs2 where 
                        obt2: &quot;pathVertices u w1 = vs1 @ fst (v2, u1) # snd (v2, u1) # vs2&quot; by auto
                      moreover have &quot;vs2 &ne; []&quot;
                        proof (rule ccontr)
                          assume &quot;&not; vs2 &ne; []&quot;
                          then have fct1: &quot;pathVertices u w1 = vs1 @ [v2, u1]&quot; using obt2 by auto
                          {
                            have &quot;pathVertices u w1 = map fst w1 @ [snd (last w1)]&quot; 
                              using pathVertices_alt `set w1 &ne; {}` by auto
                            moreover have &quot;map fst w1 = map fst (butlast w1) @ [fst (last w1)]&quot; 
                              using `set w1 &ne; {}` by (metis last_map empty_set map_butlast
                              snoc_eq_iff_butlast zip_Nil zip_map_fst_snd)
                            ultimately have &quot;pathVertices u w1 = 
                              map fst (butlast w1) @ fst (last w1) # snd (last w1) # []&quot; by auto
                          }  note fct2 = this
                          have &quot;map fst (butlast w1) @ [fst (last w1)] = vs1 @ [v2]&quot; using fct1
                            fct2 by (metis butlast.simps(2) butlast_append list.distinct(1)) 
                          then have &quot;fst (last w1) = v2&quot; by (metis last_snoc)
                          moreover have &quot;snd (last w1) = u1&quot; using fct1 fct2  
                            by (metis append_Cons append_Nil last_appendR last_snoc)
                          ultimately have &quot;last w1 = (v2, u1)&quot; by auto
                          moreover have &quot;(v2, u1) &ne; last w1&quot;
                            proof (rule ccontr)
                              assume &quot;&not; (v2, u1) &ne; last w1&quot;
                              moreover have &quot;butlast w1 @ [last w1] = w1&quot; using `set w1 &ne; {}` 
                                by (metis append_butlast_last_id list.set(1))
                              ultimately have &quot;p = butlast w1 @ (v2, u1) # (u1, v1) # w2&quot; 
                                using obt1 by auto
                              thus &quot;False&quot; using asm_s1 by auto
                            qed
                          ultimately show &quot;False&quot; by metis
                        qed
                      ultimately have &quot;&exist; vs1&#39; vs2&#39;. butlast (pathVertices u w1) = 
                        vs1&#39; @ v2 # u1 # vs2&#39;&quot; by (metis butlast.simps(2)
                        butlast_append fst_conv list.distinct(1) snd_conv)
                    }
                    moreover have &quot;&exist;vs3&#39;. pathVertices (last (pathVertices u w1)) ((u1, v1) # w2) = 
                      u1 # vs3&#39;&quot; by (metis Graph.pathVertices.simps(2) fst_conv)
                    ultimately obtain vs1 vs2 vs3 where &quot;pathVertices u p = 
                      (vs1 @ v2 # u1 # vs2) @ (u1 # vs3)&quot; by auto
                    then have &quot;&not; distinct (pathVertices u p)&quot; by (metis append_Cons append_assoc
                      distinct.simps(2) distinct_append in_set_conv_decomp)
                    thus ?thesis using asm1 isSimplePath_def by auto
                  next
                    assume &quot;(v2, u1) &isin; (set w2)&quot;
                    have &quot;pathVertices u p = butlast (pathVertices u w1) @  pathVertices (last 
                      (pathVertices u w1)) ((u1, v1) # w2)&quot; using obt1 pathVertices_append by auto
                    moreover have &quot;pathVertices (last (pathVertices u w1)) ((u1, v1) # w2) = u1 # 
                      (pathVertices v1 w2)&quot; by (metis Graph.pathVertices.simps(2) fst_conv snd_conv)
                    moreover {
                      have &quot;isPath v1 w2 v&quot; using asm1 isSimplePath_def
                        by (metis Graph.isPath.simps(2) Graph.isPath_append obt1)
                      note pathVertices_edge_old[OF this `(v2, u1) &isin; (set w2)`]
                      then have &quot; &exist;vs1 vs2. pathVertices v1 w2 = vs1 @ v2 # u1 # vs2&quot; by auto
                    }
                    ultimately obtain vs1 vs2 vs3 where 
                      &quot;pathVertices u p = vs1 @ (u1 # vs2 @ v2 # u1 # vs3 )&quot; by auto
                    then have &quot;&not; distinct (pathVertices u p)&quot; by auto
                    thus ?thesis using asm1 isSimplePath_def by auto
                  qed
              qed
          qed
      qed
*)</span>
      
<span class="keyword1">lemma</span> isSPath_nt_parallel<span class="delimiter">:</span>
  <span class="keyword2">assumes</span> SP<span class="delimiter">:</span> <span class="string">&quot;isSimplePath s p t&quot;</span>
  <span class="keyword2">assumes</span> EIP<span class="delimiter">:</span> <span class="string">&quot;e&isin;set p&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;prod.swap e &notin; set p&quot;</span>
<span class="keyword1">proof</span> -  
  <span class="keyword1">from</span> SP <span class="keyword1">have</span> P<span class="delimiter">:</span> <span class="string">&quot;isPath s p t&quot;</span> <span class="keyword2">and</span> D<span class="delimiter">:</span> <span class="string">&quot;distinct (pathVertices_fwd s p)&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_fwd<span class="delimiter">)</span>

  <span class="keyword3">show</span> <span class="string">&quot;prod.swap e &notin; set p&quot;</span>  
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases e<span class="delimiter">)</span> <span class="keyword1">using</span> D EIP
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto 
      dest<span class="delimiter">!</span><span class="delimiter">:</span> pathVertices_edge<span class="delimiter">[</span>OF P<span class="delimiter">]</span> 
      elim<span class="delimiter">!</span><span class="delimiter">:</span> list_match_lel_lel list_Cons_eq_append_cases<span class="delimiter">)</span>

<span class="keyword1">qed</span>

<span class="keyword1">lemma</span> isSPath_nt_parallel_old<span class="delimiter">:</span> 
  <span class="string">&quot;isSimplePath u p v ==&gt; (&forall;(u, v) &isin; set p. (v, u) &notin; set p)&quot;</span>
  <span class="keyword1">using</span> isSPath_nt_parallel<span class="delimiter">[</span>of u p v<span class="delimiter">]</span> <span class="keyword1">by</span> auto

<span class="keyword1">corollary</span> isSPath_nt_parallel_pf<span class="delimiter">:</span> 
  <span class="string">&quot;isSimplePath s p t ==&gt; set p &cap; (set p)&macr; = {}&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto dest<span class="delimiter">:</span> isSPath_nt_parallel<span class="delimiter">)</span>
      
<span class="keyword1">lemma</span> isSPath_distinct<span class="delimiter">:</span> <span class="string">&quot;isSimplePath u p v ==&gt; distinct p&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto dest<span class="delimiter">!</span><span class="delimiter">:</span> not_distinct_decomp simp<span class="delimiter">:</span> split_path_simps<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">done</span></span>

<span class="keyword1">text</span> <span class="cartouche">&#8249;Edges adjacent to a node that does not lie on a path 
  are not contained in that path:&#8250;</span>  
<span class="keyword1">lemma</span> adjacent_edges_not_on_path<span class="delimiter">:</span>
  <span class="keyword2">assumes</span> PATH<span class="delimiter">:</span> <span class="string">&quot;isPath s p t&quot;</span>
  <span class="keyword2">assumes</span> VNV<span class="delimiter">:</span> <span class="string">&quot;v&notin;set (pathVertices_fwd s p)&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;adjacent v &cap; set p = {}&quot;</span> 
<span class="keyword1">proof</span> -
  <span class="keyword1">from</span> VNV <span class="keyword1">have</span> <span class="string">&quot;&forall;u. (u,v)&notin;set p &and; (v,u)&notin;set p&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto dest<span class="delimiter">:</span> pathVertices_edge<span class="delimiter">[</span>OF PATH<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword3">thus</span> <span class="string">&quot;adjacent v &cap; set p = {}&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> incoming_def outgoing_def adjacent_def<span class="delimiter">)</span>
<span class="keyword1">qed</span>    

<span class="keyword1">corollary</span> 
  <span class="keyword2">assumes</span> <span class="string">&quot;isPath s p t&quot;</span>
  <span class="keyword2">assumes</span> <span class="string">&quot;v&notin;set (pathVertices_fwd s p)&quot;</span>
  <span class="keyword2">shows</span> incoming_edges_not_on_path<span class="delimiter">:</span> <span class="string">&quot;incoming v &cap; set p = {}&quot;</span> 
    <span class="keyword2">and</span> outgoing_edges_not_on_path<span class="delimiter">:</span> <span class="string">&quot;outgoing v &cap; set p = {}&quot;</span>
  <span class="keyword1">using</span> adjacent_edges_not_on_path<span class="delimiter">[</span>OF assms<span class="delimiter">]</span>
  <span class="keyword1">unfolding</span> adjacent_def <span class="keyword1">by</span> auto

<span class="keyword1">text</span> <span class="cartouche">&#8249;A simple path over a vertex can be split at this vertex, 
  and there are exactly two edges on the path touching this vertex.&#8250;</span>  
<span class="keyword1">lemma</span> adjacent_edges_on_simple_path<span class="delimiter">:</span>
  <span class="keyword2">assumes</span> SPATH<span class="delimiter">:</span> <span class="string">&quot;isSimplePath s p t&quot;</span>
  <span class="keyword2">assumes</span> VNV<span class="delimiter">:</span> <span class="string">&quot;v&isin;set (pathVertices_fwd s p)&quot;</span> <span class="string">&quot;v&ne;s&quot;</span> <span class="string">&quot;v&ne;t&quot;</span>
  <span class="keyword2">obtains</span> p1 u w p2 <span class="keyword2">where</span> 
    <span class="string">&quot;p = p1@(u,v)#(v,w)#p2&quot;</span> 
    <span class="string">&quot;incoming v &cap; set p = {(u,v)}&quot;</span> 
    <span class="string">&quot;outgoing v &cap; set p = {(v,w)}&quot;</span>
<span class="keyword1">proof</span> -
  <span class="keyword1">from</span> SPATH <span class="keyword1">have</span> 
    PATH<span class="delimiter">:</span> <span class="string">&quot;isPath s p t&quot;</span> <span class="keyword2">and</span> 
    DIST<span class="delimiter">:</span> <span class="string">&quot;distinct (pathVertices_fwd s p)&quot;</span> 
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_def pathVertices_fwd<span class="delimiter">)</span>
  <span class="keyword1">from</span> split_path_at_vertex<span class="delimiter">[</span>OF VNV<span class="delimiter">(</span>1<span class="delimiter">)</span> PATH<span class="delimiter">]</span> <span class="keyword3">obtain</span> p1 p2 <span class="keyword2">where</span> 
    <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;p=p1@p2&quot;</span> <span class="keyword2">and</span> P1<span class="delimiter">:</span> <span class="string">&quot;isPath s p1 v&quot;</span> <span class="keyword2">and</span> P2<span class="delimiter">:</span> <span class="string">&quot;isPath v p2 t&quot;</span> <span class="keyword1">.</span>
  <span class="keyword1">from</span> <span class="cartouche">&#8249;v&ne;s&#8250;</span> P1 <span class="keyword3">obtain</span> p1&#39; u <span class="keyword2">where</span> 
    <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;p1=p1&#39;@[(u,v)]&quot;</span> <span class="keyword2">and</span> P1&#39;<span class="delimiter">:</span> <span class="string">&quot;isPath s p1&#39; u&quot;</span> <span class="keyword2">and</span> UV<span class="delimiter">:</span> <span class="string">&quot;(u,v)&isin;E&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>cases p1 rule<span class="delimiter">:</span> rev_cases<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> split_path_simps<span class="delimiter">)</span>
  <span class="keyword1">from</span> <span class="cartouche">&#8249;v&ne;t&#8250;</span> P2 <span class="keyword3">obtain</span> w p2&#39; <span class="keyword2">where</span> 
    <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;p2=(v,w)#p2&#39;&quot;</span> <span class="keyword2">and</span> VW<span class="delimiter">:</span> <span class="string">&quot;(v,w)&isin;E&quot;</span> <span class="keyword2">and</span> P2&#39;<span class="delimiter">:</span> <span class="string">&quot;isPath w p2&#39; t&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>cases p2<span class="delimiter">)</span> <span class="delimiter">(</span>auto<span class="delimiter">)</span>
  <span class="keyword3">show</span> thesis
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule that<span class="delimiter">[</span>of p1&#39; u w p2&#39;<span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> simp
    <span class="keyword1">using</span> 
      isSPath_sg_outgoing<span class="delimiter">[</span>OF SPATH<span class="delimiter">,</span> of v w<span class="delimiter">]</span> 
      isSPath_sg_incoming<span class="delimiter">[</span>OF SPATH<span class="delimiter">,</span> of u v<span class="delimiter">]</span>
      isPath_edgeset<span class="delimiter">[</span>OF PATH<span class="delimiter">]</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>fastforce simp<span class="delimiter">:</span> incoming_def outgoing_def<span class="delimiter">)</span><span class="delimiter">+</span>
    <span class="keyword1"><span class="improper">done</span></span>
<span class="keyword1">qed</span>

<span class="keyword1">subsubsection</span> <span class="cartouche">&#8249;Distance&#8250;</span>

<span class="keyword1">lemma</span> connected_by_dist<span class="delimiter">:</span> <span class="string">&quot;connected v v&#39; = (&exist;d. dist v d v&#39;)&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dist_def connected_def<span class="delimiter">)</span>

<span class="keyword1">lemma</span> isPath_distD<span class="delimiter">:</span> <span class="string">&quot;isPath u p v ==&gt; dist u (length p) v&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dist_def<span class="delimiter">)</span>

<span class="keyword1">lemma</span>
  <span class="keyword2">shows</span> connected_distI<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;dist v d v&#39; ==&gt; connected v v&#39;&quot;</span>
    <span class="comment">(*and connectedI_succ: &quot;connected v v&#39; ==&gt; (v&#39;,v&#39;&#39;) &isin; E ==&gt; connected v v&#39;&#39;&quot;*)</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dist_def connected_def intro<span class="delimiter">:</span> isPath_append_edge<span class="delimiter">)</span>
  
  
<span class="keyword1">lemma</span> min_distI2<span class="delimiter">:</span> 
  <span class="string">&quot;[|connected v v&#39;; !!d. [|dist v d v&#39;; !!d&#39;. dist v d&#39; v&#39; ==&gt; d &le; d&#39;|] ==&gt; Q d|] 
    ==&gt; Q (min_dist v v&#39;)&quot;</span>
  <span class="keyword1">unfolding</span> min_dist_def
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule LeastI2_wellorder<span class="delimiter">[</span><span class="keyword2">where</span> Q<span class="delimiter">=</span>Q <span class="keyword2">and</span> a<span class="delimiter">=</span><span class="string">&quot;SOME d. dist v d v&#39;&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> connected_by_dist intro<span class="delimiter">:</span> someI<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">done</span></span>

<span class="keyword1">lemma</span> min_distI_eq<span class="delimiter">:</span>
  <span class="string">&quot;[| dist v d v&#39;; !!d&#39;. dist v d&#39; v&#39; ==&gt; d &le; d&#39; |] ==&gt; min_dist v v&#39; = d&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>force intro<span class="delimiter">:</span> min_distI2 simp<span class="delimiter">:</span> connected_by_dist<span class="delimiter">)</span>

<span class="keyword1">text</span> <span class="verbatim">{* Two nodes are connected by a path of length @{text &quot;0&quot;}, 
  iff they are equal. *}</span>
<span class="keyword1">lemma</span> dist_z_iff<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;dist v 0 v&#39; &lt;-&gt; v&#39;=v&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dist_def<span class="delimiter">)</span>


<span class="keyword1">lemma</span> dist_z<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;dist v 0 v&quot;</span> <span class="keyword1">by</span> simp
<span class="keyword1">lemma</span> dist_suc<span class="delimiter">:</span> <span class="string">&quot;[|dist v d v&#39;; (v&#39;,v&#39;&#39;)&isin;E|] ==&gt; dist v (Suc d) v&#39;&#39;&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dist_def intro<span class="delimiter">:</span> isPath_append_edge<span class="delimiter">)</span>

<span class="keyword1">lemma</span> dist_cases<span class="delimiter">[</span>case_names dist_z dist_suc<span class="delimiter">,</span> consumes 1<span class="delimiter">,</span> cases pred<span class="delimiter">]</span><span class="delimiter">:</span>
  <span class="keyword2">assumes</span> <span class="string">&quot;dist v d v&#39;&quot;</span>
  <span class="keyword2">obtains</span> <span class="string">&quot;v=v&#39;&quot;</span> <span class="string">&quot;d=0&quot;</span>
   <span class="delimiter">|</span> vh dd <span class="keyword2">where</span> <span class="string">&quot;d=Suc dd&quot;</span> <span class="string">&quot;dist v dd vh&quot;</span> <span class="string">&quot;(vh,v&#39;)&isin;E&quot;</span>
  <span class="keyword1">using</span> assms 
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases d<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dist_def length_Suc_rev_conv isPath_append<span class="delimiter">)</span> 
  <span class="keyword1"><span class="improper">apply</span></span> force
  <span class="keyword1"><span class="improper">done</span></span>


<span class="keyword1">text</span> <span class="verbatim">{* The same holds for @{text &quot;min_dist&quot;}, i.e., 
  the shortest path between two nodes has length @{text &quot;0&quot;}, 
  iff these nodes are equal. *}</span>
<span class="keyword1">lemma</span> min_dist_z<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;min_dist v v = 0&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>rule min_distI2<span class="delimiter">)</span> auto

<span class="keyword1">lemma</span> min_dist_z_iff<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;connected v v&#39; ==&gt; min_dist v v&#39; = 0 &lt;-&gt; v&#39;=v&quot;</span> 
  <span class="keyword1">by</span> <span class="delimiter">(</span>rule min_distI2<span class="delimiter">)</span> <span class="delimiter">(</span>auto<span class="delimiter">)</span>
  
<span class="keyword1">lemma</span> min_dist_is_dist<span class="delimiter">:</span> <span class="string">&quot;connected v v&#39; ==&gt; dist v (min_dist v v&#39;) v&#39;&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto intro<span class="delimiter">:</span> min_distI2<span class="delimiter">)</span>
<span class="keyword1">lemma</span> min_dist_minD<span class="delimiter">:</span> <span class="string">&quot;dist v d v&#39; ==&gt; min_dist v v&#39; &le; d&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto intro<span class="delimiter">:</span> min_distI2<span class="delimiter">)</span>

<span class="keyword1">text</span> <span class="verbatim">{* We also provide introduction and destruction rules for the
  pattern @{text &quot;min_dist v v&#39; = Suc d&quot;}.
  *}</span>

<span class="keyword1">lemma</span> min_dist_succ<span class="delimiter">:</span> 
  <span class="string">&quot;[| connected v v&#39;; (v&#39;,v&#39;&#39;) &isin; E |] ==&gt; min_dist v v&#39;&#39; &le; Suc (min_dist v v&#39;) &quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule min_distI2<span class="delimiter">[</span><span class="keyword2">where</span> v&#39;<span class="delimiter">=</span>v&#39;<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto intro<span class="delimiter">!</span><span class="delimiter">:</span> min_dist_minD intro<span class="delimiter">:</span> dist_suc<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">done</span></span>

<span class="keyword1">lemma</span> min_dist_suc<span class="delimiter">:</span>
  <span class="keyword2">assumes</span> c<span class="delimiter">:</span> <span class="string">&quot;connected v v&#39;&quot;</span> <span class="string">&quot;min_dist v v&#39; = Suc d&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;&exist;v&#39;&#39;. connected v v&#39;&#39; &and; (v&#39;&#39;,v&#39;) &isin; E &and; min_dist v v&#39;&#39; = d&quot;</span>
<span class="keyword1">proof</span> -
  <span class="keyword1">from</span> min_dist_is_dist<span class="delimiter">[</span>OF c<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="keyword1">have</span> <span class="string">&quot;min_dist v v&#39; = Suc d --&gt; ?thesis&quot;</span>
  <span class="keyword1">proof</span> cases
    <span class="keyword3">case</span> <span class="delimiter">(</span>dist_suc v&#39;&#39; d&#39;<span class="delimiter">)</span> <span class="keyword1">then</span> <span class="keyword3">show</span> <span class="var">?thesis</span>
      <span class="keyword1">using</span> min_dist_succ<span class="delimiter">[</span>of v v&#39;&#39; v&#39;<span class="delimiter">]</span> min_dist_minD<span class="delimiter">[</span>of v d v&#39;&#39;<span class="delimiter">]</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> connected_distI<span class="delimiter">)</span>
  <span class="keyword1">qed</span> simp
  <span class="keyword1">with</span> c <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">by</span> simp
<span class="keyword1">qed</span>

<span class="keyword1">text</span> <span class="verbatim">{*
  If there is a node with a shortest path of length @{text &quot;d&quot;}, 
  then, for any @{text &quot;d&#39;&lt;d&quot;}, there is also a node with a shortest path
  of length @{text &quot;d&#39;&quot;}.
  *}</span>
<span class="keyword1">lemma</span> min_dist_less<span class="delimiter">:</span>
  <span class="keyword2">assumes</span> <span class="string">&quot;connected src v&quot;</span> <span class="string">&quot;min_dist src v = d&quot;</span> <span class="keyword2">and</span> <span class="string">&quot;d&#39; &lt; d&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;&exist;v&#39;. connected src v&#39; &and; min_dist src v&#39; = d&#39;&quot;</span>
  <span class="keyword1">using</span> assms
<span class="keyword1">proof</span> <span class="delimiter">(</span>induct d arbitrary<span class="delimiter">:</span> v<span class="delimiter">)</span>
  <span class="keyword3">case</span> <span class="delimiter">(</span>Suc d<span class="delimiter">)</span> <span class="keyword1">with</span> min_dist_suc<span class="delimiter">[</span>of src v<span class="delimiter">]</span> <span class="keyword3">show</span> <span class="var">?case</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>cases <span class="string">&quot;d&#39; = d&quot;</span><span class="delimiter">)</span> auto
<span class="keyword1">qed</span> auto

<span class="keyword1">text</span> <span class="verbatim">{*
  Lemma @{text &quot;min_dist_less&quot;} can be weakened to @{text &quot;d&#39;&le;d&quot;}.
  *}</span>

<span class="keyword1">corollary</span> min_dist_le<span class="delimiter">:</span>
  <span class="keyword2">assumes</span> c<span class="delimiter">:</span> <span class="string">&quot;connected src v&quot;</span> <span class="keyword2">and</span> d&#39;<span class="delimiter">:</span> <span class="string">&quot;d&#39; &le; min_dist src v&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;&exist;v&#39;. connected src v&#39; &and; min_dist src v&#39; = d&#39;&quot;</span>
  <span class="keyword1">using</span> min_dist_less<span class="delimiter">[</span>OF c<span class="delimiter">,</span> of <span class="string">&quot;min_dist src v&quot;</span> d&#39;<span class="delimiter">]</span> d&#39; c
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> le_less<span class="delimiter">)</span>


<span class="keyword1">lemma</span> dist_trans<span class="delimiter">[</span>trans<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;dist u d1 w ==&gt; dist w d2 v ==&gt; dist u (d1+d2) v&quot;</span>  
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>clarsimp simp<span class="delimiter">:</span> dist_def<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rename_tac p1 p2<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule_tac x<span class="delimiter">=</span><span class="string">&quot;p1@p2&quot;</span> <span class="keyword2">in</span> exI<span class="delimiter">)</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isPath_append<span class="delimiter">)</span>


<span class="keyword1">lemma</span> min_dist_split<span class="delimiter">:</span>
  <span class="keyword2">assumes</span> D1<span class="delimiter">:</span> <span class="string">&quot;dist u d1 w&quot;</span> <span class="keyword2">and</span> D2<span class="delimiter">:</span> <span class="string">&quot;dist w d2 v&quot;</span> <span class="keyword2">and</span> MIN<span class="delimiter">:</span> <span class="string">&quot;min_dist u v = d1+d2&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;min_dist u w = d1&quot;</span> <span class="string">&quot;min_dist w v = d2&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>metis assms ab_semigroup_add_class.add.commute add_le_cancel_left 
    dist_trans min_distI_eq min_dist_minD<span class="delimiter">)</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>metis assms add_le_cancel_left dist_trans min_distI_eq min_dist_minD<span class="delimiter">)</span>
  
<span class="keyword1">lemma</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Manual proof&#8250;</span>
  <span class="keyword2">assumes</span> D1<span class="delimiter">:</span> <span class="string">&quot;dist u d1 w&quot;</span> <span class="keyword2">and</span> D2<span class="delimiter">:</span> <span class="string">&quot;dist w d2 v&quot;</span> <span class="keyword2">and</span> MIN<span class="delimiter">:</span> <span class="string">&quot;min_dist u v = d1+d2&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;min_dist u w = d1&quot;</span> <span class="string">&quot;min_dist w v = d2&quot;</span>
<span class="keyword1">proof</span> -
  <span class="keyword1">from</span> min_dist_minD<span class="delimiter">[</span>OF <span class="cartouche">&#8249;dist u d1 w&#8250;</span><span class="delimiter">]</span> <span class="keyword1">have</span> <span class="string">&quot;min_dist u w &le; d1&quot;</span> <span class="keyword1">.</span>
  <span class="keyword1">moreover</span> <span class="keyword1">{</span>
    <span class="keyword1">have</span> <span class="string">&quot;dist u (min_dist u w) w&quot;</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule min_dist_is_dist<span class="delimiter">)</span>
      <span class="keyword1">using</span> D1 <span class="keyword1">by</span> auto
    <span class="keyword1">also</span> <span class="keyword1">note</span> D2
    <span class="keyword1">finally</span> <span class="keyword1">have</span> <span class="string">&quot;dist u (min_dist u w + d2) v&quot;</span> <span class="keyword1">.</span>
    <span class="keyword1">moreover</span> <span class="keyword3">assume</span> <span class="string">&quot;min_dist u w &lt; d1&quot;</span>
    <span class="keyword1">moreover</span> <span class="keyword1">note</span> MIN
    <span class="keyword1">ultimately</span> <span class="keyword1">have</span> False <span class="keyword1">by</span> <span class="delimiter">(</span>auto dest<span class="delimiter">:</span> min_dist_minD<span class="delimiter">)</span>
  <span class="keyword1">}</span> <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="string">&quot;min_dist u w = d1&quot;</span>
    <span class="keyword1">unfolding</span> not_less<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="keyword1">using</span> nat_neq_iff <span class="keyword1">by</span> blast

  <span class="keyword1">from</span> min_dist_minD<span class="delimiter">[</span>OF <span class="cartouche">&#8249;dist w d2 v&#8250;</span><span class="delimiter">]</span> <span class="keyword1">have</span> <span class="string">&quot;min_dist w v &le; d2&quot;</span> <span class="keyword1">.</span>
  <span class="keyword1">moreover</span> <span class="keyword1">{</span>
    <span class="keyword1">note</span> D1
    <span class="keyword1">also</span> <span class="keyword1">have</span> <span class="string">&quot;dist w (min_dist w v) v&quot;</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule min_dist_is_dist<span class="delimiter">)</span>
      <span class="keyword1">using</span> D2 <span class="keyword1">by</span> auto
    <span class="keyword1">finally</span> <span class="keyword1">have</span> <span class="string">&quot;dist u (d1 + min_dist w v) v&quot;</span> <span class="keyword1">.</span>
    <span class="keyword1">moreover</span> <span class="keyword3">assume</span> <span class="string">&quot;min_dist w v &lt; d2&quot;</span>
    <span class="keyword1">moreover</span> <span class="keyword1">note</span> MIN
    <span class="keyword1">ultimately</span> <span class="keyword1">have</span> False <span class="keyword1">by</span> <span class="delimiter">(</span>auto dest<span class="delimiter">:</span> min_dist_minD<span class="delimiter">)</span>
  <span class="keyword1">}</span> <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="string">&quot;min_dist w v = d2&quot;</span>
    <span class="keyword1">unfolding</span> not_less<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="keyword1">using</span> nat_neq_iff <span class="keyword1">by</span> blast
<span class="keyword1">qed</span>    

<span class="keyword1">subsubsection</span> <span class="cartouche">&#8249;Shortest Paths&#8250;</span>

<span class="keyword1">text</span> <span class="cartouche">&#8249;Characterization of shortest path in terms of minimum distance&#8250;</span>
<span class="keyword1">lemma</span> isShortestPath_min_dist_def<span class="delimiter">:</span> 
  <span class="string">&quot;isShortestPath u p v &lt;-&gt; isPath u p v &and; length p = min_dist u v&quot;</span>  
  <span class="keyword1">unfolding</span> isShortestPath_def min_dist_def dist_def
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule iffI<span class="delimiter">;</span> clarsimp<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule Least_equality<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">;</span> auto<span class="delimiter">;</span> fail<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule Least_le<span class="delimiter">;</span> auto<span class="delimiter">;</span> fail<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">done</span></span>      

<span class="keyword1">lemma</span> obtain_shortest_path<span class="delimiter">:</span> 
  <span class="keyword2">assumes</span> CONN<span class="delimiter">:</span> <span class="string">&quot;connected u v&quot;</span>  
  <span class="keyword2">obtains</span> p <span class="keyword2">where</span> <span class="string">&quot;isShortestPath u p v&quot;</span>
  <span class="keyword1">using</span> min_dist_is_dist<span class="delimiter">[</span>OF CONN<span class="delimiter">]</span>
  <span class="keyword1">unfolding</span> dist_def isShortestPath_min_dist_def
  <span class="keyword1">by</span> blast

<span class="keyword1">lemma</span> shortestPath_is_simple<span class="delimiter">:</span>
  <span class="keyword2">assumes</span> <span class="string">&quot;isShortestPath s p t&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;isSimplePath s p t&quot;</span>
<span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
  <span class="keyword1">from</span> assms <span class="keyword1">have</span> PATH<span class="delimiter">:</span> <span class="string">&quot;isPath s p t&quot;</span> 
    <span class="keyword2">and</span> SHORTEST<span class="delimiter">:</span> <span class="string">&quot;&forall;p&#39;. isPath s p&#39; t --&gt; length p &le; length p&#39;&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isShortestPath_def<span class="delimiter">)</span>

  <span class="keyword3">assume</span> <span class="string">&quot;&not;isSimplePath s p t&quot;</span>  
  <span class="keyword1">with</span> PATH <span class="keyword1">have</span> <span class="string">&quot;&not;distinct (pathVertices_fwd s p)&quot;</span> 
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isSimplePath_fwd<span class="delimiter">)</span>

  <span class="keyword1">then</span> <span class="keyword3">obtain</span> pv1 u pv2 pv3 <span class="keyword2">where</span> PV<span class="delimiter">:</span> <span class="string">&quot;pathVertices_fwd s p = pv1@u#pv2@u#pv3&quot;</span> 
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto dest<span class="delimiter">:</span> not_distinct_decomp<span class="delimiter">)</span>

  <span class="keyword1">from</span> split_path_at_vertex_complete<span class="delimiter">[</span>OF PATH PV<span class="delimiter">]</span> <span class="keyword3">obtain</span> p1 p23 <span class="keyword2">where</span>
    <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;p=p1@p23&quot;</span> <span class="keyword2">and</span> 
      P1<span class="delimiter">:</span> <span class="string">&quot;isPath s p1 u&quot;</span> <span class="string">&quot;pathVertices_fwd s p1 = pv1@[u]&quot;</span> <span class="keyword2">and</span>
      P23<span class="delimiter">:</span> <span class="string">&quot;isPath u p23 t&quot;</span> <span class="string">&quot;pathVertices_fwd u p23 = (u#pv2)@u#pv3&quot;</span>
      <span class="keyword1">by</span> auto
      
  <span class="keyword1">from</span> split_path_at_vertex_complete<span class="delimiter">[</span>OF P23<span class="delimiter">]</span> <span class="keyword3">obtain</span> p2 p3 <span class="keyword2">where</span>
    <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;p23 = p2@p3&quot;</span> <span class="keyword2">and</span>
    P2<span class="delimiter">:</span> <span class="string">&quot;isPath u p2 u&quot;</span> <span class="string">&quot;pathVertices_fwd u p2 = u#pv2@[u]&quot;</span> <span class="keyword2">and</span>
    P3<span class="delimiter">:</span> <span class="string">&quot;isPath u p3 t&quot;</span> <span class="string">&quot;pathVertices_fwd u p3 = u#pv3&quot;</span>
    <span class="keyword1">by</span> auto

  <span class="keyword1">from</span> P1<span class="delimiter">(</span>1<span class="delimiter">)</span> P3<span class="delimiter">(</span>1<span class="delimiter">)</span> <span class="keyword1">have</span> SHORTER_PATH<span class="delimiter">:</span> <span class="string">&quot;isPath s (p1@p3) t&quot;</span> 
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isPath_append<span class="delimiter">)</span>
  
  <span class="keyword1">from</span> P2 <span class="keyword1">have</span> <span class="string">&quot;p2&ne;[]&quot;</span> <span class="keyword1">by</span> auto
  <span class="keyword1">hence</span> LESS<span class="delimiter">:</span> <span class="string">&quot;length (p1@p3) &lt; length p&quot;</span> <span class="keyword1">by</span> auto
  <span class="keyword1">with</span> SHORTER_PATH SHORTEST <span class="keyword3">show</span> False <span class="keyword1">by</span> auto
<span class="keyword1">qed</span>    

<span class="keyword1">text</span> <span class="cartouche">&#8249;We provide yet another characterization of shortest paths:&#8250;</span>
<span class="keyword1">lemma</span> isShortestPath_alt<span class="delimiter">:</span> 
  <span class="string">&quot;isShortestPath u p v &lt;-&gt; isSimplePath u p v &and; length p = min_dist u v&quot;</span>
  <span class="keyword1">using</span> shortestPath_is_simple isShortestPath_min_dist_def
  <span class="keyword1">unfolding</span> isSimplePath_def <span class="keyword1">by</span> auto

<span class="keyword1">lemma</span> shortestPath_is_path<span class="delimiter">:</span> <span class="string">&quot;isShortestPath u p v ==&gt; isPath u p v&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isShortestPath_def<span class="delimiter">)</span>
  
<span class="keyword1">lemma</span> split_shortest_path<span class="delimiter">:</span> <span class="string">&quot;isShortestPath u (p1@p2) v 
  ==&gt; (&exist;w. isShortestPath u p1 w &and; isShortestPath w p2 v)&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isShortestPath_min_dist_def isPath_append<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule exI<span class="delimiter">;</span> intro conjI<span class="delimiter">;</span> assumption<span class="delimiter">?</span><span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>drule isPath_distD<span class="delimiter">)</span><span class="delimiter">+</span> <span class="keyword1">using</span> min_dist_split <span class="keyword1"><span class="improper">apply</span></span> auto <span class="delimiter">[</span><span class="delimiter">]</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>drule isPath_distD<span class="delimiter">)</span><span class="delimiter">+</span> <span class="keyword1">using</span> min_dist_split <span class="keyword1"><span class="improper">apply</span></span> auto <span class="delimiter">[</span><span class="delimiter">]</span>
  <span class="keyword1"><span class="improper">done</span></span>

<span class="keyword1">text</span> <span class="cartouche">&#8249;Edges in a shortest path connect nodes with increasing 
  minimum distance from the source&#8250;</span>
<span class="keyword1">lemma</span> isShortestPath_level_edge<span class="delimiter">:</span>  
  <span class="keyword2">assumes</span> SP<span class="delimiter">:</span> <span class="string">&quot;isShortestPath s p t&quot;</span> 
  <span class="keyword2">assumes</span> EIP<span class="delimiter">:</span> <span class="string">&quot;(u,v)&isin;set p&quot;</span>
  <span class="keyword2">shows</span> 
    <span class="string">&quot;connected s u&quot;</span> <span class="string">&quot;connected u v&quot;</span> <span class="string">&quot;connected v t&quot;</span> <span class="keyword2">and</span>
    <span class="string">&quot;min_dist s v = min_dist s u + 1&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="var">?G1</span><span class="delimiter">)</span> <span class="keyword2">and</span>
    <span class="string">&quot;min_dist u t = 1 + min_dist v t&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="var">?G2</span><span class="delimiter">)</span> <span class="keyword2">and</span>
    <span class="string">&quot;min_dist s t = min_dist s u + 1 + min_dist v t&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="var">?G3</span><span class="delimiter">)</span> 
<span class="keyword1">proof</span> -  
  <span class="delimiter">--</span> <span class="cartouche">&#8249;Split the original path at the edge&#8250;</span>
  <span class="keyword1">from</span> EIP <span class="keyword3">obtain</span> p1 p2 <span class="keyword2">where</span> <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;p=p1@(u,v)#p2&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> in_set_conv_decomp<span class="delimiter">)</span>
  <span class="keyword1">from</span> <span class="cartouche">&#8249;isShortestPath s p t&#8250;</span> <span class="keyword1">have</span> 
    MIN<span class="delimiter">:</span> <span class="string">&quot;min_dist s t = length p&quot;</span> <span class="keyword2">and</span> 
      P<span class="delimiter">:</span> <span class="string">&quot;isPath s p t&quot;</span> <span class="keyword2">and</span> 
     DV<span class="delimiter">:</span> <span class="string">&quot;distinct (pathVertices s p)&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isShortestPath_alt isSimplePath_def<span class="delimiter">)</span>
  <span class="keyword1">from</span> P <span class="keyword1">have</span> DISTS<span class="delimiter">:</span> <span class="string">&quot;dist s (length p1) u&quot;</span> <span class="string">&quot;dist u 1 v&quot;</span> <span class="string">&quot;dist v (length p2) t&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isPath_append dist_def intro<span class="delimiter">:</span> exI<span class="delimiter">[</span><span class="keyword2">where</span> x<span class="delimiter">=</span><span class="string">&quot;[(u,v)]&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>
    
  <span class="keyword1">from</span> DISTS <span class="keyword3">show</span> <span class="string">&quot;connected s u&quot;</span> <span class="string">&quot;connected u v&quot;</span> <span class="string">&quot;connected v t&quot;</span> <span class="keyword1">by</span> auto

  <span class="delimiter">--</span> <span class="cartouche">&#8249;Express the minimum distances in terms of the split original path&#8250;</span>  
  <span class="keyword1">from</span> MIN <span class="keyword1">have</span> MIN&#39;<span class="delimiter">:</span> <span class="string">&quot;min_dist s t = length p1 + 1 + length p2&quot;</span> <span class="keyword1">by</span> auto
  
  <span class="keyword1">from</span> min_dist_split<span class="delimiter">[</span>OF dist_trans<span class="delimiter">[</span>OF DISTS<span class="delimiter">(</span>1<span class="delimiter">,</span>2<span class="delimiter">)</span><span class="delimiter">]</span> DISTS<span class="delimiter">(</span>3<span class="delimiter">)</span> MIN&#39;<span class="delimiter">]</span> <span class="keyword1">have</span>
      MDSV<span class="delimiter">:</span> <span class="string">&quot;min_dist s v = length p1 + 1&quot;</span> <span class="keyword2">and</span> 
    <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;length p2 = min_dist v t&quot;</span> 
    <span class="keyword1">by</span> simp_all
  <span class="keyword1">from</span> min_dist_split<span class="delimiter">[</span>OF DISTS<span class="delimiter">(</span>1<span class="delimiter">)</span> dist_trans<span class="delimiter">[</span>OF DISTS<span class="delimiter">(</span>2<span class="delimiter">,</span>3<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span> MIN&#39; <span class="keyword1">have</span>
      MDUT<span class="delimiter">:</span> <span class="string">&quot;min_dist u t = 1 + length p2&quot;</span> <span class="keyword2">and</span> 
    <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;length p1 = min_dist s u&quot;</span> 
    <span class="keyword1">by</span> simp_all

  <span class="keyword1">from</span> MDSV MDUT MIN&#39; <span class="keyword3">show</span> <span class="var">?G1</span> <span class="var">?G2</span> <span class="var">?G3</span> <span class="keyword1">by</span> auto  
<span class="keyword1">qed</span>  

<span class="keyword2">end</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Graph&#8250;</span>

<span class="keyword1">context</span> Finite_Graph <span class="keyword2">begin</span>

<span class="keyword1">text</span> <span class="cartouche">&#8249;In a finite graph, the length of a shortest path is less 
  than the number of nodes&#8250;</span>  
<span class="keyword1">lemma</span> isShortestPath_length_less_V<span class="delimiter">:</span>   
  <span class="keyword2">assumes</span> SV<span class="delimiter">:</span> <span class="string">&quot;s&isin;V&quot;</span>
  <span class="keyword2">assumes</span> PATH<span class="delimiter">:</span> <span class="string">&quot;isShortestPath s p t&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;length p &lt; card V&quot;</span>
  <span class="keyword1">using</span> simplePath_length_less_V<span class="delimiter">[</span>OF SV<span class="delimiter">]</span>
  <span class="keyword1">using</span> shortestPath_is_simple<span class="delimiter">[</span>OF PATH<span class="delimiter">]</span> <span class="keyword1">.</span>

<span class="keyword1">corollary</span> min_dist_less_V<span class="delimiter">:</span>
  <span class="keyword2">assumes</span> SV<span class="delimiter">:</span> <span class="string">&quot;s&isin;V&quot;</span>
  <span class="keyword2">assumes</span> CONN<span class="delimiter">:</span> <span class="string">&quot;connected s t&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;min_dist s t &lt; card V&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule obtain_shortest_path<span class="delimiter">[</span>OF CONN<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>frule isShortestPath_length_less_V<span class="delimiter">[</span>OF SV<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword1">unfolding</span> isShortestPath_min_dist_def <span class="keyword1">by</span> auto

<span class="keyword2">end</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Finite_Graph&#8250;</span>

<span class="keyword2">end</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Theory&#8250;</span>
</pre>

</div>
</body>
</html>
