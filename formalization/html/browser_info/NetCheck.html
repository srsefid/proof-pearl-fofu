<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory NetCheck (Isabelle2015: May 2015)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory NetCheck</h1>

<span class="command">theory</span> <span class="name">NetCheck</span><br/>
<span class="keyword">imports</span> <a href="Network.html"><span class="name">Network</span></a> <a href="Graph_Impl.html"><span class="name">Graph_Impl</span></a> <a href="../Edka_Base/Reachable_Nodes.html"><span class="name">Reachable_Nodes</span></a><br/>

</div>
<div class="source">
<pre><span class="keyword1">theory</span> NetCheck
<span class="keyword2">imports</span> 
  Fofu_Impl_Base
   Network 
  <span class="string">&quot;Graph_Impl&quot;</span>
  <span class="string">&quot;cava/DFS_Framework/Examples/Reachable_Nodes&quot;</span>
<span class="keyword2">begin</span>

  <span class="keyword1">declare</span> <span class="delimiter">[</span><span class="delimiter">[</span>coercion_delete int<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword1">declare</span> <span class="delimiter">[</span><span class="delimiter">[</span>coercion_delete <span class="string">&quot;real::nat=&gt;real&quot;</span><span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="keyword1">type_synonym</span> edge_list <span class="delimiter">=</span> <span class="string">&quot;(node &times; node &times; capacity_impl) list&quot;</span>

  <span class="keyword1">definition</span> ln_invar <span class="delimiter">::</span> <span class="string">&quot;edge_list =&gt; bool&quot;</span> <span class="keyword2">where</span> 
    <span class="string">&quot;ln_invar el &equiv; 
      distinct (map (&lambda;(u, v, _). (u,v)) el) 
    &and; (&forall;(u,v,c)&isin;set el. c&gt;0) 
    &quot;</span>
  <span class="keyword1">definition</span> ln_&alpha; <span class="delimiter">::</span> <span class="string">&quot;edge_list =&gt; capacity_impl graph&quot;</span> <span class="keyword2">where</span> 
    <span class="string">&quot;ln_&alpha; el &equiv; &lambda;(u,v). 
      if &exist;c. (u, v, c) &isin; set el &and; c &ne; 0 then 
        SOME c. (u, v, c) &isin; set el &and; c &ne; 0
      else 0&quot;</span>

  <span class="keyword1">definition</span> <span class="string">&quot;ln_rel &equiv; br ln_&alpha; ln_invar&quot;</span>
  
  <span class="keyword1">lemma</span> ln_equivalence<span class="delimiter">:</span> <span class="string">&quot;(el, c&#39;) &isin; ln_rel &lt;-&gt; ln_invar el &and; c&#39; = ln_&alpha; el&quot;</span>
    <span class="keyword1">unfolding</span> ln_rel_def br_def <span class="keyword1">by</span> auto 

  <span class="comment">(*export_code ln_invar in SML*)</span>

  <span class="keyword1">definition</span> ln_N <span class="delimiter">::</span> <span class="string">&quot;(node&times;node&times;_) list =&gt; nat&quot;</span> <span class="keyword2">where</span>
    <span class="string">&quot;ln_N el &equiv; Max ((fst`set el) &cup; ((fst o snd)`set el)) + 1&quot;</span>

  <span class="keyword1">lemma</span> ln_&alpha;_imp_in_set<span class="delimiter">:</span> <span class="string">&quot;[|ln_&alpha; el (u,v)&ne;(0)|] ==&gt; (u,v,ln_&alpha; el (u,v))&isin;set el&quot;</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> ln_&alpha;_def split<span class="delimiter">:</span> split_if_asm<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>mono_tags<span class="delimiter">,</span> lifting<span class="delimiter">)</span> someI_ex<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">done</span></span>

  <span class="keyword1">lemma</span> ln_N_correct<span class="delimiter">:</span> <span class="string">&quot;Graph.V (ln_&alpha; el) &sube; {0..&lt;ln_N el}&quot;</span>  
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>clarsimp simp<span class="delimiter">:</span> Graph.V_def Graph.E_def<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>safe dest<span class="delimiter">!</span><span class="delimiter">:</span> ln_&alpha;_imp_in_set<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>fastforce simp<span class="delimiter">:</span> ln_N_def less_Suc_eq_le intro<span class="delimiter">:</span> Max_ge<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>force simp<span class="delimiter">:</span> ln_N_def less_Suc_eq_le intro<span class="delimiter">:</span> Max_ge<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">done</span></span>



  <span class="keyword1">record</span> pre_network <span class="delimiter">=</span>
    pn_c <span class="delimiter">::</span> <span class="string">&quot;capacity_impl graph&quot;</span>
    pn_V <span class="delimiter">::</span> <span class="string">&quot;nat set&quot;</span>
    pn_succ <span class="delimiter">::</span> <span class="string">&quot;nat =&gt; nat list&quot;</span>
    pn_pred <span class="delimiter">::</span> <span class="string">&quot;nat =&gt; nat list&quot;</span>
    pn_psucc <span class="delimiter">::</span> <span class="string">&quot;nat =&gt; nat list&quot;</span>
    pn_s_node <span class="delimiter">::</span> bool
    pn_t_node <span class="delimiter">::</span> bool

  <span class="keyword1">fun</span> read <span class="delimiter">::</span> <span class="string">&quot;edge_list =&gt; nat =&gt; nat =&gt;
    pre_network option&quot;</span> <span class="keyword2">where</span>
    <span class="string">&quot;read [] _ _ = Some (|
      pn_c = (&lambda; _. 0), 
      pn_V = {}, 
      pn_succ = (&lambda; _. []),
      pn_pred = (&lambda; _. []),
      pn_psucc = (&lambda; _. []), 
      pn_s_node = False, 
      pn_t_node = False
    |)),&quot;</span>
  <span class="delimiter">|</span> <span class="string">&quot;read ((u, v, c) # es) s t = ((case (read es s t) of 
      Some x =&gt;
        (if (pn_c x) (u, v) = 0 &and; (pn_c x) (v, u) = 0 &and; c &gt; 0 then
          (if u = v &or; v = s &or; u = t then
            None
          else
            Some (x(| 
              pn_c := (pn_c x) ((u, v) := c),
              pn_V := insert u (insert v (pn_V x)),
              pn_succ := (pn_succ x) (u := v # ((pn_succ x) u)),
              pn_pred := (pn_pred x) (v := u # ((pn_pred x) v)),
              pn_psucc := ((pn_psucc x) (u := v # (pn_psucc x) u)) (v := u # (pn_psucc x) v),
              pn_s_node := pn_s_node x &or; u = s,
              pn_t_node := pn_t_node x &or; v = t
            |)),))
        else
          None)
    | None =&gt; None))&quot;</span>
      
  <span class="keyword1">lemma</span> read_correct1<span class="delimiter">:</span> <span class="string">&quot;read es s t = Some (|pn_c = c, pn_V = V, pn_succ = succ, 
    pn_pred = pred , pn_psucc = psucc, pn_s_node = s_n, pn_t_node = t_n|)), ==&gt; 
    (es, c) &isin; ln_rel &and; Graph.V c = V &and; finite V &and; 
    (s_n --&gt; s &isin; V) &and; (t_n --&gt; t &isin; V) &and; (&not;s_n --&gt; s &notin; V) &and; (&not;t_n --&gt; t &notin; V) &and;
    (&forall;u v. c (u,v) &ge; 0) &and;
    (&forall;u. c(u, u) = 0) &and; (&forall;u. c (u, s) = 0) &and; (&forall;u. c (t, u) = 0) &and;
    (&forall;u v. c (u, v) &ne; 0 --&gt; c (v, u) = 0) &and; 
    (&forall;u. set (succ u) = Graph.E c``{u} &and; distinct (succ u)) &and; 
    (&forall;u. set (pred u) = (Graph.E c)&macr;``{u} &and; distinct (pred u)) &and; 
    (&forall;u. set (psucc u) = Graph.E c``{u} &cup; (Graph.E c)&macr;``{u} &and; distinct (psucc u))&quot;</span>
    <span class="keyword1">proof</span> <span class="delimiter">(</span>induction es arbitrary<span class="delimiter">:</span> c V succ pred psucc s_n t_n<span class="delimiter">)</span>
      <span class="keyword3">case</span> Nil
        <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">unfolding</span> Graph.V_def Graph.E_def ln_rel_def br_def ln_&alpha;_def ln_invar_def <span class="keyword1">by</span> auto
    <span class="keyword1">next</span>
      <span class="keyword3">case</span> <span class="delimiter">(</span>Cons e es<span class="delimiter">)</span>
        <span class="keyword3">obtain</span> u1 v1 c1 <span class="keyword2">where</span> obt1<span class="delimiter">:</span> <span class="string">&quot;e = (u1, v1, c1)&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>meson prod_cases3<span class="delimiter">)</span>
        <span class="keyword3">obtain</span> x <span class="keyword2">where</span> obt2<span class="delimiter">:</span> <span class="string">&quot;read es s t = Some x&quot;</span>
          <span class="keyword1">using</span> Cons.prems obt1 <span class="keyword1">by</span> <span class="delimiter">(</span>auto split<span class="delimiter">:</span> option.splits<span class="delimiter">)</span>
        <span class="keyword1">have</span> fct0<span class="delimiter">:</span> <span class="string">&quot;(pn_c x) (u1, v1) = 0 &and; (pn_c x) (v1, u1) = 0 &and; c1 &gt; 0&quot;</span>
          <span class="keyword1">using</span> Cons.prems obt1 obt2 <span class="keyword1">by</span> <span class="delimiter">(</span>auto split<span class="delimiter">:</span> option.splits if_splits<span class="delimiter">)</span>
        <span class="keyword1">have</span> fct1<span class="delimiter">:</span> <span class="string">&quot;c1 &gt; 0 &and; u1 &ne; v1 &and; v1 &ne; s &and; u1 &ne; t&quot;</span>
          <span class="keyword1">using</span> Cons.prems obt1 obt2 <span class="keyword1">by</span> <span class="delimiter">(</span>auto split<span class="delimiter">:</span> option.splits if_splits<span class="delimiter">)</span>
        
        <span class="keyword3">obtain</span> c&#39; V&#39; sc&#39; ps&#39; pd&#39; s_n&#39; t_n&#39; <span class="keyword2">where</span> obt3<span class="delimiter">:</span> <span class="string">&quot;x = (|pn_c = c&#39;, pn_V = V&#39;,
          pn_succ = sc&#39;, pn_pred = pd&#39;,  pn_psucc = ps&#39;, pn_s_node = s_n&#39;, pn_t_node = t_n&#39;|)),&quot;</span> 
          <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases x<span class="delimiter">)</span> <span class="keyword1">by</span> auto
        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;read es s t = Some (|pn_c = c&#39;, pn_V = V&#39;, pn_succ = sc&#39;, pn_pred = pd&#39;,
          pn_psucc = ps&#39;, pn_s_node = s_n&#39;, pn_t_node = t_n&#39;|)),&quot;</span> <span class="keyword1">using</span> obt2 <span class="keyword1">by</span> blast
        <span class="keyword1">note</span> fct <span class="delimiter">=</span> Cons.IH<span class="delimiter">[</span>OF this<span class="delimiter">]</span>
        <span class="keyword1">have</span> fct2<span class="delimiter">:</span> <span class="string">&quot;s_n = (s_n&#39; &or; u1 = s)&quot;</span> 
          <span class="keyword1">using</span> fct0 fct1 Cons.prems obt1 obt2 obt3 <span class="keyword1">by</span> simp
        <span class="keyword1">have</span> fct3<span class="delimiter">:</span> <span class="string">&quot;t_n = (t_n&#39; &or; v1 = t)&quot;</span>
          <span class="keyword1">using</span> fct0 fct1 Cons.prems obt1 obt2 obt3 <span class="keyword1">by</span> simp
        <span class="keyword1">have</span> fct4<span class="delimiter">:</span> <span class="string">&quot;c = c&#39; ((u1, v1) := c1)&quot;</span>
          <span class="keyword1">using</span> fct0 fct1 Cons.prems obt1 obt2 obt3 <span class="keyword1">by</span> simp
        <span class="keyword1">have</span> fct5<span class="delimiter">:</span> <span class="string">&quot;V = V&#39; &cup; {u1, v1}&quot;</span> 
          <span class="keyword1">using</span> fct0 fct1 Cons.prems obt1 obt2 obt3 <span class="keyword1">by</span> simp
        <span class="keyword1">have</span> fct6<span class="delimiter">:</span> <span class="string">&quot;succ = sc&#39; (u1 := v1 # sc&#39; u1)&quot;</span> 
          <span class="keyword1">using</span> fct0 fct1 Cons.prems obt1 obt2 obt3 <span class="keyword1">by</span> simp
        <span class="keyword1">have</span> fct7<span class="delimiter">:</span> <span class="string">&quot;pred = pd&#39; (v1 := u1 # pd&#39; v1)&quot;</span>
          <span class="keyword1">using</span> fct0 fct1 Cons.prems obt1 obt2 obt3 <span class="keyword1">by</span> simp
        <span class="keyword1">have</span> fct8<span class="delimiter">:</span> <span class="string">&quot;psucc = (ps&#39; (u1 := v1 # ps&#39; u1)) (v1 := u1 # ps&#39; v1)&quot;</span>
          <span class="keyword1">using</span> fct0 fct1 Cons.prems obt1 obt2 obt3 <span class="keyword1">by</span> simp
        
          
        <span class="keyword1">{</span>
          <span class="keyword1">have</span> <span class="string">&quot;(es, c&#39;) &isin; ln_rel&quot;</span> <span class="keyword1">using</span> fct <span class="keyword1">by</span> blast
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;ln_invar es&quot;</span> <span class="keyword2">and</span> <span class="string">&quot;c&#39; = ln_&alpha; es&quot;</span> <span class="keyword1">unfolding</span> ln_rel_def br_def <span class="keyword1">by</span> auto
          
          <span class="keyword1">have</span> <span class="string">&quot;ln_invar (e # es)&quot;</span>
            <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
              <span class="keyword3">assume</span> <span class="string">&quot;&not; ?thesis&quot;</span>
              <span class="keyword1">have</span> f1<span class="delimiter">:</span> <span class="string">&quot;&forall;(u, v, c) &isin; set (e # es). c&gt;0&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`ln_invar es`</span> fct0 obt1
                <span class="keyword1">unfolding</span> ln_invar_def <span class="keyword1">by</span> auto
              <span class="keyword1">have</span> f2<span class="delimiter">:</span> <span class="string">&quot;distinct (map (&lambda;(u, v, _). (u,v)) es)&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`ln_invar es`</span>
                <span class="keyword1">unfolding</span> ln_invar_def <span class="keyword1">by</span> auto
              
              <span class="keyword1">have</span> <span class="string">&quot;&exist;c1&#39;. (u1, v1, c1&#39;) &isin; (set es) &and; c1&#39; &ne; 0&quot;</span>
                <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
                  <span class="keyword3">assume</span> <span class="string">&quot;&not; ?thesis&quot;</span>
                  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&forall;c1&#39;. (u1, v1, c1&#39;) &notin; (set es) &or; c1&#39; = 0&quot;</span> <span class="keyword1">by</span> blast
                  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;distinct (map (&lambda;(u, v, _). (u,v)) (e # es))&quot;</span> <span class="keyword1">using</span> obt1 f2 f1 <span class="keyword1">by</span> auto
                  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;ln_invar (e # es)&quot;</span> <span class="keyword1">unfolding</span> ln_invar_def <span class="keyword1">using</span> f1 <span class="keyword1">by</span> simp
                  <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`&not; ln_invar (e # es)`</span> <span class="keyword1">by</span> blast
                <span class="keyword1">qed</span>
              <span class="keyword1">then</span> <span class="keyword3">obtain</span> c1&#39; <span class="keyword2">where</span> <span class="string">&quot;(u1, v1, c1&#39;) &isin; (set es) &and; c1&#39; &ne; 0&quot;</span> <span class="keyword1">by</span> blast
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;c&#39; (u1, v1) = (SOME c. (u1, v1, c) &isin; set es &and; c &ne; 0)&quot;</span>
                <span class="keyword1">using</span> <span class="alt_string">`c&#39; = ln_&alpha; es`</span> <span class="keyword1">unfolding</span> ln_&alpha;_def <span class="keyword1">by</span> auto
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;c&#39; (u1, v1) &ne; 0&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`(u1, v1, c1&#39;) &isin; (set es) &and; c1&#39; &ne; 0`</span> f1
                <span class="keyword1">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>mono_tags<span class="delimiter">,</span> lifting<span class="delimiter">)</span> tfl_some<span class="delimiter">)</span>
              <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> fct0 obt3 <span class="keyword1">by</span> simp
            <span class="keyword1">qed</span>
          <span class="keyword1">moreover</span> <span class="keyword1">{</span>
            <span class="keyword1">{</span>
              <span class="keyword3">fix</span> a
              <span class="keyword1">have</span> f1<span class="delimiter">:</span> <span class="string">&quot;distinct (map (&lambda;(u, v, _). (u,v)) (e # es))&quot;</span>
                <span class="keyword2">and</span> f2<span class="delimiter">:</span> <span class="string">&quot;&forall;u v. (u, v, 0) &notin; set (e # es)&quot;</span>
                <span class="keyword1">using</span> <span class="alt_string">`ln_invar (e # es)`</span> <span class="keyword1">unfolding</span> ln_invar_def <span class="keyword1">by</span> auto
              <span class="keyword1">have</span> <span class="string">&quot;c a = ln_&alpha; (e # es) a&quot;</span>
                <span class="keyword1">proof</span> <span class="delimiter">(</span>cases <span class="string">&quot;a = (u1, v1)&quot;</span><span class="delimiter">)</span>
                  <span class="keyword3">case</span> True
                    <span class="keyword1">have</span> <span class="string">&quot;c a = c1&quot;</span> <span class="keyword1">using</span> fct4 True <span class="keyword1">by</span> simp
                    <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                      <span class="keyword1">have</span> <span class="string">&quot;(ln_&alpha; (e # es)) a = (SOME c. (u1, v1, c) &isin; set (e # es) &and; c &ne; 0)&quot;</span>
                        <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;?L = ?R&quot;</span><span class="delimiter">)</span> <span class="keyword1">unfolding</span> ln_&alpha;_def <span class="keyword1">using</span> obt1 fct0 True <span class="keyword1">by</span> auto
                      <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;?R = c1&quot;</span>
                        <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
                          <span class="keyword3">assume</span> <span class="string">&quot;&not; ?thesis&quot;</span>
                          <span class="keyword1">then</span> <span class="keyword3">obtain</span> c1&#39; <span class="keyword2">where</span> <span class="string">&quot;(u1, v1, c1&#39;) &isin; set (e # es) 
                            &and; c1&#39; &ne; 0 &and; c1&#39; &ne; c1&quot;</span> <span class="keyword1">using</span> fct0 obt1 <span class="keyword1">by</span> auto
                          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not;distinct (map (&lambda;(u, v, _). (u,v)) (e # es))&quot;</span> 
                            <span class="keyword1">using</span> obt1 <span class="keyword1">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>mono_tags<span class="delimiter">,</span> lifting<span class="delimiter">)</span> Pair_inject 
                              distinct_map_eq list.set_intros<span class="delimiter">(</span>1<span class="delimiter">)</span> split_conv<span class="delimiter">)</span> 
                          <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> f1 <span class="keyword1">by</span> blast
                        <span class="keyword1">qed</span>
                      <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;?L = c1&quot;</span> <span class="keyword1">by</span> blast
                    <span class="keyword1">}</span>
                    <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">by</span> simp
                <span class="keyword1">next</span>
                  <span class="keyword3">case</span> False
                    <span class="keyword1">have</span> f1<span class="delimiter">:</span> <span class="string">&quot;&forall;u1&#39; v1&#39; c1&#39;. u1&#39; &ne; u1 &or; v1&#39; &ne; v1 --&gt; ((u1&#39;, v1&#39;, c1&#39;) &isin; set (e # es)
                      &lt;-&gt; (u1&#39;, v1&#39;, c1&#39;) &isin; set es)&quot;</span> <span class="keyword1">using</span> obt1 <span class="keyword1">by</span> auto
                    <span class="keyword3">obtain</span> u1&#39; v1&#39; <span class="keyword2">where</span> <span class="string">&quot;a = (u1&#39;, v1&#39;)&quot;</span> <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases a<span class="delimiter">)</span> <span class="keyword1">by</span> auto
                    <span class="keyword1">{</span>
                      <span class="keyword1">have</span> <span class="string">&quot;(ln_&alpha; (e # es)) (u1&#39;, v1&#39;) = (ln_&alpha; es) (u1&#39;, v1&#39;)&quot;</span>
                        <span class="keyword1">proof</span> <span class="delimiter">(</span>cases <span class="string">&quot;&exist; c1&#39;. (u1&#39;, v1&#39;, c1&#39;) &isin; set (e # es) &and; c1&#39; &ne; 0&quot;</span><span class="delimiter">)</span>
                          <span class="keyword3">case</span> True
                            <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">unfolding</span> ln_&alpha;_def 
                              <span class="keyword1">using</span> f1 False True <span class="alt_string">`a = (u1&#39;, v1&#39;)`</span> <span class="keyword1">by</span> auto
                        <span class="keyword1">next</span>
                          <span class="keyword3">case</span> False
                            <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">unfolding</span> ln_&alpha;_def <span class="keyword1">by</span> auto
                        <span class="keyword1">qed</span>
                      <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(ln_&alpha; (e # es)) a = (ln_&alpha; es) a&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`a = (u1&#39;, v1&#39;)`</span> <span class="keyword1">by</span> simp
                    <span class="keyword1">}</span>
                    <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;c a = c&#39; a&quot;</span> <span class="keyword1">using</span> False fct4 <span class="keyword1">by</span> simp
                    <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;c&#39; a = ln_&alpha; es a&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`c&#39; = ln_&alpha; es`</span> <span class="keyword1">by</span> simp
                    <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">by</span> simp
                <span class="keyword1">qed</span>
            <span class="keyword1">}</span>
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;c = ln_&alpha; (e # es)&quot;</span> <span class="keyword1">by</span> auto
          <span class="keyword1">}</span>
          <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;(e # es, c) &isin; ln_rel&quot;</span> <span class="keyword1">unfolding</span> ln_rel_def br_def <span class="keyword1">by</span> simp
        <span class="keyword1">}</span>
        <span class="keyword1">moreover</span> <span class="keyword1">{</span>
          <span class="keyword1">have</span> <span class="string">&quot;Graph.V c = Graph.V c&#39; &cup; {u1, v1}&quot;</span> <span class="keyword1">unfolding</span> Graph.V_def Graph.E_def
            <span class="keyword1">using</span> fct0 fct4 <span class="keyword1">by</span> auto
          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;Graph.V c&#39; = V&#39;&quot;</span> <span class="keyword1">using</span> fct <span class="keyword1">by</span> blast
          <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;Graph.V c = V&quot;</span> <span class="keyword1">using</span> fct5 <span class="keyword1">by</span> auto
        <span class="keyword1">}</span>
        <span class="keyword1">moreover</span> <span class="keyword1">{</span>
          <span class="keyword1">have</span> <span class="string">&quot;finite V&#39;&quot;</span> <span class="keyword1">using</span> fct <span class="keyword1">by</span> blast
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;finite V&quot;</span> <span class="keyword1">using</span> fct5 <span class="keyword1">by</span> auto
        <span class="keyword1">}</span>
        <span class="keyword1">moreover</span> <span class="keyword1">{</span>
          <span class="keyword3">assume</span> <span class="string">&quot;s_n&quot;</span>
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;s_n&#39; &or; u1 = s&quot;</span> <span class="keyword1">using</span> fct2 <span class="keyword1">by</span> blast
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;s &isin; V&quot;</span>
            <span class="keyword1">proof</span>
              <span class="keyword3">assume</span> <span class="string">&quot;s_n&#39;&quot;</span>
                <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> fct fct5 <span class="keyword1">by</span> auto
            <span class="keyword1">next</span>
              <span class="keyword3">assume</span> <span class="string">&quot;u1 = s&quot;</span>
                <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> fct5 <span class="keyword1">by</span> simp
            <span class="keyword1">qed</span>
        <span class="keyword1">}</span>
        <span class="keyword1">moreover</span> <span class="keyword1">{</span>
          <span class="keyword3">assume</span> <span class="string">&quot;t_n&quot;</span>
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;t_n&#39; &or; v1 = t&quot;</span> <span class="keyword1">using</span> fct3 <span class="keyword1">by</span> blast
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;t &isin; V&quot;</span>
            <span class="keyword1">proof</span>
              <span class="keyword3">assume</span> <span class="string">&quot;t_n&#39;&quot;</span>
                <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> fct fct5 <span class="keyword1">by</span> auto
            <span class="keyword1">next</span>
              <span class="keyword3">assume</span> <span class="string">&quot;v1 = t&quot;</span>
                <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> fct5 <span class="keyword1">by</span> simp
            <span class="keyword1">qed</span>
        <span class="keyword1">}</span>
        <span class="keyword1">moreover</span> <span class="keyword1">{</span>
          <span class="keyword3">assume</span> <span class="string">&quot;&not;s_n&quot;</span>
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not;s_n&#39; &and; u1 &ne; s&quot;</span> <span class="keyword1">using</span> fct2 <span class="keyword1">by</span> blast
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;s &notin; V&quot;</span> <span class="keyword1">using</span> fct fct5 fct1  <span class="keyword1">by</span> auto
        <span class="keyword1">}</span>
        <span class="keyword1">moreover</span> <span class="keyword1">{</span>
          <span class="keyword3">assume</span> <span class="string">&quot;&not;t_n&quot;</span>
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not;t_n&#39; &and; v1 &ne; t&quot;</span> <span class="keyword1">using</span> fct3 <span class="keyword1">by</span> blast
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;t &notin; V&quot;</span> <span class="keyword1">using</span> fct fct5 fct1  <span class="keyword1">by</span> auto
        <span class="keyword1">}</span>
        <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;&forall;u v. (c (u, v) &ge; 0)&quot;</span> <span class="keyword1">using</span> fct fct4 fct1 fct0 <span class="keyword1">by</span> auto
        <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;&forall;u. c (u, u) = 0&quot;</span> <span class="keyword1">using</span> fct fct4 fct1 fct0 <span class="keyword1">by</span> auto
        <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;&forall;u. c (u, s) = 0&quot;</span> <span class="keyword1">using</span> fct fct4 fct1 fct0 <span class="keyword1">by</span> auto
        <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;&forall;u. c (t, u) = 0&quot;</span> <span class="keyword1">using</span> fct fct4 fct1 fct0 <span class="keyword1">by</span> auto
        <span class="keyword1">moreover</span> <span class="keyword1">{</span>
          <span class="keyword3">fix</span> a b
          <span class="keyword3">assume</span> <span class="string">&quot;c (a, b) &ne; 0&quot;</span>
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;a &ne; b&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`&forall;u. c (u, u) = 0`</span> <span class="keyword1">by</span> auto
          <span class="keyword1">have</span> <span class="string">&quot;c (b, a) = 0&quot;</span>
            <span class="keyword1">proof</span> <span class="delimiter">(</span>cases <span class="string">&quot;(a, b) = (u1, v1)&quot;</span><span class="delimiter">)</span>
              <span class="keyword3">case</span> True
                <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;c (b, a) = c&#39; (v1, u1)&quot;</span> <span class="keyword1">using</span> fct4 <span class="alt_string">`a &ne; b`</span> <span class="keyword1">by</span> auto 
                <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;c&#39; (v1, u1) = 0&quot;</span> <span class="keyword1">using</span> fct0 obt3 <span class="keyword1">by</span> auto
                <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">by</span> simp
            <span class="keyword1">next</span>
              <span class="keyword3">case</span> False
                <span class="keyword3">thus</span> <span class="var">?thesis</span>
                  <span class="keyword1">proof</span> <span class="delimiter">(</span>cases <span class="string">&quot;(b, a) = (u1, v1)&quot;</span><span class="delimiter">)</span>
                    <span class="keyword3">case</span> True
                      <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;c (a, b) = c&#39; (v1, u1)&quot;</span> <span class="keyword1">using</span> fct4 <span class="alt_string">`a &ne; b`</span> <span class="keyword1">by</span> auto
                      <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;c&#39; (v1, u1) = 0&quot;</span> <span class="keyword1">using</span> fct0 obt3 <span class="keyword1">by</span> auto
                      <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">using</span> <span class="alt_string">`c (a, b) &ne; 0`</span> <span class="keyword1">by</span> simp
                  <span class="keyword1">next</span>
                    <span class="keyword3">case</span> False
                      <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;c (b, a) = c&#39; (b, a)&quot;</span> <span class="keyword1">using</span> fct4 <span class="keyword1">by</span> auto
                      <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;c (a, b) = c&#39; (a, b)&quot;</span> 
                        <span class="keyword1">using</span> False <span class="alt_string">`(a, b) &ne; (u1, v1)`</span> fct4 <span class="keyword1">by</span> auto
                      <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">using</span> fct <span class="alt_string">`c (a, b) &ne; 0`</span> <span class="keyword1">by</span> auto 
                  <span class="keyword1">qed</span>
            <span class="keyword1">qed</span>
        <span class="keyword1">}</span> <span class="keyword1">note</span> n_fct <span class="delimiter">=</span> this
        <span class="keyword1">moreover</span> <span class="keyword1">{</span>
          <span class="keyword1">{</span>
            <span class="keyword3">fix</span> a
            <span class="keyword3">assume</span> <span class="string">&quot;a &ne; u1&quot;</span>
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;succ a = sc&#39; a&quot;</span> <span class="keyword1">using</span> fct6 <span class="keyword1">by</span> simp
            <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;set (sc&#39; a) = Graph.E c&#39; `` {a} &and; distinct (sc&#39; a)&quot;</span>
              <span class="keyword1">using</span> fct <span class="keyword1">by</span> blast
            <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;set (succ a) = Graph.E c``{a} &and; distinct (succ a)&quot;</span>
              <span class="keyword1">unfolding</span> Graph.E_def <span class="keyword1">using</span> fct4 <span class="alt_string">`a &ne; u1`</span> <span class="keyword1">by</span> auto 
          <span class="keyword1">}</span>
          <span class="keyword1">moreover</span> <span class="keyword1">{</span>
            <span class="keyword3">fix</span> a
            <span class="keyword3">assume</span> <span class="string">&quot;a = u1&quot;</span>
            <span class="keyword1">have</span> <span class="string">&quot;set (succ a) = Graph.E c``{a} &and; distinct (succ a)&quot;</span>
              <span class="keyword1">proof</span> <span class="delimiter">(</span>cases <span class="string">&quot;c&#39; (u1, v1) = 0&quot;</span><span class="delimiter">)</span>
                <span class="keyword3">case</span> True
                  <span class="keyword1">have</span> fct<span class="delimiter">:</span> <span class="string">&quot;set (sc&#39; a) = Graph.E c&#39; `` {a} &and; distinct (sc&#39; a)&quot;</span>
                    <span class="keyword1">using</span> fct <span class="keyword1">by</span> blast
                  
                  <span class="keyword1">have</span> <span class="string">&quot;succ a = v1 # sc&#39; a&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`a = u1`</span> fct6 True <span class="keyword1">by</span> simp
                  <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;Graph.E c = Graph.E c&#39; &cup; {(u1, v1)}&quot;</span> 
                    <span class="keyword1">unfolding</span> Graph.E_def <span class="keyword1">using</span> fct4 fct0 <span class="keyword1">by</span> auto
                  <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;v1 &notin; set (sc&#39; a)&quot;</span>
                    <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
                      <span class="keyword3">assume</span> <span class="string">&quot;&not; ?thesis&quot;</span>
                      <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;c&#39; (a, v1) &ne; 0&quot;</span> <span class="keyword1">using</span> fct <span class="keyword1">unfolding</span> Graph.E_def <span class="keyword1">by</span> auto
                      <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> True <span class="alt_string">`a = u1`</span> <span class="keyword1">by</span> simp
                    <span class="keyword1">qed</span>
                  <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">using</span> <span class="alt_string">`a = u1`</span> fct <span class="keyword1">by</span> auto
              <span class="keyword1">next</span>
                <span class="keyword3">case</span> False
                  <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> fct0 obt3 <span class="keyword1">by</span> auto
              <span class="keyword1">qed</span>
        <span class="keyword1">}</span>
        <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;&forall;u. set (succ u) = Graph.E c `` {u} &and; distinct (succ u)&quot;</span> <span class="keyword1">by</span> metis
      <span class="keyword1">}</span>
        <span class="keyword1">moreover</span> <span class="keyword1">{</span>
          <span class="keyword1">{</span>
            <span class="keyword3">fix</span> a
            <span class="keyword3">assume</span> <span class="string">&quot;a &ne; v1&quot;</span>
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;pred a = pd&#39; a&quot;</span> <span class="keyword1">using</span> fct7 <span class="keyword1">by</span> simp
            <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;set (pd&#39; a) = (Graph.E c&#39;)&macr; `` {a} &and; distinct (pd&#39; a)&quot;</span>
              <span class="keyword1">using</span> fct <span class="keyword1">by</span> blast
            <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;set (pred a) = (Graph.E c)&macr;``{a} &and; distinct (pred a)&quot;</span>
              <span class="keyword1">unfolding</span> Graph.E_def <span class="keyword1">using</span> fct4 <span class="alt_string">`a &ne; v1`</span> <span class="keyword1">by</span> auto 
          <span class="keyword1">}</span>
          <span class="keyword1">moreover</span> <span class="keyword1">{</span>
            <span class="keyword3">fix</span> a
            <span class="keyword3">assume</span> <span class="string">&quot;a = v1&quot;</span>
            <span class="keyword1">have</span> <span class="string">&quot;set (pred a) = (Graph.E c)&macr;``{a} &and; distinct (pred a)&quot;</span>
              <span class="keyword1">proof</span> <span class="delimiter">(</span>cases <span class="string">&quot;c&#39; (u1, v1) = 0&quot;</span><span class="delimiter">)</span>
                <span class="keyword3">case</span> True
                  <span class="keyword1">have</span> fct<span class="delimiter">:</span> <span class="string">&quot;set (pd&#39; a) = (Graph.E c&#39;)&macr; `` {a} &and; distinct (pd&#39; a)&quot;</span>
                    <span class="keyword1">using</span> fct <span class="keyword1">by</span> blast
                  
                  <span class="keyword1">have</span> <span class="string">&quot;pred a = u1 # pd&#39; a&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`a = v1`</span> fct7 True <span class="keyword1">by</span> simp
                  <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;Graph.E c = Graph.E c&#39; &cup; {(u1, v1)}&quot;</span> 
                    <span class="keyword1">unfolding</span> Graph.E_def <span class="keyword1">using</span> fct4 fct0 <span class="keyword1">by</span> auto
                  <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;u1 &notin; set (pd&#39; a)&quot;</span>
                    <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
                      <span class="keyword3">assume</span> <span class="string">&quot;&not; ?thesis&quot;</span>
                      <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;c&#39; (u1, a) &ne; 0&quot;</span> <span class="keyword1">using</span> fct <span class="keyword1">unfolding</span> Graph.E_def <span class="keyword1">by</span> auto
                      <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> True <span class="alt_string">`a = v1`</span> <span class="keyword1">by</span> simp
                    <span class="keyword1">qed</span>
                  <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">using</span> <span class="alt_string">`a = v1`</span> fct <span class="keyword1">by</span> auto
              <span class="keyword1">next</span>
                <span class="keyword3">case</span> False
                  <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> fct0 obt3 <span class="keyword1">by</span> auto
              <span class="keyword1">qed</span>
        <span class="keyword1">}</span>
        <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;&forall;u. set (pred u) = (Graph.E c)&macr;`` {u} &and; distinct (pred u)&quot;</span> <span class="keyword1">by</span> metis
      <span class="keyword1">}</span>
      <span class="keyword1">moreover</span> <span class="keyword1">{</span>
        <span class="keyword1">{</span>
          <span class="keyword3">fix</span> a
          <span class="keyword3">assume</span> <span class="string">&quot;a &ne; u1 &and; a &ne; v1&quot;</span>
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;psucc a = ps&#39; a&quot;</span> <span class="keyword1">using</span> fct8 <span class="keyword1">by</span> simp
            <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;set (ps&#39; a) = 
              Graph.E c&#39;``{a} &cup; (Graph.E c&#39;)&macr;``{a} &and; distinct (ps&#39; a)&quot;</span> <span class="keyword1">using</span> fct <span class="keyword1">by</span> blast
            <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;set (psucc a) = Graph.E c``{a} &cup; (Graph.E c)&macr;``{a} &and; 
              distinct (psucc a)&quot;</span> <span class="keyword1">unfolding</span> Graph.E_def <span class="keyword1">using</span> fct4 <span class="alt_string">`a &ne; u1 &and; a &ne; v1`</span> <span class="keyword1">by</span> auto
        <span class="keyword1">}</span>
        <span class="keyword1">moreover</span> <span class="keyword1">{</span>
          <span class="keyword3">fix</span> a
          <span class="keyword3">assume</span> <span class="string">&quot;a = u1 &or; a = v1&quot;</span>
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;set (psucc a) = Graph.E c``{a} &cup; (Graph.E c)&macr;``{a} &and; distinct (psucc a)&quot;</span>
            <span class="keyword1">proof</span>
              <span class="keyword3">assume</span> <span class="string">&quot;a = u1&quot;</span>
              <span class="keyword3">show</span> <span class="var">?thesis</span>
                <span class="keyword1">proof</span> <span class="delimiter">(</span>cases <span class="string">&quot;c&#39; (u1, v1) = 0 &and; c&#39; (v1, u1) = 0&quot;</span><span class="delimiter">)</span>
                  <span class="keyword3">case</span> True
                    <span class="keyword1">have</span> fct<span class="delimiter">:</span> <span class="string">&quot;set (ps&#39; a) = Graph.E c&#39; `` {a} &cup; (Graph.E c&#39;)&macr; `` {a} &and; 
                      distinct (ps&#39; a)&quot;</span> <span class="keyword1">using</span> fct <span class="keyword1">by</span> blast
                    
                    <span class="keyword1">have</span> <span class="string">&quot;psucc a = v1 # ps&#39; a&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`a = u1`</span> fct8 True <span class="keyword1">by</span> simp
                    <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;Graph.E c = Graph.E c&#39; &cup; {(u1, v1)}&quot;</span> 
                      <span class="keyword1">unfolding</span> Graph.E_def <span class="keyword1">using</span> fct4 fct0 <span class="keyword1">by</span> auto
                    <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;v1 &notin; set (ps&#39; a)&quot;</span>
                      <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
                        <span class="keyword3">assume</span> <span class="string">&quot;&not; ?thesis&quot;</span>
                        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;c&#39; (a, v1) &ne; 0 &or; c&#39; (v1, a) &ne; 0&quot;</span>
                          <span class="keyword1">using</span> fct <span class="keyword1">unfolding</span> Graph.E_def <span class="keyword1">by</span> auto
                        <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> True <span class="alt_string">`a = u1`</span> <span class="keyword1">by</span> simp
                      <span class="keyword1">qed</span>
                    <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">using</span> <span class="alt_string">`a = u1`</span> fct <span class="keyword1">by</span> auto
                <span class="keyword1">next</span>
                  <span class="keyword3">case</span> False
                    <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> fct0 obt3 <span class="keyword1">by</span> auto 
                <span class="keyword1">qed</span>
            <span class="keyword1">next</span>
              <span class="keyword3">assume</span> <span class="string">&quot;a = v1&quot;</span>
              <span class="keyword3">show</span> <span class="var">?thesis</span>
                <span class="keyword1">proof</span> <span class="delimiter">(</span>cases <span class="string">&quot;c&#39; (u1, v1) = 0 &and; c&#39; (v1, u1) = 0&quot;</span><span class="delimiter">)</span>
                  <span class="keyword3">case</span> True
                    <span class="keyword1">have</span> fct<span class="delimiter">:</span> <span class="string">&quot;set (ps&#39; a) = Graph.E c&#39; `` {a} &cup; (Graph.E c&#39;)&macr; `` {a} &and; 
                      distinct (ps&#39; a)&quot;</span> <span class="keyword1">using</span> fct <span class="keyword1">by</span> blast
                    
                    <span class="keyword1">have</span> <span class="string">&quot;psucc a = u1 # ps&#39; a&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`a = v1`</span> fct8 True <span class="keyword1">by</span> simp
                    <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;Graph.E c = Graph.E c&#39; &cup; {(u1, v1)}&quot;</span> 
                      <span class="keyword1">unfolding</span> Graph.E_def <span class="keyword1">using</span> fct4 fct0 <span class="keyword1">by</span> auto
                    <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;u1 &notin; set (ps&#39; a)&quot;</span>
                      <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
                        <span class="keyword3">assume</span> <span class="string">&quot;&not; ?thesis&quot;</span>
                        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;c&#39; (u1, a) &ne; 0 &or; c&#39; (a, u1) &ne; 0&quot;</span>
                          <span class="keyword1">using</span> fct <span class="keyword1">unfolding</span> Graph.E_def <span class="keyword1">by</span> auto
                        <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> True <span class="alt_string">`a = v1`</span> <span class="keyword1">by</span> simp
                      <span class="keyword1">qed</span>
                    <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">using</span> <span class="alt_string">`a = v1`</span> fct <span class="keyword1">by</span> auto
                <span class="keyword1">next</span>
                  <span class="keyword3">case</span> False
                    <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> fct0 obt3 <span class="keyword1">by</span> auto
                <span class="keyword1">qed</span>
            <span class="keyword1">qed</span>
        <span class="keyword1">}</span>
        <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;&forall;u. set (psucc u) = Graph.E c``{u} &cup; (Graph.E c)&macr;``{u} &and;
          distinct (psucc u)&quot;</span> <span class="keyword1">by</span> metis
      <span class="keyword1">}</span>
      <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?case</span> <span class="keyword1">by</span> simp  
    <span class="keyword1">qed</span>
    
  <span class="keyword1">lemma</span> read_correct2<span class="delimiter">:</span> <span class="string">&quot;read el s t = None ==&gt; &not;ln_invar el 
    &or; (&exist;u v c. (u,v,c) &isin; set el &and; &not;(c &gt; 0))
    &or; (&exist;u c. (u, u, c) &isin; set el &and; c &ne; 0) &or; 
    (&exist;u c. (u, s, c) &isin; set el &and; c &ne; 0) &or; (&exist;u c. (t, u, c) &isin; set el &and; c &ne; 0) &or;
    (&exist;u v c1 c2. (u, v, c1) &isin; set el &and; (v, u, c2) &isin; set el &and; c1 &ne; 0 &and; c2 &ne; 0)&quot;</span>
    <span class="keyword1">proof</span> <span class="delimiter">(</span>induction el<span class="delimiter">)</span>
      <span class="keyword3">case</span> Nil
        <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">by</span> auto
    <span class="keyword1">next</span>
      <span class="keyword3">case</span> <span class="delimiter">(</span>Cons e el<span class="delimiter">)</span>
        <span class="keyword3">thus</span> <span class="var">?case</span>
          <span class="keyword1">proof</span> <span class="delimiter">(</span>cases <span class="string">&quot;read el s t = None&quot;</span><span class="delimiter">)</span>
            <span class="keyword3">case</span> True
              <span class="keyword1">note</span> Cons.IH<span class="delimiter">[</span>OF this<span class="delimiter">]</span>
              <span class="keyword3">thus</span> <span class="var">?thesis</span>
                <span class="keyword1">proof</span>
                  <span class="keyword3">assume</span> <span class="string">&quot;&not;ln_invar el&quot;</span>
                  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not;distinct (map (&lambda;(u, v, _). (u,v)) (e # el)) &or; 
                    (&exist;(u, v, c) &isin; set (e # el). &not;(c&gt;0))&quot;</span> <span class="keyword1">unfolding</span> ln_invar_def <span class="keyword1">by</span> fastforce
                  <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">unfolding</span> ln_invar_def <span class="keyword1">by</span> fastforce
                <span class="keyword1">next</span>
                  <span class="keyword3">assume</span> <span class="string">&quot;(&exist;u v c. (u, v, c) &isin; set (el) &and; &not;(c &gt; 0)) 
                  &or; (&exist;u c. (u, u, c) &isin; set el &and; c &ne; 0) &or; 
                    (&exist;u c. (u, s, c) &isin; set el &and; c &ne; 0) &or; (&exist;u c. (t, u, c) &isin; set el &and; c &ne; 0) &or;
                    (&exist;u v c1 c2. (u, v, c1) &isin; set el &and; (v, u, c2) &isin; set el &and; c1 &ne; 0 &and; c2 &ne; 0)&quot;</span> 
                  
                  <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                    <span class="keyword3">assume</span> <span class="string">&quot;(&exist;u v c. (u, v, c) &isin; set el &and; &not;(c &gt; 0))&quot;</span>
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(&exist;u v c. (u, v, c) &isin; set (e # el) &and; &not;(c &gt; 0))&quot;</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">}</span>
                  <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                    <span class="keyword3">assume</span> <span class="string">&quot;(&exist;u c. (u, u, c) &isin; set el &and; c &ne; 0)&quot;</span>
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(&exist;u c. (u, u, c) &isin; set (e # el) &and; c &ne; 0)&quot;</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">}</span>
                  <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                    <span class="keyword3">assume</span> <span class="string">&quot;(&exist;u c. (u, s, c) &isin; set el &and; c &ne; 0)&quot;</span>
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(&exist;u c. (u, s, c) &isin; set (e # el) &and; c &ne; 0)&quot;</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">}</span>
                  <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                    <span class="keyword3">assume</span> <span class="string">&quot;(&exist;u c. (t, u, c) &isin; set el &and; c &ne; 0)&quot;</span>
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(&exist;u c. (t, u, c) &isin; set (e # el) &and; c &ne; 0)&quot;</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">}</span>
                  <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                    <span class="keyword3">assume</span> <span class="string">&quot;(&exist;u v c1 c2. (u, v, c1) &isin; set el &and; (v, u, c2) &isin; set el &and; c1 &ne; 0 &and; c2 &ne; 0)&quot;</span>
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(&exist;u v c1 c2. (u, v, c1) &isin; set (e # el) &and;
                      (v, u, c2) &isin; set (e # el) &and; c1 &ne; 0 &and; c2 &ne; 0)&quot;</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">}</span>
                  <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">by</span> blast
                <span class="keyword1">qed</span>
          <span class="keyword1">next</span>
            <span class="keyword3">case</span> False
            <span class="keyword1">then</span> <span class="keyword3">obtain</span> x <span class="keyword2">where</span> obt1<span class="delimiter">:</span> <span class="string">&quot;read el s t = Some x&quot;</span> <span class="keyword1">by</span> auto
            <span class="keyword3">obtain</span> u1 v1 c1 <span class="keyword2">where</span> obt2<span class="delimiter">:</span> <span class="string">&quot;e = (u1, v1, c1)&quot;</span> <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases e<span class="delimiter">)</span> <span class="keyword1">by</span> auto
            <span class="keyword3">obtain</span> c&#39; V&#39; sc&#39; pd&#39; ps&#39; s_n&#39; t_n&#39; <span class="keyword2">where</span> obt3<span class="delimiter">:</span> <span class="string">&quot;x = (|pn_c = c&#39;, pn_V = V&#39;, pn_succ = sc&#39;,
              pn_pred = pd&#39;, pn_psucc = ps&#39;, pn_s_node = s_n&#39;, pn_t_node = t_n&#39;|)),&quot;</span> 
              <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases x<span class="delimiter">)</span> <span class="keyword1">by</span> auto 
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(el, c&#39;) &isin; ln_rel&quot;</span> <span class="keyword1">using</span> obt1 read_correct1<span class="delimiter">[</span>of el s t<span class="delimiter">]</span> <span class="keyword1">by</span> simp
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;c&#39; = ln_&alpha; el&quot;</span> <span class="keyword1">unfolding</span> ln_rel_def br_def <span class="keyword1">by</span> simp
            

            <span class="keyword1">have</span> <span class="string">&quot;(c&#39; (u1, v1) &ne; 0 &or; c&#39; (v1, u1) &ne; 0 &or; c1 &le; 0) &or; 
              (c1 &gt; 0 &and; (u1 = v1 &or; v1 = s &or; u1 = t))&quot;</span>
              <span class="keyword1">using</span> obt1 obt2 obt3 False Cons.prems 
                <span class="keyword1">by</span> <span class="delimiter">(</span>auto split<span class="delimiter">:</span>option.splits if_splits<span class="delimiter">)</span>
            <span class="keyword1">moreover</span> <span class="keyword1">{</span>
              <span class="keyword3">assume</span> <span class="string">&quot;c1 &le; 0&quot;</span>
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not; ln_invar (e # el)&quot;</span> <span class="keyword1">unfolding</span> ln_invar_def <span class="keyword1">using</span> obt2 <span class="keyword1">by</span> auto
            <span class="keyword1">}</span>
            <span class="keyword1">moreover</span> <span class="keyword1">{</span>
              <span class="keyword3">assume</span> <span class="string">&quot;c1 &gt; 0 &and; u1 = v1&quot;</span>
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(&exist;u c. (u, u, c) &isin; set (e # el) &and; c &gt; 0)&quot;</span> <span class="keyword1">using</span> obt2 <span class="keyword1">by</span> auto
            <span class="keyword1">}</span>
            <span class="keyword1">moreover</span> <span class="keyword1">{</span>
              <span class="keyword3">assume</span> <span class="string">&quot;c1 &gt; 0 &and; v1 = s&quot;</span>
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(&exist;u c. (u, s, c) &isin; set (e # el) &and; c &gt; 0)&quot;</span> <span class="keyword1">using</span> obt2 <span class="keyword1">by</span> auto
            <span class="keyword1">}</span>
            <span class="keyword1">moreover</span> <span class="keyword1">{</span>
              <span class="keyword3">assume</span> <span class="string">&quot;c1 &gt; 0 &and; u1 = t&quot;</span>
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(&exist;u c. (t, u, c) &isin; set (e # el) &and; c &gt; 0)&quot;</span> <span class="keyword1">using</span> obt2 <span class="keyword1">by</span> auto
            <span class="keyword1">}</span>
            <span class="keyword1">moreover</span> <span class="keyword1">{</span>
              <span class="keyword3">assume</span> <span class="string">&quot;c&#39; (u1, v1) &ne; 0&quot;</span>
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&exist;c1&#39;. (u1, v1, c1&#39;) &isin; set el&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`c&#39; = ln_&alpha; el`</span> <span class="keyword1">unfolding</span> ln_&alpha;_def
                <span class="keyword1">by</span> <span class="delimiter">(</span>auto split<span class="delimiter">:</span>if_splits<span class="delimiter">)</span>
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not; distinct (map (&lambda;(u, v, _). (u, v)) (e # el))&quot;</span> <span class="keyword1">using</span> obt2 <span class="keyword1">by</span> force
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not;ln_invar (e # el)&quot;</span> <span class="keyword1">unfolding</span> ln_invar_def <span class="keyword1">by</span> auto
            <span class="keyword1">}</span>
            <span class="keyword1">moreover</span> <span class="keyword1">{</span>
              <span class="keyword3">assume</span> <span class="string">&quot;c&#39; (v1, u1) &ne; 0&quot;</span>
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&exist;c1&#39;. (v1, u1, c1&#39;) &isin; set el &and; c1&#39; &ne; 0&quot;</span> 
                <span class="keyword1">using</span> <span class="alt_string">`c&#39; = ln_&alpha; el`</span> <span class="keyword1">unfolding</span> ln_&alpha;_def <span class="keyword1">by</span> <span class="delimiter">(</span>auto split<span class="delimiter">:</span>if_splits<span class="delimiter">)</span>
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not;ln_invar (e # el) &or; (&exist;u v c1 c2.
                (u, v, c1) &isin; set (e # el) &and; (v, u, c2) &isin; set (e # el) &and; c1 &ne; 0 &and; c2 &ne; 0)&quot;</span>
                <span class="keyword1">proof</span> <span class="delimiter">(</span>cases <span class="string">&quot;c1 &ne; 0&quot;</span><span class="delimiter">)</span>
                  <span class="keyword3">case</span> True
                    <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> <span class="alt_string">`&exist;c1&#39;. (v1, u1, c1&#39;) &isin; set el  &and; c1&#39; &ne; 0`</span> obt2 <span class="keyword1">by</span> auto
                <span class="keyword1">next</span>
                  <span class="keyword3">case</span> False
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not;ln_invar (e # el)&quot;</span> <span class="keyword1">unfolding</span> ln_invar_def <span class="keyword1">using</span> obt2 <span class="keyword1">by</span> auto
                    <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> blast
                <span class="keyword1">qed</span>
            <span class="keyword1">}</span>
            <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">by</span> blast
          <span class="keyword1">qed</span>
    <span class="keyword1">qed</span>
    
  <span class="keyword1">record</span> <span class="tfree">&#39;capacity</span><span class="delimiter">::</span>linordered_idom pre_network&#39; <span class="delimiter">=</span>
    pn_c&#39; <span class="delimiter">::</span> <span class="string">&quot;(nat*nat,&#39;capacity) ahm&quot;</span>
    pn_V&#39; <span class="delimiter">::</span> <span class="string">&quot;nat ahs&quot;</span>
    pn_succ&#39; <span class="delimiter">::</span> <span class="string">&quot;(nat,nat list) ahm&quot;</span>
    pn_pred&#39; <span class="delimiter">::</span> <span class="string">&quot;(nat,nat list) ahm&quot;</span>
    pn_psucc&#39; <span class="delimiter">::</span> <span class="string">&quot;(nat,nat list) ahm&quot;</span>
    pn_s_node&#39; <span class="delimiter">::</span> bool
    pn_t_node&#39; <span class="delimiter">::</span> bool


  <span class="keyword1">definition</span> <span class="string">&quot;pnet_&alpha; pn&#39; &equiv; (|
      pn_c = the_default 0 o (ahm.&alpha; (pn_c&#39; pn&#39;)), 
      pn_V = ahs_&alpha; (pn_V&#39; pn&#39;), 
      pn_succ = the_default [] o (ahm.&alpha; (pn_succ&#39; pn&#39;)),
      pn_pred = the_default [] o (ahm.&alpha; (pn_pred&#39; pn&#39;)),
      pn_psucc = the_default [] o (ahm.&alpha; (pn_psucc&#39; pn&#39;)), 
      pn_s_node = pn_s_node&#39; pn&#39;, 
      pn_t_node = pn_t_node&#39; pn&#39;
  |)),&quot;</span>  

  <span class="keyword1">definition</span> <span class="string">&quot;pnet_rel &equiv; br pnet_&alpha; (&lambda;_. True)&quot;</span>
  
  <span class="keyword1">definition</span> <span class="string">&quot;ahm_ld a ahm k &equiv; the_default a (ahm.lookup k ahm)&quot;</span>
  <span class="keyword1">abbreviation</span> <span class="string">&quot;cap_lookup &equiv; ahm_ld 0&quot;</span>
  <span class="keyword1">abbreviation</span> <span class="string">&quot;succ_lookup &equiv; ahm_ld []&quot;</span>


  <span class="keyword1">fun</span> read&#39; <span class="delimiter">::</span> <span class="string">&quot;(nat &times; nat &times; &#39;capacity::linordered_idom) list =&gt; nat =&gt; nat =&gt;
    &#39;capacity pre_network&#39; option&quot;</span> <span class="keyword2">where</span>
    <span class="string">&quot;read&#39; [] _ _ = Some (|
      pn_c&#39; = ahm.empty (), 
      pn_V&#39; = ahs.empty (), 
      pn_succ&#39; = ahm.empty (),
      pn_pred&#39; = ahm.empty (),
      pn_psucc&#39; = ahm.empty (), 
      pn_s_node&#39; = False, 
      pn_t_node&#39; = False
    |)),&quot;</span>
  <span class="delimiter">|</span> <span class="string">&quot;read&#39; ((u, v, c) # es) s t = ((case (read&#39; es s t) of 
      Some x =&gt;
        (if cap_lookup (pn_c&#39; x) (u, v) = 0 &and; cap_lookup (pn_c&#39; x) (v, u) = 0 &and; c &gt; 0 then
          (if u = v &or; v = s &or; u = t then
            None
          else
            Some (x(| 
              pn_c&#39; := ahm.update (u, v) c (pn_c&#39; x),
              pn_V&#39; := ahs.ins u (ahs.ins v (pn_V&#39; x)),
              pn_succ&#39; := ahm.update u (v # (succ_lookup (pn_succ&#39; x) u)) (pn_succ&#39; x),
              pn_pred&#39; := ahm.update v (u # (succ_lookup (pn_pred&#39; x) v)) (pn_pred&#39; x),
              pn_psucc&#39; := ahm.update u (v # (succ_lookup (pn_psucc&#39; x) u))
                (ahm.update v (u # (succ_lookup (pn_psucc&#39; x) v)) (pn_psucc&#39; x)),
              pn_s_node&#39; := pn_s_node&#39; x &or; u = s,
              pn_t_node&#39; := pn_t_node&#39; x &or; v = t
            |)),))
        else
          None)
    | None =&gt; None))&quot;</span>

  <span class="keyword1">lemma</span> read&#39;_correct<span class="delimiter">:</span> <span class="string">&quot;read el s t = map_option pnet_&alpha; (read&#39; el s t)&quot;</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>induction el s t rule<span class="delimiter">:</span> read.induct<span class="delimiter">)</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto 
      simp<span class="delimiter">:</span> pnet_&alpha;_def o_def ahm.correct ahs.correct ahm_ld_def 
      split<span class="delimiter">:</span> option.splits<span class="delimiter">)</span> <span class="comment">(* Takes long *)</span>
    
  <span class="keyword1">lemma</span> read&#39;_correct_alt<span class="delimiter">:</span> <span class="string">&quot;(read&#39; el s t, read el s t) &isin; &lang;pnet_rel&rang;option_rel&quot;</span>
    <span class="keyword1">unfolding</span> pnet_rel_def br_def
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> option_rel_def read&#39;_correct<span class="delimiter">)</span>
    <span class="keyword1">using</span> domIff <span class="keyword1">by</span> force

  <span class="keyword1">export_code</span> read <span class="keyword2">in</span> SML     
  
  <span class="keyword1">definition</span> <span class="string">&quot;reachable_spec c s &equiv; RETURN (((Graph.E c)<span class="hidden">&#8679;</span><sup>*</sup>)``{s}) &quot;</span>
  <span class="keyword1">definition</span> <span class="string">&quot;reaching_spec c t &equiv; RETURN ((((Graph.E c)&macr;)<span class="hidden">&#8679;</span><sup>*</sup>)``{t})&quot;</span>

  <span class="keyword1">definition</span> <span class="string">&quot;checkNet cc s t &equiv; do {
    if s = t then
      RETURN None
    else do {
      let rd = read cc s t;
      case rd of 
        None =&gt; RETURN None
      | Some x =&gt; do {                
          if pn_s_node x &and; pn_t_node x then
            do {
              ASSERT(finite ((Graph.E (pn_c x))<span class="hidden">&#8679;</span><sup>*</sup> `` {s}));
              ASSERT(finite (((Graph.E (pn_c x))&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t}));
              ASSERT(&forall;u. set ((pn_succ x) u) = Graph.E (pn_c x) `` {u} &and; distinct ((pn_succ x) u));
              ASSERT(&forall;u. set ((pn_pred x) u) = (Graph.E (pn_c x))&macr; `` {u} &and; distinct ((pn_pred x) u));
              
              succ_s \&lt;leftarrow&gt; reachable_spec (pn_c x) s;
              pred_t \&lt;leftarrow&gt; reaching_spec (pn_c x) t;
              if (pn_V x) = succ_s &and; (pn_V x) = pred_t then
                RETURN (Some (pn_c x, pn_psucc x))
              else
                RETURN None
            }
          else
            RETURN None
        }
      }
    }&quot;</span>

  <span class="keyword1">lemma</span> checkNet_pre_correct1 <span class="delimiter">:</span> <span class="string">&quot;checkNet el s t &le; 
    SPEC (&lambda; r. r = Some (c, psucc) --&gt; (el, c) &isin; ln_rel &and; Network c s t &and; 
    (&forall;u. set (psucc u) = Graph.E c``{u} &cup; (Graph.E c)&macr;``{u} &and; distinct (psucc u)))&quot;</span>
    <span class="keyword1">unfolding</span> checkNet_def reachable_spec_def reaching_spec_def
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>refine_vcg<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> clarsimp_all
      <span class="keyword1">proof</span> -
        <span class="keyword1">{</span>
          <span class="keyword3">fix</span> x
          <span class="keyword3">assume</span> asm1<span class="delimiter">:</span> <span class="string">&quot;s &ne; t&quot;</span>
          <span class="keyword3">assume</span> asm2<span class="delimiter">:</span> <span class="string">&quot;read el s t = Some x&quot;</span>
          <span class="keyword3">assume</span> asm3<span class="delimiter">:</span> <span class="string">&quot;pn_s_node x&quot;</span>
          <span class="keyword3">assume</span> asm4<span class="delimiter">:</span> <span class="string">&quot;pn_t_node x&quot;</span>
          <span class="keyword3">obtain</span> c V sc pd psucc  <span class="keyword2">where</span> obt<span class="delimiter">:</span> <span class="string">&quot;x = (|pn_c = c, pn_V = V,
            pn_succ = sc, pn_pred = pd,  pn_psucc = psucc, pn_s_node = True, pn_t_node = True|)),&quot;</span>
            <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases x<span class="delimiter">)</span> <span class="keyword1">using</span> asm3 asm4 <span class="keyword1">by</span> auto
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;read el s t = Some (|pn_c = c, pn_V = V, pn_succ = sc, pn_pred = pd, 
            pn_psucc = psucc, pn_s_node = True, pn_t_node = True|)),&quot;</span> <span class="keyword1">using</span> asm2 <span class="keyword1">by</span> simp
          <span class="keyword1">note</span> fct <span class="delimiter">=</span> read_correct1<span class="delimiter">[</span>OF this<span class="delimiter">]</span>
          
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;finite (Graph.V c)&quot;</span> <span class="keyword1">by</span> blast
          <span class="keyword1">have</span> <span class="string">&quot;Graph.E c &sube; (Graph.V c) &times; (Graph.V c)&quot;</span> <span class="keyword1">unfolding</span> Graph.V_def <span class="keyword1">by</span> auto
          <span class="keyword1">from</span> finite_subset<span class="delimiter">[</span>OF this<span class="delimiter">]</span> <span class="keyword1">have</span> <span class="string">&quot;finite (Graph.E (pn_c x))&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> obt<span class="delimiter">)</span>
          <span class="keyword1">then</span> <span class="keyword3">show</span>  <span class="string">&quot;finite ((Graph.E (pn_c x))<span class="hidden">&#8679;</span><sup>*</sup> `` {s})&quot;</span> 
            <span class="keyword2">and</span> <span class="string">&quot;finite (((Graph.E (pn_c x))&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t})&quot;</span>  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp add<span class="delimiter">:</span> finite_rtrancl_Image<span class="delimiter">)</span>
        <span class="keyword1">}</span>
        <span class="keyword1">{</span>
          <span class="keyword3">fix</span> x
          <span class="keyword3">assume</span> asm1<span class="delimiter">:</span> <span class="string">&quot;s &ne; t&quot;</span>
          <span class="keyword3">assume</span> asm2<span class="delimiter">:</span> <span class="string">&quot;read el s t = Some x&quot;</span>
          <span class="keyword3">assume</span> asm3<span class="delimiter">:</span> <span class="string">&quot;finite ((Graph.E (pn_c x))<span class="hidden">&#8679;</span><sup>*</sup> `` {s})&quot;</span>
          <span class="keyword3">assume</span> asm4<span class="delimiter">:</span> <span class="string">&quot;finite (((Graph.E (pn_c x))&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t})&quot;</span>
          <span class="keyword3">assume</span> asm5<span class="delimiter">:</span> <span class="string">&quot;pn_s_node x&quot;</span>
          <span class="keyword3">assume</span> asm6<span class="delimiter">:</span> <span class="string">&quot;pn_t_node x&quot;</span> 
          <span class="keyword3">obtain</span> c V sc pd psucc  <span class="keyword2">where</span> obt<span class="delimiter">:</span> <span class="string">&quot;x = (|pn_c = c, pn_V = V,
            pn_succ = sc, pn_pred = pd,  pn_psucc = psucc, pn_s_node = True, pn_t_node = True|)),&quot;</span>
            <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases x<span class="delimiter">)</span> <span class="keyword1">using</span> asm5 asm6 <span class="keyword1">by</span> auto
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;read el s t = Some (|pn_c = c, pn_V = V, pn_succ = sc, pn_pred = pd, 
            pn_psucc = psucc, pn_s_node = True, pn_t_node = True|)),&quot;</span> <span class="keyword1">using</span> asm2 <span class="keyword1">by</span> simp
          <span class="keyword1">note</span> fct <span class="delimiter">=</span> read_correct1<span class="delimiter">[</span>OF this<span class="delimiter">]</span>
          
          <span class="keyword1">have</span> <span class="string">&quot;!!u. set ((pn_succ x) u) = Graph.E (pn_c x) `` {u} &and; distinct ((pn_succ x) u)&quot;</span>
            <span class="keyword1">using</span> fct obt <span class="keyword1">by</span> simp
          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;!!u. set ((pn_pred x) u) = (Graph.E (pn_c x))&macr; `` {u} &and; 
            distinct ((pn_pred x) u)&quot;</span> <span class="keyword1">using</span> fct obt <span class="keyword1">by</span> simp
          <span class="keyword1">ultimately</span> <span class="keyword3">show</span>  <span class="string">&quot;!!u. set ((pn_succ x) u) = Graph.E (pn_c x) `` {u}&quot;</span> <span class="keyword2">and</span> 
            <span class="string">&quot;!!u. distinct ((pn_succ x) u)&quot;</span> <span class="keyword2">and</span> <span class="string">&quot;!!u. set ((pn_pred x) u) = (Graph.E (pn_c x))&macr; `` {u}&quot;</span>
            <span class="keyword2">and</span>  <span class="string">&quot;!!u.  distinct ((pn_pred x) u)&quot;</span> <span class="keyword1">by</span> auto 
        <span class="keyword1">}</span>
        <span class="keyword1">{</span>
          <span class="keyword3">fix</span> x
          <span class="keyword3">assume</span> asm1<span class="delimiter">:</span> <span class="string">&quot;s &ne; t&quot;</span>
          <span class="keyword3">assume</span> asm2<span class="delimiter">:</span> <span class="string">&quot;read el s t = Some x&quot;</span>
          <span class="keyword3">assume</span> asm3<span class="delimiter">:</span> <span class="string">&quot;pn_s_node x&quot;</span>
          <span class="keyword3">assume</span> asm4<span class="delimiter">:</span> <span class="string">&quot;pn_t_node x&quot;</span>
          <span class="keyword3">assume</span> asm5<span class="delimiter">:</span> <span class="string">&quot;((Graph.E (pn_c x))&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t} = (Graph.E (pn_c x))<span class="hidden">&#8679;</span><sup>*</sup> `` {s}&quot;</span>
          <span class="keyword3">assume</span> asm6<span class="delimiter">:</span> <span class="string">&quot;pn_V x = (Graph.E (pn_c x))<span class="hidden">&#8679;</span><sup>*</sup> `` {s}&quot;</span> 
          <span class="keyword3">assume</span> asm7<span class="delimiter">:</span> <span class="string">&quot;c = pn_c x&quot;</span>
          <span class="keyword3">assume</span> asm8<span class="delimiter">:</span> <span class="string">&quot;psucc = pn_psucc x&quot;</span>
          <span class="keyword3">obtain</span> V sc pd  <span class="keyword2">where</span> obt<span class="delimiter">:</span> <span class="string">&quot;x = (|pn_c = c, pn_V = V,
            pn_succ = sc, pn_pred = pd,  pn_psucc = psucc, pn_s_node = True, pn_t_node = True|)),&quot;</span>
            <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases x<span class="delimiter">)</span> <span class="keyword1">using</span> asm3 asm4 asm7 asm8 <span class="keyword1">by</span> auto
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;read el s t = Some (|pn_c = c, pn_V = V, pn_succ = sc, pn_pred = pd, 
            pn_psucc = psucc, pn_s_node = True, pn_t_node = True|)),&quot;</span> <span class="keyword1">using</span> asm2 <span class="keyword1">by</span> simp
          <span class="keyword1">note</span> fct <span class="delimiter">=</span> read_correct1<span class="delimiter">[</span>OF this<span class="delimiter">]</span>
          
          <span class="keyword1">have</span> <span class="string">&quot;!!u. set ((pn_succ x) u) = Graph.E (pn_c x) `` {u} &and; distinct ((pn_succ x) u)&quot;</span>
            <span class="keyword1">using</span> fct obt <span class="keyword1">by</span> simp
          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;!!u. set ((pn_pred x) u) = (Graph.E (pn_c x))&macr; `` {u} &and; 
            distinct ((pn_pred x) u)&quot;</span> <span class="keyword1">using</span> fct obt <span class="keyword1">by</span> simp
          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;(el, pn_c x) &isin; ln_rel&quot;</span> <span class="keyword1">using</span> fct asm7 <span class="keyword1">by</span> simp
          <span class="keyword1">moreover</span> <span class="keyword1">{</span>
            <span class="keyword1">{</span>
              <span class="keyword1">{</span>
                <span class="keyword1">have</span> <span class="string">&quot;Graph.V c &sube; ((Graph.E c))<span class="hidden">&#8679;</span><sup>*</sup> `` {s}&quot;</span> <span class="keyword1">using</span> asm6 obt fct <span class="keyword1">by</span> simp
                <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&forall;v&isin;(Graph.V c). Graph.isReachable c s v&quot;</span> 
                  <span class="keyword1">unfolding</span> Graph.connected_def <span class="keyword1">using</span> Graph.rtc_isPath<span class="delimiter">[</span>of s _ c<span class="delimiter">]</span> <span class="keyword1">by</span> auto
              <span class="keyword1">}</span>
              <span class="keyword1">moreover</span> <span class="keyword1">{</span>
                <span class="keyword1">have</span> <span class="string">&quot;Graph.V c &sube; ((Graph.E c)&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t}&quot;</span> <span class="keyword1">using</span> asm5 asm6 obt fct <span class="keyword1">by</span> simp
                <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&forall;v&isin;(Graph.V c). Graph.isReachable c v t&quot;</span>
                  <span class="keyword1">unfolding</span> Graph.connected_def <span class="keyword1">using</span> Graph.rtci_isPath <span class="keyword1">by</span> fastforce
              <span class="keyword1">}</span>
              <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;&forall;v&isin;(Graph.V c). Graph.isReachable c s v &and; Graph.isReachable c v t&quot;</span> <span class="keyword1">by</span> simp
            <span class="keyword1">}</span>
            <span class="keyword1">moreover</span> <span class="keyword1">{</span>
              <span class="keyword1">have</span> <span class="string">&quot;finite (Graph.V c)&quot;</span> <span class="keyword2">and</span> <span class="string">&quot;s &isin; (Graph.V c)&quot;</span> <span class="keyword1">using</span> fct obt <span class="keyword1">by</span> auto
              <span class="keyword1">note</span> Graph.reachable_ss_V<span class="delimiter">[</span>OF <span class="alt_string">`s &isin; (Graph.V c)`</span><span class="delimiter">]</span>
              <span class="keyword1">note</span> finite_subset<span class="delimiter">[</span>OF this <span class="alt_string">`finite (Graph.V c)`</span><span class="delimiter">]</span>
            <span class="keyword1">}</span>
            <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;Network (pn_c x) s t&quot;</span> <span class="keyword1">unfolding</span> Network_def <span class="keyword1">using</span> asm1 fct asm7 
              <span class="keyword1">by</span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> Graph.E_def<span class="delimiter">)</span>
          <span class="keyword1">}</span>
          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;&forall;u.(set (pn_psucc x u) =
            Graph.E (pn_c x) `` {u} &cup; (Graph.E (pn_c x))&macr; `` {u})&quot;</span> <span class="keyword1">using</span> fct obt <span class="keyword1">by</span> simp
          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;&forall;u. distinct (pn_psucc x u)&quot;</span> <span class="keyword1">using</span> fct obt <span class="keyword1">by</span> simp
          <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="string">&quot;(el, pn_c x) &isin; ln_rel&quot;</span> <span class="keyword2">and</span> <span class="string">&quot;Network (pn_c x) s t&quot;</span> <span class="keyword2">and</span>
            <span class="string">&quot;!!u. set (pn_psucc x u) = Graph.E (pn_c x) `` {u} &cup; (Graph.E (pn_c x))&macr; `` {u}&quot;</span> <span class="keyword2">and</span>
            <span class="string">&quot;!!u. distinct (pn_psucc x u)&quot;</span> <span class="keyword1">by</span> auto
        <span class="keyword1">}</span>
      <span class="keyword1">qed</span>
  
  <span class="keyword1">lemma</span> checkNet_pre_correct2_aux<span class="delimiter">:</span> 
    <span class="keyword2">assumes</span> asm1<span class="delimiter">:</span> <span class="string">&quot;s &ne; t&quot;</span>
    <span class="keyword2">assumes</span> asm2<span class="delimiter">:</span> <span class="string">&quot;read el s t = Some x&quot;</span> 
    <span class="keyword2">assumes</span> asm3<span class="delimiter">:</span> <span class="string">&quot;&forall;u. set (pn_succ x u) = Graph.E (pn_c x) `` {u} &and; distinct (pn_succ x u)&quot;</span>
    <span class="keyword2">assumes</span> asm4<span class="delimiter">:</span> <span class="string">&quot;&forall;u. set (pn_pred x u) = (Graph.E (pn_c x))&macr; `` {u} &and; distinct (pn_pred x u)&quot;</span>
    <span class="keyword2">assumes</span> asm5<span class="delimiter">:</span> <span class="string">&quot;pn_V x = (Graph.E (pn_c x))<span class="hidden">&#8679;</span><sup>*</sup> `` {s} --&gt; (Graph.E (pn_c x))<span class="hidden">&#8679;</span><sup>*</sup> `` {s} &ne;
      ((Graph.E (pn_c x))&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t}&quot;</span>
    <span class="keyword2">assumes</span> asm6<span class="delimiter">:</span> <span class="string">&quot;pn_s_node x&quot;</span>
    <span class="keyword2">assumes</span> asm7<span class="delimiter">:</span> <span class="string">&quot;pn_t_node x&quot;</span>
    <span class="keyword2">assumes</span> asm8<span class="delimiter">:</span> <span class="string">&quot;ln_invar el&quot;</span>
    <span class="keyword2">assumes</span> asm9<span class="delimiter">:</span> <span class="string">&quot;Network (ln_&alpha; el) s t&quot;</span>
    <span class="keyword2">shows</span> <span class="string">&quot;False&quot;</span>
    <span class="keyword1">proof</span> -          
      <span class="keyword3">obtain</span> c V sc pd ps  <span class="keyword2">where</span> obt<span class="delimiter">:</span> <span class="string">&quot;x = (|pn_c = c, pn_V = V, pn_succ = sc, pn_pred = pd, 
        pn_psucc = ps, pn_s_node = True, pn_t_node = True|)),&quot;</span>
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases x<span class="delimiter">)</span> <span class="keyword1">using</span> asm3 asm4 asm6 asm7 <span class="keyword1">by</span> auto
      <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;read el s t = Some (|pn_c = c, pn_V = V, pn_succ = sc, pn_pred = pd, 
        pn_psucc = ps, pn_s_node = True, pn_t_node = True|)),&quot;</span> <span class="keyword1">using</span> asm2 <span class="keyword1">by</span> simp
      <span class="keyword1">note</span> fct <span class="delimiter">=</span> read_correct1<span class="delimiter">[</span>OF this<span class="delimiter">]</span>
      
      <span class="keyword1">have</span> <span class="string">&quot;pn_V x &ne; (Graph.E (pn_c x))<span class="hidden">&#8679;</span><sup>*</sup> `` {s} &or; (pn_V x = (Graph.E (pn_c x))<span class="hidden">&#8679;</span><sup>*</sup> `` {s} &and;
        ((Graph.E (pn_c x))&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t} &ne; (Graph.E (pn_c x))<span class="hidden">&#8679;</span><sup>*</sup> `` {s})&quot;</span> <span class="keyword1">using</span> asm5 <span class="keyword1">by</span> blast
      <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span>
        <span class="keyword1">proof</span>
          <span class="keyword3">assume</span> <span class="string">&quot;pn_V x = (Graph.E (pn_c x))<span class="hidden">&#8679;</span><sup>*</sup> `` {s} &and; 
            ((Graph.E (pn_c x))&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t} &ne; (Graph.E (pn_c x))<span class="hidden">&#8679;</span><sup>*</sup> `` {s}&quot;</span>
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not;(Graph.V c &sube; ((Graph.E c)&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t}) &or; &not;(((Graph.E c)&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t} &sube; Graph.V c)&quot;</span>
            <span class="keyword1">using</span> asm5  obt fct <span class="keyword1">by</span> simp
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&exist;v&isin;(Graph.V c). &not;Graph.isReachable c v t&quot;</span>
            <span class="keyword1">proof</span>
              <span class="keyword3">assume</span> <span class="string">&quot;&not;(((Graph.E c)&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t} &sube; Graph.V c)&quot;</span>
              <span class="keyword1">then</span> <span class="keyword3">obtain</span> x <span class="keyword2">where</span> o1<span class="delimiter">:</span><span class="string">&quot;x &isin; ((Graph.E c)&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t} &and; x &notin; Graph.V c&quot;</span> <span class="keyword1">by</span> blast
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&exist;p. Graph.isPath c x p t&quot;</span> <span class="keyword1">using</span> Graph.rtci_isPath <span class="keyword1">by</span> auto
              <span class="keyword1">then</span> <span class="keyword3">obtain</span> p <span class="keyword2">where</span> <span class="string">&quot;Graph.isPath c x p t&quot;</span> <span class="keyword1">by</span> blast
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;x &isin; Graph.V c&quot;</span>
                <span class="keyword1">proof</span> <span class="delimiter">(</span>cases <span class="string">&quot;p = []&quot;</span><span class="delimiter">)</span>
                  <span class="keyword3">case</span> True
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;x = t&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`Graph.isPath c x p t`</span> Graph.isPath.simps<span class="delimiter">(</span>1<span class="delimiter">)</span> <span class="keyword1">by</span> auto
                    <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> fct <span class="keyword1">by</span> auto
                <span class="keyword1">next</span>
                  <span class="keyword3">case</span> False
                    <span class="keyword1">then</span> <span class="keyword3">obtain</span> p1 ps <span class="keyword2">where</span> <span class="string">&quot;p = p1 # ps&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>meson neq_Nil_conv<span class="delimiter">)</span>
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;Graph.isPath c x (p1 # ps) t&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`Graph.isPath c x p t`</span> <span class="keyword1">by</span> auto
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;fst p1 = x &and; c p1 &ne; 0&quot;</span> <span class="keyword1">using</span> Graph.isPath_head<span class="delimiter">[</span>of c x p1 ps t<span class="delimiter">]</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> Graph.E_def<span class="delimiter">)</span>
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&exist;v. c (x, v) &ne; 0&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis prod.collapse<span class="delimiter">)</span>
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;x &isin; Graph.V c&quot;</span> <span class="keyword1">unfolding</span> Graph.V_def Graph.E_def <span class="keyword1">by</span> auto
                    <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> simp
                <span class="keyword1">qed</span>
              <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> o1 <span class="keyword1">by</span> auto
            <span class="keyword1">next</span>
              <span class="keyword3">assume</span> <span class="string">&quot;&not;(Graph.V c &sube; ((Graph.E c)&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t})&quot;</span>
              <span class="keyword1">then</span> <span class="keyword3">obtain</span> x <span class="keyword2">where</span> o1<span class="delimiter">:</span><span class="string">&quot;x &notin; ((Graph.E c)&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t} &and; x &isin; Graph.V c&quot;</span> <span class="keyword1">by</span> blast
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(x , t) &notin; (Graph.E c)<span class="hidden">&#8679;</span><sup>*</sup>&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>meson Image_singleton_iff rtrancl_converseI<span class="delimiter">)</span>
              <span class="keyword1">have</span> <span class="string">&quot;&forall;p. &not;Graph.isPath c x p t&quot;</span>
                <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
                  <span class="keyword3">assume</span> <span class="string">&quot;&not;?thesis&quot;</span>
                  <span class="keyword1">then</span> <span class="keyword3">obtain</span> p <span class="keyword2">where</span> <span class="string">&quot;Graph.isPath c x p t&quot;</span> <span class="keyword1">by</span> blast
                  <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> Graph.isPath_rtc <span class="alt_string">`(x , t) &notin; (Graph.E c)<span class="hidden">&#8679;</span><sup>*</sup>`</span> <span class="keyword1">by</span> auto
                <span class="keyword1">qed</span>
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not;Graph.isReachable c x t&quot;</span> <span class="keyword1">unfolding</span> Graph.connected_def <span class="keyword1">by</span> auto
              <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> o1 <span class="keyword1">by</span> auto
            <span class="keyword1">qed</span>
          <span class="keyword1">moreover</span> <span class="keyword1">{</span>
            <span class="keyword1">have</span> <span class="string">&quot;(el, c) &isin; ln_rel&quot;</span> <span class="keyword1">using</span> fct obt <span class="keyword1">by</span> simp
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;c = ln_&alpha; el&quot;</span> <span class="keyword1">unfolding</span> ln_rel_def br_def <span class="keyword1">by</span> auto
          <span class="keyword1">}</span>
          <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;&not;Network (ln_&alpha; el) s t&quot;</span> <span class="keyword1">unfolding</span> Network_def <span class="keyword1">by</span> auto
          <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> asm9 <span class="keyword1">by</span> blast
        <span class="keyword1">next</span>
          <span class="keyword3">assume</span> <span class="string">&quot;pn_V x &ne; (Graph.E (pn_c x))<span class="hidden">&#8679;</span><sup>*</sup> `` {s}&quot;</span>
          
          
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not;(Graph.V c &sube; (Graph.E c)<span class="hidden">&#8679;</span><sup>*</sup> `` {s}) &or; &not;((Graph.E c)<span class="hidden">&#8679;</span><sup>*</sup> `` {s} &sube; Graph.V c)&quot;</span>
            <span class="keyword1">using</span> asm5  obt fct <span class="keyword1">by</span> simp
          <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&exist;v&isin;(Graph.V c). &not;Graph.isReachable c s v&quot;</span>
            <span class="keyword1">proof</span>
              <span class="keyword3">assume</span> <span class="string">&quot;&not;((Graph.E c)<span class="hidden">&#8679;</span><sup>*</sup> `` {s} &sube; Graph.V c)&quot;</span>
              <span class="keyword1">then</span> <span class="keyword3">obtain</span> x <span class="keyword2">where</span> o1<span class="delimiter">:</span><span class="string">&quot;x &isin; (Graph.E c)<span class="hidden">&#8679;</span><sup>*</sup> `` {s} &and; x &notin; Graph.V c&quot;</span> <span class="keyword1">by</span> blast
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&exist;p. Graph.isPath c s p x&quot;</span> <span class="keyword1">using</span> Graph.rtc_isPath <span class="keyword1">by</span> auto
              <span class="keyword1">then</span> <span class="keyword3">obtain</span> p <span class="keyword2">where</span> <span class="string">&quot;Graph.isPath c s p x&quot;</span> <span class="keyword1">by</span> blast
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;x &isin; Graph.V c&quot;</span>
                <span class="keyword1">proof</span> <span class="delimiter">(</span>cases <span class="string">&quot;p = []&quot;</span><span class="delimiter">)</span>
                  <span class="keyword3">case</span> True
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;x = s&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`Graph.isPath c s p x`</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> Graph.isPath.simps<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> fct <span class="keyword1">by</span> auto
                <span class="keyword1">next</span>
                  <span class="keyword3">case</span> False
                    <span class="keyword1">then</span> <span class="keyword3">obtain</span> p1 ps <span class="keyword2">where</span> <span class="string">&quot;p = ps @ [p1]&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis append_butlast_last_id<span class="delimiter">)</span>
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;Graph.isPath c s (ps @ [p1]) x&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`Graph.isPath c s p x`</span> <span class="keyword1">by</span> auto
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;snd p1 = x &and; c p1 &ne; 0&quot;</span> <span class="keyword1">using</span> Graph.isPath_tail<span class="delimiter">[</span>of c s ps p1 x<span class="delimiter">]</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> Graph.E_def<span class="delimiter">)</span>
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&exist;v. c (v, x) &ne; 0&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis prod.collapse<span class="delimiter">)</span>
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;x &isin; Graph.V c&quot;</span> <span class="keyword1">unfolding</span> Graph.V_def Graph.E_def <span class="keyword1">by</span> auto
                    <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> simp
                <span class="keyword1">qed</span>
              <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> o1 <span class="keyword1">by</span> auto
            <span class="keyword1">next</span>
              <span class="keyword3">assume</span> <span class="string">&quot;&not;(Graph.V c &sube; (Graph.E c)<span class="hidden">&#8679;</span><sup>*</sup> `` {s})&quot;</span>
              <span class="keyword1">then</span> <span class="keyword3">obtain</span> x <span class="keyword2">where</span> o1<span class="delimiter">:</span><span class="string">&quot;x &notin; (Graph.E c)<span class="hidden">&#8679;</span><sup>*</sup> `` {s} &and; x &isin; Graph.V c&quot;</span> <span class="keyword1">by</span> blast
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(s , x) &notin; (Graph.E c)<span class="hidden">&#8679;</span><sup>*</sup>&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>meson Image_singleton_iff rtrancl_converseI<span class="delimiter">)</span>
              <span class="keyword1">have</span> <span class="string">&quot;&forall;p. &not;Graph.isPath c s p x&quot;</span>
                <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
                  <span class="keyword3">assume</span> <span class="string">&quot;&not;?thesis&quot;</span>
                  <span class="keyword1">then</span> <span class="keyword3">obtain</span> p <span class="keyword2">where</span> <span class="string">&quot;Graph.isPath c s p x&quot;</span> <span class="keyword1">by</span> blast
                  <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> Graph.isPath_rtc <span class="alt_string">`(s, x) &notin; (Graph.E c)<span class="hidden">&#8679;</span><sup>*</sup>`</span> <span class="keyword1">by</span> auto
                <span class="keyword1">qed</span>
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not;Graph.isReachable c s x&quot;</span> <span class="keyword1">unfolding</span> Graph.connected_def <span class="keyword1">by</span> auto
              <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> o1 <span class="keyword1">by</span> auto
            <span class="keyword1">qed</span>
          <span class="keyword1">moreover</span> <span class="keyword1">{</span>
            <span class="keyword1">have</span> <span class="string">&quot;(el, c) &isin; ln_rel&quot;</span> <span class="keyword1">using</span> fct obt <span class="keyword1">by</span> simp
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;c = ln_&alpha; el&quot;</span> <span class="keyword1">unfolding</span> ln_rel_def br_def <span class="keyword1">by</span> auto
          <span class="keyword1">}</span>
          <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;&not;Network (ln_&alpha; el) s t&quot;</span> <span class="keyword1">unfolding</span> Network_def <span class="keyword1">by</span> auto
          <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> asm9 <span class="keyword1">by</span> blast
        <span class="keyword1">qed</span>
    <span class="keyword1">qed</span>

  <span class="keyword1">lemma</span> checkNet_pre_correct2<span class="delimiter">:</span>
    <span class="string">&quot;checkNet el s t &le; SPEC (&lambda;r. r = None --&gt; &not;ln_invar el &or; &not;Network (ln_&alpha; el) s t)&quot;</span>
    <span class="keyword1">unfolding</span> checkNet_def reachable_spec_def reaching_spec_def
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>refine_vcg<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>clarsimp_all<span class="delimiter">)</span> 
    <span class="keyword1">proof</span> -
      <span class="keyword1">{</span>
        <span class="keyword3">assume</span> <span class="string">&quot;s = t&quot;</span> <span class="keyword2">and</span> <span class="string">&quot;ln_invar el&quot;</span> <span class="keyword2">and</span> <span class="string">&quot;Network (ln_&alpha; el) t t&quot;</span>
        <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> Network_def <span class="keyword1">by</span> auto
      <span class="keyword1">}</span>
      <span class="keyword1">next</span> <span class="keyword1">{</span>
        <span class="keyword3">assume</span> <span class="string">&quot;s &ne; t&quot;</span> <span class="keyword2">and</span> <span class="string">&quot;read el s t = None&quot;</span> <span class="keyword2">and</span> <span class="string">&quot;ln_invar el&quot;</span> <span class="keyword2">and</span> <span class="string">&quot;Network (ln_&alpha; el) s t&quot;</span>
        <span class="keyword1">note</span> read_correct2<span class="delimiter">[</span>OF <span class="alt_string">`read el s t = None`</span><span class="delimiter">]</span>
        <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span>
          <span class="keyword1">proof</span>
            <span class="keyword3">assume</span> <span class="string">&quot;&not;ln_invar el&quot;</span>
            <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> <span class="alt_string">`ln_invar el`</span> <span class="keyword1">by</span> blast
          <span class="keyword1">next</span>
            <span class="keyword3">assume</span> asm<span class="delimiter">:</span> <span class="string">&quot;(&exist;u v c. (u, v, c) &isin; set el &and; &not;(c &gt; 0)) 
            &or; (&exist;u c. (u, u, c) &isin; set el &and; c&ne;0) &or; (&exist;u c. (u, s, c) &isin; set el &and; c&ne;0) &or;
              (&exist;u c. (t, u, c) &isin; set el &and; c&ne;0) &or; (&exist;u v c1 c2. (u, v, c1) &isin; set el &and;
              (v, u, c2) &isin; set el &and; c1&ne;0 &and; c2&ne;0)&quot;</span>
            
            <span class="keyword1">moreover</span> <span class="keyword1">{</span>
              <span class="keyword3">assume</span> A<span class="delimiter">:</span> <span class="string">&quot;(&exist;u v c. (u, v, c) &isin; set el &and; &not;(c&gt;0))&quot;</span>
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not;ln_invar el&quot;</span> <span class="keyword1">using</span> not_less <span class="keyword1">by</span> <span class="delimiter">(</span>fastforce simp<span class="delimiter">:</span> ln_invar_def<span class="delimiter">)</span>
              <span class="keyword1">with</span> <span class="cartouche">&#8249;ln_invar el&#8250;</span> <span class="keyword1">have</span> False <span class="keyword1">by</span> simp
            <span class="keyword1">}</span>
            <span class="keyword1">moreover</span> <span class="keyword1">{</span>
              <span class="keyword3">assume</span> <span class="string">&quot;(&exist;u c. (u, u, c) &isin; set el &and; c&ne;0)&quot;</span>
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&exist; u. ln_&alpha; el (u, u) &ne; 0&quot;</span> <span class="keyword1">unfolding</span> ln_&alpha;_def <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto split<span class="delimiter">:</span>if_splits<span class="delimiter">)</span>
                <span class="keyword1">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>mono_tags<span class="delimiter">,</span> lifting<span class="delimiter">)</span> tfl_some<span class="delimiter">)</span>
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`Network (ln_&alpha; el) s t`</span> <span class="keyword1">unfolding</span> Network_def <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> Graph.E_def<span class="delimiter">)</span>
            <span class="keyword1">}</span>
            <span class="keyword1">moreover</span> <span class="keyword1">{</span>
              <span class="keyword3">assume</span> <span class="string">&quot;(&exist;u c. (u, s, c) &isin; set el &and; c&ne;0)&quot;</span>
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&exist; u. ln_&alpha; el (u, s) &ne; 0&quot;</span> <span class="keyword1">unfolding</span> ln_&alpha;_def <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto split<span class="delimiter">:</span>if_splits<span class="delimiter">)</span>
                <span class="keyword1">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>mono_tags<span class="delimiter">,</span> lifting<span class="delimiter">)</span> tfl_some<span class="delimiter">)</span>
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`Network (ln_&alpha; el) s t`</span> <span class="keyword1">unfolding</span> Network_def <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> Graph.E_def<span class="delimiter">)</span>
            <span class="keyword1">}</span>
            <span class="keyword1">moreover</span> <span class="keyword1">{</span>
              <span class="keyword3">assume</span> <span class="string">&quot;(&exist;u c. (t, u, c) &isin; set el &and; c&ne;0)&quot;</span>
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&exist; u. ln_&alpha; el (t, u) &ne; 0&quot;</span> <span class="keyword1">unfolding</span> ln_&alpha;_def <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto split<span class="delimiter">:</span>if_splits<span class="delimiter">)</span>
                <span class="keyword1">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>mono_tags<span class="delimiter">,</span> lifting<span class="delimiter">)</span> tfl_some<span class="delimiter">)</span>
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`Network (ln_&alpha; el) s t`</span> <span class="keyword1">unfolding</span> Network_def <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> Graph.E_def<span class="delimiter">)</span>
            <span class="keyword1">}</span>
            <span class="keyword1">moreover</span> <span class="keyword1">{</span>
              <span class="keyword3">assume</span> <span class="string">&quot;(&exist;u v c1 c2. (u, v, c1) &isin; set el &and; (v, u, c2) &isin; set el &and; c1&ne;0 &and; c2&ne;0)&quot;</span>
              <span class="keyword1">then</span> <span class="keyword3">obtain</span> u v c1 c2 <span class="keyword2">where</span> o1<span class="delimiter">:</span> <span class="string">&quot;(u, v, c1) &isin; set el &and; (v, u, c2) &isin; set el 
                &and; c1&ne;0 &and; c2&ne;0&quot;</span> <span class="keyword1">by</span> blast
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;ln_&alpha; el (u, v) &ne; 0&quot;</span> <span class="keyword1">unfolding</span> ln_&alpha;_def
                <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto split<span class="delimiter">:</span>if_splits<span class="delimiter">)</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>mono_tags<span class="delimiter">,</span> lifting<span class="delimiter">)</span> tfl_some<span class="delimiter">)</span>
              <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;ln_&alpha; el (v, u) &ne; 0&quot;</span> <span class="keyword1">unfolding</span> ln_&alpha;_def <span class="keyword1">using</span> o1 
                <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto split<span class="delimiter">:</span>if_splits<span class="delimiter">)</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>mono_tags<span class="delimiter">,</span> lifting<span class="delimiter">)</span> tfl_some<span class="delimiter">)</span>
              <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;&not; (&forall;u v. (ln_&alpha; el) (u, v) &ne; 0 --&gt; (ln_&alpha; el) (v, u) = 0)&quot;</span> <span class="keyword1">by</span> auto
              <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> <span class="alt_string">`Network (ln_&alpha; el) s t`</span> <span class="keyword1">unfolding</span> Network_def <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> Graph.E_def<span class="delimiter">)</span>
            <span class="keyword1">}</span>
            <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">by</span> force
          <span class="keyword1">qed</span>
      <span class="keyword1">}</span>
      <span class="keyword1">next</span> <span class="keyword1">{</span>
        <span class="keyword3">fix</span> x
        <span class="keyword3">assume</span> asm1<span class="delimiter">:</span> <span class="string">&quot;s &ne; t&quot;</span>
        <span class="keyword3">assume</span> asm2<span class="delimiter">:</span> <span class="string">&quot;read el s t = Some x&quot;</span>
        <span class="keyword3">assume</span> asm3<span class="delimiter">:</span> <span class="string">&quot;pn_s_node x&quot;</span>
        <span class="keyword3">assume</span> asm4<span class="delimiter">:</span> <span class="string">&quot;pn_t_node x&quot;</span>
        <span class="keyword3">obtain</span> c V sc pd psucc  <span class="keyword2">where</span> obt<span class="delimiter">:</span> <span class="string">&quot;x = (|pn_c = c, pn_V = V,
          pn_succ = sc, pn_pred = pd,  pn_psucc = psucc, pn_s_node = True, pn_t_node = True|)),&quot;</span>
          <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases x<span class="delimiter">)</span> <span class="keyword1">using</span> asm3 asm4 <span class="keyword1">by</span> auto
        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;read el s t = Some (|pn_c = c, pn_V = V, pn_succ = sc, pn_pred = pd, 
          pn_psucc = psucc, pn_s_node = True, pn_t_node = True|)),&quot;</span> <span class="keyword1">using</span> asm2 <span class="keyword1">by</span> simp
        <span class="keyword1">note</span> fct <span class="delimiter">=</span> read_correct1<span class="delimiter">[</span>OF this<span class="delimiter">]</span>
        
        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;finite (Graph.V c)&quot;</span> <span class="keyword1">by</span> blast
        <span class="keyword1">have</span> <span class="string">&quot;Graph.E c &sube; (Graph.V c) &times; (Graph.V c)&quot;</span> <span class="keyword1">unfolding</span> Graph.V_def <span class="keyword1">by</span> auto
        <span class="keyword1">from</span> finite_subset<span class="delimiter">[</span>OF this<span class="delimiter">]</span> <span class="keyword1">have</span> <span class="string">&quot;finite (Graph.E (pn_c x))&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> obt<span class="delimiter">)</span>
        <span class="keyword1">then</span> <span class="keyword3">show</span>  <span class="string">&quot;finite ((Graph.E (pn_c x))<span class="hidden">&#8679;</span><sup>*</sup> `` {s})&quot;</span> 
          <span class="keyword2">and</span> <span class="string">&quot;finite (((Graph.E (pn_c x))&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t})&quot;</span>  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp add<span class="delimiter">:</span> finite_rtrancl_Image<span class="delimiter">)</span>
      <span class="keyword1">}</span>
      <span class="keyword1">{</span>
        <span class="keyword3">fix</span> x
        <span class="keyword3">assume</span> asm1<span class="delimiter">:</span> <span class="string">&quot;s &ne; t&quot;</span>
        <span class="keyword3">assume</span> asm2<span class="delimiter">:</span> <span class="string">&quot;read el s t = Some x&quot;</span>
        <span class="keyword3">assume</span> asm3<span class="delimiter">:</span> <span class="string">&quot;finite ((Graph.E (pn_c x))<span class="hidden">&#8679;</span><sup>*</sup> `` {s})&quot;</span>
        <span class="keyword3">assume</span> asm4<span class="delimiter">:</span> <span class="string">&quot;finite (((Graph.E (pn_c x))&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t})&quot;</span>
        <span class="keyword3">assume</span> asm5<span class="delimiter">:</span> <span class="string">&quot;pn_s_node x&quot;</span>
        <span class="keyword3">assume</span> asm6<span class="delimiter">:</span> <span class="string">&quot;pn_t_node x&quot;</span> 
        <span class="keyword3">obtain</span> c V sc pd psucc  <span class="keyword2">where</span> obt<span class="delimiter">:</span> <span class="string">&quot;x = (|pn_c = c, pn_V = V,
          pn_succ = sc, pn_pred = pd,  pn_psucc = psucc, pn_s_node = True, pn_t_node = True|)),&quot;</span>
          <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases x<span class="delimiter">)</span> <span class="keyword1">using</span> asm5 asm6 <span class="keyword1">by</span> auto
        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;read el s t = Some (|pn_c = c, pn_V = V, pn_succ = sc, pn_pred = pd, 
          pn_psucc = psucc, pn_s_node = True, pn_t_node = True|)),&quot;</span> <span class="keyword1">using</span> asm2 <span class="keyword1">by</span> simp
        <span class="keyword1">note</span> fct <span class="delimiter">=</span> read_correct1<span class="delimiter">[</span>OF this<span class="delimiter">]</span>
        
        <span class="keyword1">have</span> <span class="string">&quot;!!u. set ((pn_succ x) u) = Graph.E (pn_c x) `` {u} &and; distinct ((pn_succ x) u)&quot;</span>
          <span class="keyword1">using</span> fct obt <span class="keyword1">by</span> simp
        <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;!!u. set ((pn_pred x) u) = (Graph.E (pn_c x))&macr; `` {u} &and; 
          distinct ((pn_pred x) u)&quot;</span> <span class="keyword1">using</span> fct obt <span class="keyword1">by</span> simp
        <span class="keyword1">ultimately</span> <span class="keyword3">show</span>  <span class="string">&quot;!!u. set ((pn_succ x) u) = Graph.E (pn_c x) `` {u}&quot;</span> <span class="keyword2">and</span> 
          <span class="string">&quot;!!u. distinct ((pn_succ x) u)&quot;</span> <span class="keyword2">and</span> <span class="string">&quot;!!u. set ((pn_pred x) u) = (Graph.E (pn_c x))&macr; `` {u}&quot;</span>
          <span class="keyword2">and</span>  <span class="string">&quot;!!u.  distinct ((pn_pred x) u)&quot;</span> <span class="keyword1">by</span> auto 
      <span class="keyword1">}</span>
      <span class="keyword1">next</span> <span class="keyword1">{</span>
        <span class="keyword3">fix</span> x
        <span class="keyword3">assume</span> asm1<span class="delimiter">:</span> <span class="string">&quot;s &ne; t&quot;</span>
        <span class="keyword3">assume</span> asm2<span class="delimiter">:</span> <span class="string">&quot;read el s t = Some x&quot;</span>
        <span class="keyword3">assume</span> asm3<span class="delimiter">:</span> <span class="string">&quot;pn_s_node x --&gt; &not;pn_t_node x&quot;</span>
        <span class="keyword3">assume</span> asm4<span class="delimiter">:</span> <span class="string">&quot;ln_invar el&quot;</span>
        <span class="keyword3">assume</span> asm5<span class="delimiter">:</span> <span class="string">&quot;Network (ln_&alpha; el) s t&quot;</span>
        <span class="keyword3">obtain</span> c V sc pd ps s_node t_node <span class="keyword2">where</span> obt<span class="delimiter">:</span> <span class="string">&quot;x = (|pn_c = c, pn_V = V, pn_succ = sc, pn_pred = pd, 
          pn_psucc = ps, pn_s_node = s_node, pn_t_node = t_node|)),&quot;</span> <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>cases x<span class="delimiter">)</span> <span class="keyword1">by</span> auto 
        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;read el s t = Some (|pn_c = c, pn_V = V, pn_succ = sc, pn_pred = pd, 
          pn_psucc = ps, pn_s_node = s_node, pn_t_node = t_node|)),&quot;</span> <span class="keyword1">using</span> asm2 <span class="keyword1">by</span> simp
        <span class="keyword1">note</span> fct <span class="delimiter">=</span> read_correct1<span class="delimiter">[</span>OF this<span class="delimiter">]</span>
        
        <span class="keyword1">have</span> <span class="string">&quot;(el, c) &isin; ln_rel&quot;</span> <span class="keyword1">using</span> fct obt <span class="keyword1">by</span> simp
        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;c = ln_&alpha; el&quot;</span> <span class="keyword1">unfolding</span> ln_rel_def br_def <span class="keyword1">by</span> auto
        
        <span class="keyword1">have</span> <span class="string">&quot;&not;pn_s_node x &or; &not;pn_t_node x&quot;</span> <span class="keyword1">using</span> asm3 <span class="keyword1">by</span> auto 
        <span class="keyword1">then</span> <span class="keyword3">show</span> <span class="string">&quot;False&quot;</span>
          <span class="keyword1">proof</span>
            <span class="keyword3">assume</span> <span class="string">&quot;&not;pn_s_node x&quot;</span>
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not;s_node&quot;</span> <span class="keyword1">using</span> obt fct <span class="keyword1">by</span> auto
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;s &notin; Graph.V c&quot;</span> <span class="keyword1">using</span> fct <span class="keyword1">by</span> auto
            <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> <span class="alt_string">`c = ln_&alpha; el`</span> asm5 Network_def <span class="keyword1">by</span> auto
          <span class="keyword1">next</span>
            <span class="keyword3">assume</span> <span class="string">&quot;&not;pn_t_node x&quot;</span>
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not;t_node&quot;</span> <span class="keyword1">using</span> obt fct <span class="keyword1">by</span> auto
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;t &notin; Graph.V c&quot;</span> <span class="keyword1">using</span> fct <span class="keyword1">by</span> auto
            <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> <span class="alt_string">`c = ln_&alpha; el`</span> asm5 Network_def <span class="keyword1">by</span> auto
          <span class="keyword1">qed</span>
      <span class="keyword1">}</span>
      <span class="keyword1">next</span> <span class="keyword3">show</span> <span class="string">&quot;!!x. s &ne; t ==&gt;
         read el s t = Some x ==&gt;
         &forall;u. set (pn_succ x u) = Graph.E (pn_c x) `` {u} &and; distinct (pn_succ x u) ==&gt;
         &forall;u. set (pn_pred x u) = (Graph.E (pn_c x))&macr; `` {u} &and; distinct (pn_pred x u) ==&gt;
         pn_V x = (Graph.E (pn_c x))<span class="hidden">&#8679;</span><sup>*</sup> `` {s} --&gt; (Graph.E (pn_c x))<span class="hidden">&#8679;</span><sup>*</sup> `` {s} &ne; ((Graph.E (pn_c x))&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t} ==&gt;
         pn_s_node x ==&gt; pn_t_node x ==&gt; ln_invar el ==&gt; Network (ln_&alpha; el) s t ==&gt; False&quot;</span>
         <span class="keyword1">using</span> checkNet_pre_correct2_aux <span class="keyword1">by</span> blast
    <span class="keyword1">qed</span>

  <span class="keyword1">lemma</span> checkNet_correct&#39; <span class="delimiter">:</span> <span class="string">&quot;checkNet el s t &le; SPEC (&lambda; r. case r of 
      Some (c, psucc) =&gt;
        (el, c) &isin; ln_rel &and; Network c s t 
        &and; (&forall;u. set (psucc u) = Graph.E c``{u} &cup; (Graph.E c)&macr;``{u} &and; distinct (psucc u))
    | None =&gt; &not;ln_invar el &or; &not;Network (ln_&alpha; el) s t)&quot;</span>
    <span class="keyword1">using</span> checkNet_pre_correct1<span class="delimiter">[</span>of el s t<span class="delimiter">]</span> checkNet_pre_correct2<span class="delimiter">[</span>of el s t<span class="delimiter">]</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto split<span class="delimiter">:</span> option.splits simp<span class="delimiter">:</span> pw_le_iff refine_pw_simps<span class="delimiter">)</span>

  <span class="keyword1">lemma</span> checkNet_correct <span class="delimiter">:</span> <span class="string">&quot;checkNet el s t &le; SPEC (&lambda;r. case r of 
      Some (c, psucc) =&gt; (el, c) &isin; ln_rel &and; Network c s t &and; is_pred_succ psucc c
    | None =&gt; &not;ln_invar el &or; &not;Network (ln_&alpha; el) s t)&quot;</span>
    <span class="keyword1">using</span> checkNet_pre_correct1<span class="delimiter">[</span>of el s t<span class="delimiter">]</span> checkNet_pre_correct2<span class="delimiter">[</span>of el s t<span class="delimiter">]</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto split<span class="delimiter">:</span> option.splits simp<span class="delimiter">:</span> is_pred_succ_def pw_le_iff refine_pw_simps<span class="delimiter">)</span>

  <span class="keyword1">definition</span> <span class="string">&quot;graph_of pn s &equiv; (|
    g_V = UNIV,
    g_E = Graph.E (pn_c pn),
    g_V0 = {s}
  |)),&quot;</span>

  <span class="keyword1">definition</span> <span class="string">&quot;rev_graph_of pn s &equiv; (|
    g_V = UNIV,
    g_E = (Graph.E (pn_c pn))&macr;,
    g_V0 = {s}
  |)),&quot;</span>

  
  <span class="keyword1">definition</span> <span class="string">&quot;checkNet2 cc s t &equiv; do {
    if s = t then
      RETURN None
    else do {
      let rd = read cc s t;
      case rd of 
        None =&gt; RETURN None
      | Some x =&gt; do {                
          if pn_s_node x &and; pn_t_node x then
            do {
              ASSERT(finite ((Graph.E (pn_c x))<span class="hidden">&#8679;</span><sup>*</sup> `` {s}));
              ASSERT(finite (((Graph.E (pn_c x))&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t}));
              ASSERT(&forall;u. set ((pn_succ x) u) = Graph.E (pn_c x) `` {u} &and; distinct ((pn_succ x) u));
              ASSERT(&forall;u. set ((pn_pred x) u) = (Graph.E (pn_c x))&macr; `` {u} &and; distinct ((pn_pred x) u));
              
              let succ_s = (op_reachable (graph_of x s));
              let pred_t = (op_reachable (rev_graph_of x t));
              if (pn_V x) = succ_s &and; (pn_V x) = pred_t then
                RETURN (Some (pn_c x, pn_psucc x))
              else
                RETURN None
            }
          else
            RETURN None
        }
      }
    }&quot;</span>
    
  <span class="keyword1">lemma</span> checkNet2_correct<span class="delimiter">:</span> <span class="string">&quot;checkNet2 c s t &le; checkNet c s t&quot;</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule refine_IdD<span class="delimiter">)</span>
    <span class="keyword1">unfolding</span> checkNet_def checkNet2_def graph_of_def rev_graph_of_def reachable_spec_def reaching_spec_def
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>refine_rcg<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> refine_dref_type
    <span class="keyword1"><span class="improper">apply</span></span> auto
    <span class="keyword1"><span class="improper">done</span></span>
    
  <span class="keyword1">definition</span> <span class="string">&quot;graph_of_impl pn&#39; s &equiv; (|
    gi_V = &lambda;_. True,
    gi_E = succ_lookup (pn_succ&#39; pn&#39;),
    gi_V0 = [s]
  |)),&quot;</span>

  <span class="keyword1">definition</span> <span class="string">&quot;rev_graph_of_impl pn&#39; t &equiv; (|
    gi_V = &lambda;_. True,
    gi_E = succ_lookup (pn_pred&#39; pn&#39;),
    gi_V0 = [t]
  |)),&quot;</span>
    
  <span class="keyword1">definition</span> <span class="string">&quot;well_formed_pn x &equiv; 
    (&forall;u. set ((pn_succ x) u) = Graph.E (pn_c x) `` {u} &and; distinct ((pn_succ x) u))&quot;</span>
  
  <span class="keyword1">definition</span> <span class="string">&quot;rev_well_formed_pn x &equiv; 
    (&forall;u. set ((pn_pred x) u) = (Graph.E (pn_c x))&macr; `` {u} &and; distinct ((pn_pred x) u))&quot;</span>
    
  <span class="keyword1">lemma</span> id_slg_rel_alt_a<span class="delimiter">:</span> <span class="string">&quot;&lang;Id&rang;slg_rel 
    = { (s,E). &forall;u. distinct (s u) &and; set (s u) = E``{u} }&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp add<span class="delimiter">:</span> slg_rel_def br_def list_set_rel_def dest<span class="delimiter">:</span> fun_relD<span class="delimiter">)</span>  
    
  <span class="keyword1">lemma</span> graph_of_impl_correct<span class="delimiter">:</span> <span class="string">&quot;well_formed_pn pn ==&gt; (pn&#39;, pn) &isin; pnet_rel ==&gt;
    (graph_of_impl pn&#39; s, graph_of pn s) &isin; &lang;unit_rel,Id&rang;g_impl_rel_ext&quot;</span>
    <span class="keyword1">unfolding</span> pnet_rel_def graph_of_impl_def graph_of_def
      g_impl_rel_ext_def gen_g_impl_rel_ext_def
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> fun_set_rel_def br_def list_set_rel_def id_slg_rel_alt_a ahm_ld_def<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> well_formed_pn_def Graph.E_def pnet_&alpha;_def o_def ahm_correct<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">done</span></span>
    
  <span class="keyword1">lemma</span> rev_graph_of_impl_correct<span class="delimiter">:</span><span class="string">&quot;[|rev_well_formed_pn pn; (pn&#39;,pn)&isin;pnet_rel|] ==&gt; 
    (rev_graph_of_impl pn&#39; s, rev_graph_of pn s) &isin; &lang;unit_rel,Id&rang;g_impl_rel_ext&quot;</span>
    <span class="keyword1">unfolding</span> pnet_rel_def rev_graph_of_impl_def rev_graph_of_def
      g_impl_rel_ext_def gen_g_impl_rel_ext_def
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> fun_set_rel_def br_def list_set_rel_def id_slg_rel_alt_a ahm_ld_def<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> rev_well_formed_pn_def Graph.E_def pnet_&alpha;_def o_def ahm_correct<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">done</span></span>   
  
  <span class="keyword1">schematic_lemma</span> reachable_impl<span class="delimiter">:</span>
    <span class="keyword2">assumes</span> <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;finite ((g_E G)<span class="hidden">&#8679;</span><sup>*</sup> `` g_V0 G)&quot;</span> <span class="string">&quot;graph G&quot;</span>
    <span class="keyword2">assumes</span> <span class="delimiter">[</span>autoref_rules<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;(Gi,G)&isin;&lang;unit_rel,nat_rel&rang;g_impl_rel_ext&quot;</span>
    <span class="keyword2">shows</span> <span class="string">&quot;RETURN (?c::?&#39;c) &le; \&lt;Down&gt;?R (RETURN (op_reachable G))&quot;</span>  
    <span class="keyword1">by</span> autoref_monadic
  <span class="keyword1">concrete_definition</span> reachable_impl <span class="keyword2">uses</span> reachable_impl
  <span class="keyword1">thm</span> reachable_impl.refine

  <span class="keyword1">term</span> reachable_impl <span class="keyword1">term</span> pn_V&#39;
  <span class="keyword1">term</span> <span class="string">&quot;&lang;nat_rel&rang;dflt_ahs_rel&quot;</span>
  <span class="keyword1">term</span> ahs.rel

  <span class="keyword1">context</span> <span class="keyword2">begin</span>
    <span class="keyword1">interpretation</span> autoref_syn <span class="keyword1">.</span>

    <span class="keyword1">schematic_lemma</span> sets_eq_impl<span class="delimiter">:</span>
      <span class="keyword2">fixes</span> a b <span class="delimiter">::</span> <span class="string">&quot;nat set&quot;</span>
      <span class="keyword2">assumes</span> <span class="delimiter">[</span>autoref_rules<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;(ai,a) &isin; &lang;nat_rel&rang;ahs.rel&quot;</span>
      <span class="keyword2">assumes</span> <span class="delimiter">[</span>autoref_rules<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;(bi,b) &isin; &lang;nat_rel&rang;dflt_ahs_rel&quot;</span>
      <span class="keyword2">shows</span> <span class="string">&quot;(?c, (a ::: &lang;nat_rel&rang;ahs.rel) = (b ::: &lang;nat_rel&rang;dflt_ahs_rel )) &isin; bool_rel&quot;</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>autoref <span class="delimiter">(</span>keep_goal<span class="delimiter">)</span> <span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">done</span></span>
    <span class="keyword1">concrete_definition</span> sets_eq_impl <span class="keyword2">uses</span> sets_eq_impl  

  <span class="keyword2">end</span>
  
  <span class="keyword1">definition</span> <span class="string">&quot;net_&alpha; &equiv; (&lambda;(ci, psucci) . 
    ((the_default 0 o (ahm.&alpha; ci)), (the_default [] o (ahm.&alpha; psucci))))&quot;</span>

  <span class="keyword1">lemma</span> <span class="delimiter">[</span>code<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;net_&alpha; (ci, psucci) = (
    cap_lookup ci, succ_lookup psucci
    )&quot;</span>
    <span class="keyword1">unfolding</span> net_&alpha;_def <span class="keyword1">by</span> <span class="delimiter">(</span>auto split<span class="delimiter">:</span> option.splits simp<span class="delimiter">:</span> ahm.correct ahm_ld_def<span class="delimiter">)</span>

    
  <span class="comment">(*definition &quot;net_invar &equiv;  (&lambda;(ci, psucci) . ahm.invar ci &and; ahm.invar psucci)&quot;
  
  definition &quot;net_rel &equiv; br net_&alpha; net_invar&quot;*)</span>

  <span class="keyword1">definition</span> <span class="string">&quot;checkNet3 cc s t &equiv; do {
    if s = t then
      RETURN None
    else do {
      let rd = read&#39; cc s t;
      case rd of 
        None =&gt; RETURN None
      | Some x =&gt; do {                
          if pn_s_node&#39; x &and; pn_t_node&#39; x then
            do {
              ASSERT(finite ((Graph.E (pn_c (pnet_&alpha; x)))<span class="hidden">&#8679;</span><sup>*</sup> `` {s}));
              ASSERT(finite (((Graph.E (pn_c (pnet_&alpha; x)))&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {t}));
              ASSERT(&forall;u. set ((pn_succ (pnet_&alpha; x)) u) =
                Graph.E (pn_c (pnet_&alpha; x)) `` {u} &and; distinct ((pn_succ (pnet_&alpha; x)) u));
              ASSERT(&forall;u. set ((pn_pred (pnet_&alpha; x)) u) = 
                (Graph.E (pn_c (pnet_&alpha; x)))&macr; `` {u} &and; distinct ((pn_pred (pnet_&alpha; x)) u));
            
              let succ_s = (reachable_impl (graph_of_impl x s));
              let pred_t = (reachable_impl (rev_graph_of_impl x t));
              if (sets_eq_impl (pn_V&#39; x) succ_s) &and; (sets_eq_impl (pn_V&#39; x) pred_t) then
                RETURN (Some (net_&alpha; (pn_c&#39; x, pn_psucc&#39; x)))
              else
                RETURN None
            }
          else
            RETURN None
        }
      }
    }&quot;</span>     

    <span class="keyword1">thm</span> reachable_impl.refine

  <span class="keyword1">term</span> map2set_rel  
  <span class="keyword1">thm</span> sets_eq_impl.refine<span class="delimiter">[</span>simplified<span class="delimiter">]</span>

    
  <span class="keyword1">lemma</span> aux1<span class="delimiter">:</span> <span class="string">&quot;(x&#39;, x) &isin; pnet_rel ==&gt; (pn_V&#39; x&#39;, pn_V x) &isin; br ahs.&alpha; ahs.invar&quot;</span>
    <span class="keyword1">unfolding</span> pnet_rel_def br_def pnet_&alpha;_def <span class="keyword1">by</span> auto

  <span class="keyword1">lemma</span> <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;graph (graph_of pn s)&quot;</span>
    <span class="keyword1"><span class="improper">apply</span></span> unfold_locales
    <span class="keyword1">unfolding</span> graph_of_def
    <span class="keyword1">by</span> auto

  <span class="keyword1">lemma</span> <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;graph (rev_graph_of pn s)&quot;</span>
    <span class="keyword1"><span class="improper">apply</span></span> unfold_locales
    <span class="keyword1">unfolding</span> rev_graph_of_def
    <span class="keyword1">by</span> auto


  <span class="keyword1">context</span> <span class="keyword2">begin</span>
  <span class="keyword2">private</span> <span class="keyword1">lemma</span> sets_eq_impl_correct_aux1<span class="delimiter">:</span>
    <span class="keyword2">assumes</span> A<span class="delimiter">:</span> <span class="string">&quot;(pn&#39;, pn) &isin; pnet_rel&quot;</span>  
    <span class="keyword2">assumes</span> WF<span class="delimiter">:</span> <span class="string">&quot;well_formed_pn pn&quot;</span> 

    <span class="keyword2">assumes</span> F<span class="delimiter">:</span> <span class="string">&quot;finite ((Graph.E (pn_c (pnet_&alpha; pn&#39;)))<span class="hidden">&#8679;</span><sup>*</sup> `` {s})&quot;</span>
    <span class="keyword2">shows</span> <span class="string">&quot;sets_eq_impl (pn_V&#39; pn&#39;) (reachable_impl (graph_of_impl pn&#39; s))
      &lt;-&gt; pn_V pn = (g_E (graph_of pn s))<span class="hidden">&#8679;</span><sup>*</sup> `` g_V0 (graph_of pn s)&quot;</span>
  <span class="keyword1">proof</span> -
    <span class="keyword1">from</span> A <span class="keyword1">have</span> S1i<span class="delimiter">:</span> <span class="string">&quot;(pn_V&#39; pn&#39;, pn_V pn) &isin; br ahs.&alpha; ahs.invar&quot;</span>
      <span class="keyword1">unfolding</span> pnet_rel_def br_def pnet_&alpha;_def <span class="keyword1">by</span> auto

    <span class="keyword1">note</span> GI <span class="delimiter">=</span> graph_of_impl_correct<span class="delimiter">[</span>OF WF A<span class="delimiter">]</span>
    <span class="keyword1">have</span> G<span class="delimiter">:</span> <span class="string">&quot;graph (graph_of pn s)&quot;</span> <span class="keyword1">by</span> simp

    <span class="keyword1">have</span> F&#39;<span class="delimiter">:</span> <span class="string">&quot;finite ((g_E (graph_of pn s))<span class="hidden">&#8679;</span><sup>*</sup> `` g_V0 (graph_of pn s))&quot;</span>
      <span class="keyword1">using</span> F A <span class="keyword1">by</span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> graph_of_def pnet_&alpha;_def pnet_rel_def br_def<span class="delimiter">)</span>

    <span class="keyword1">note</span> S2i <span class="delimiter">=</span> reachable_impl.refine<span class="delimiter">[</span>simplified<span class="delimiter">,</span> OF F&#39; G GI<span class="delimiter">]</span>  

    <span class="keyword1">from</span> sets_eq_impl.refine<span class="delimiter">[</span>simplified<span class="delimiter">,</span> OF S1i S2i<span class="delimiter">]</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">.</span>
  <span class="keyword1">qed</span> 

  <span class="keyword2">private</span> <span class="keyword1">lemma</span> sets_eq_impl_correct_aux2<span class="delimiter">:</span>
    <span class="keyword2">assumes</span> A<span class="delimiter">:</span> <span class="string">&quot;(pn&#39;, pn) &isin; pnet_rel&quot;</span>  
    <span class="keyword2">assumes</span> WF<span class="delimiter">:</span> <span class="string">&quot;rev_well_formed_pn pn&quot;</span> 

    <span class="keyword2">assumes</span> F<span class="delimiter">:</span> <span class="string">&quot;finite (((Graph.E (pn_c (pnet_&alpha; pn&#39;)))&macr;)<span class="hidden">&#8679;</span><sup>*</sup> `` {s})&quot;</span>
    <span class="keyword2">shows</span> <span class="string">&quot;sets_eq_impl (pn_V&#39; pn&#39;) (reachable_impl (rev_graph_of_impl pn&#39; s))
      &lt;-&gt; pn_V pn = (g_E (rev_graph_of pn s))<span class="hidden">&#8679;</span><sup>*</sup> `` g_V0 (rev_graph_of pn s)&quot;</span>
  <span class="keyword1">proof</span> -
    <span class="keyword1">from</span> A <span class="keyword1">have</span> S1i<span class="delimiter">:</span> <span class="string">&quot;(pn_V&#39; pn&#39;, pn_V pn) &isin; br ahs.&alpha; ahs.invar&quot;</span>
      <span class="keyword1">unfolding</span> pnet_rel_def br_def pnet_&alpha;_def <span class="keyword1">by</span> auto

    <span class="keyword1">note</span> GI <span class="delimiter">=</span> rev_graph_of_impl_correct<span class="delimiter">[</span>OF WF A<span class="delimiter">]</span>
    <span class="keyword1">have</span> G<span class="delimiter">:</span> <span class="string">&quot;graph (rev_graph_of pn s)&quot;</span> <span class="keyword1">by</span> simp

    <span class="keyword1">have</span> F&#39;<span class="delimiter">:</span> <span class="string">&quot;finite ((g_E (rev_graph_of pn s))<span class="hidden">&#8679;</span><sup>*</sup> `` g_V0 (rev_graph_of pn s))&quot;</span>
      <span class="keyword1">using</span> F A <span class="keyword1">by</span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> rev_graph_of_def pnet_&alpha;_def pnet_rel_def br_def<span class="delimiter">)</span>

    <span class="keyword1">note</span> S2i <span class="delimiter">=</span> reachable_impl.refine<span class="delimiter">[</span>simplified<span class="delimiter">,</span> OF F&#39; G GI<span class="delimiter">]</span>  

    <span class="keyword1">from</span> sets_eq_impl.refine<span class="delimiter">[</span>simplified<span class="delimiter">,</span> OF S1i S2i<span class="delimiter">]</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">.</span>
  <span class="keyword1">qed</span> 



  <span class="keyword1">lemma</span> checkNet3_correct<span class="delimiter">:</span> <span class="string">&quot;checkNet3 el s t &le; checkNet2 el s t&quot;</span> 
    <span class="keyword1">unfolding</span> checkNet3_def checkNet2_def
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule refine_IdD<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>refine_rcg<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> clarsimp_all
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule introR<span class="delimiter">[</span><span class="keyword2">where</span> R<span class="delimiter">=</span><span class="string">&quot;&lang;pnet_rel&rang;option_rel&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="comment">(*apply (rule asm_rl [of &quot;(read&#39; el s t, read el s t) &isin; &lang;pnet_rel&rang;option_rel&quot;])*)</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> read&#39;_correct_alt<span class="delimiter">;</span> fail<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span><span class="delimiter">(</span>simp add<span class="delimiter">:</span> pnet_rel_def br_def pnet_&alpha;_def<span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span> <span class="delimiter">[</span>7<span class="delimiter">]</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>subst sets_eq_impl_correct_aux1<span class="delimiter">;</span> assumption<span class="delimiter">?</span><span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> well_formed_pn_def<span class="delimiter">)</span>
    
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>subst sets_eq_impl_correct_aux2<span class="delimiter">;</span> assumption<span class="delimiter">?</span><span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> rev_well_formed_pn_def<span class="delimiter">)</span>

    <span class="keyword1"><span class="improper">apply</span></span> simp

    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> net_&alpha;_def o_def pnet_&alpha;_def pnet_rel_def br_def<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">done</span></span>

  <span class="keyword2">end</span>  


  <span class="keyword1">schematic_lemma</span> checkNet4<span class="delimiter">:</span> <span class="string">&quot;RETURN ?c &le; checkNet3 el s t&quot;</span>
    <span class="keyword1">unfolding</span> checkNet3_def
    <span class="keyword1">by</span> <span class="delimiter">(</span>refine_transfer<span class="delimiter">)</span>
  <span class="keyword1">concrete_definition</span> checkNet4 <span class="keyword2">for</span> el s t <span class="keyword2">uses</span> checkNet4
    

  <span class="keyword1">lemma</span> checkNet4_correct<span class="delimiter">:</span> <span class="string">&quot;case checkNet4 el s t of 
      Some (c, psucc) =&gt; (el, c) &isin; ln_rel &and; Network c s t &and; is_pred_succ psucc c
    | None =&gt; &not;ln_invar el &or; &not;Network (ln_&alpha; el) s t&quot;</span>
  <span class="keyword1">proof</span> -  
    <span class="keyword1">note</span> checkNet4.refine 
    <span class="keyword1">also</span> <span class="keyword1">note</span> checkNet3_correct 
    <span class="keyword1">also</span> <span class="keyword1">note</span> checkNet2_correct
    <span class="keyword1">also</span> <span class="keyword1">note</span> checkNet_correct
    <span class="keyword1">finally</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">by</span> simp
  <span class="keyword1">qed</span>  

  <span class="keyword1">definition</span> prepareNet <span class="delimiter">::</span> <span class="string">&quot;edge_list =&gt; node =&gt; node =&gt; (capacity_impl graph &times; (node=&gt;node list) &times; nat) option&quot;</span>
  <span class="keyword2">where</span>
    <span class="string">&quot;prepareNet el s t &equiv; do {
      (c,psucc) \&lt;leftarrow&gt; checkNet4 el s t;
      let N = ln_N el;
      Some (c,psucc,N)
    }&quot;</span>

  <span class="keyword1">export_code</span> prepareNet <span class="keyword2">checking</span> SML  

  <span class="keyword1">lemma</span> prepareNet_correct<span class="delimiter">:</span> <span class="string">&quot;case (prepareNet el s t) of 
      Some (c, psucc,N) =&gt; (el, c) &isin; ln_rel &and; Network c s t &and; is_pred_succ psucc c &and; Graph.V c &sube; {0..&lt;N}
    | None =&gt; &not;ln_invar el &or; &not;Network (ln_&alpha; el) s t&quot;</span>
    <span class="keyword1">using</span> checkNet4_correct<span class="delimiter">[</span>of el s t<span class="delimiter">]</span> ln_N_correct<span class="delimiter">[</span>of el<span class="delimiter">]</span>
    <span class="keyword1">unfolding</span> prepareNet_def
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto split<span class="delimiter">:</span> Option.bind_split simp<span class="delimiter">:</span> ln_rel_def br_def<span class="delimiter">)</span>

<span class="keyword2">end</span>
</pre>

</div>
</body>
</html>
