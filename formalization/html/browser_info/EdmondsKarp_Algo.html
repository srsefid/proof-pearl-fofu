<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory EdmondsKarp_Algo (Isabelle2015: May 2015)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory EdmondsKarp_Algo</h1>

<span class="command">theory</span> <span class="name">EdmondsKarp_Algo</span><br/>
<span class="keyword">imports</span> <a href="FordFulkerson_Algo.html"><span class="name">FordFulkerson_Algo</span></a><br/>

</div>
<div class="source">
<pre><span class="keyword1">section</span> <span class="cartouche">&#8249;Edmonds-Karp Algorithm&#8250;</span>
<span class="keyword1">theory</span> EdmondsKarp_Algo
<span class="keyword2">imports</span> FordFulkerson_Algo
<span class="keyword2">begin</span>
<span class="keyword1">text</span> <span class="cartouche">&#8249;
  In this theory, we formalize an abstract version of
  Edmonds-Karp algorithm, which we obtain by refining the 
  Ford-Fulkerson algorithm to always use shortest augmenting paths.

  Then, we show that the algorithm always terminates within $O(VE)$ iterations.
&#8250;</span>

<span class="keyword1">subsection</span> <span class="cartouche">&#8249;Algorithm&#8250;</span>

<span class="keyword1">context</span> Network 
<span class="keyword2">begin</span>

<span class="keyword1">text</span> <span class="cartouche">&#8249;First, we specify the refined procedure for finding augmenting paths&#8250;</span>
<span class="keyword1">definition</span> <span class="string">&quot;find_shortest_augmenting_spec f &equiv; ASSERT (NFlow c s t f) &raquo; 
  SELECTp (&lambda;p. Graph.isShortestPath (residualGraph c f) s p t)&quot;</span>

<span class="keyword1">text</span> <span class="cartouche">&#8249;Note, if there is an augmenting path, there is always a shortest one&#8250;</span>
<span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> NFlow<span class="delimiter">)</span> augmenting_path_imp_shortest<span class="delimiter">:</span> 
  <span class="string">&quot;isAugmenting p ==&gt; &exist;p. Graph.isShortestPath cf s p t&quot;</span>
  <span class="keyword1">using</span> Graph.obtain_shortest_path <span class="keyword1">unfolding</span> isAugmenting_def
  <span class="keyword1">by</span> <span class="delimiter">(</span>fastforce simp<span class="delimiter">:</span> Graph.isSimplePath_def Graph.connected_def<span class="delimiter">)</span>

<span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> NFlow<span class="delimiter">)</span> shortest_is_augmenting<span class="delimiter">:</span> 
  <span class="string">&quot;Graph.isShortestPath cf s p t ==&gt; isAugmenting p&quot;</span>
  <span class="keyword1">unfolding</span> isAugmenting_def <span class="keyword1">using</span> Graph.shortestPath_is_simple
  <span class="keyword1">by</span> <span class="delimiter">(</span>fastforce<span class="delimiter">)</span>

<span class="keyword1">text</span> <span class="cartouche">&#8249;We show that our refined procedure is actually a refinement&#8250;</span>  
<span class="keyword1">lemma</span> find_shortest_augmenting_refine<span class="delimiter">[</span>refine<span class="delimiter">]</span><span class="delimiter">:</span> 
  <span class="string">&quot;(f&#39;,f)&isin;Id ==&gt; find_shortest_augmenting_spec f&#39; &le; \&lt;Down&gt;Id (find_augmenting_spec f)&quot;</span>  
  <span class="keyword1">unfolding</span> find_shortest_augmenting_spec_def find_augmenting_spec_def
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>refine_vcg<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto 
    simp<span class="delimiter">:</span> NFlow.shortest_is_augmenting 
    dest<span class="delimiter">:</span> NFlow.augmenting_path_imp_shortest<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">done</span></span>

<span class="keyword1">text</span> <span class="cartouche">&#8249;Next, we specify the Edmonds-Karp algorithm. 
  Our first specification still uses partial correctness, 
  termination will be proved afterwards. &#8250;</span>  
<span class="keyword1">definition</span> <span class="string">&quot;edka_partial &equiv; do {
  let f = (&lambda;_. 0);

  (f,_) \&lt;leftarrow&gt; while<span class="hidden">&#8663;</span><sup>fofu_invar<span class="hidden">&#8662;</span></sup>
    (&lambda;(f,brk). &not;brk) 
    (&lambda;(f,_). do {
      p \&lt;leftarrow&gt; find_shortest_augmenting_spec f;
      case p of 
        None =&gt; return (f,True)
      | Some p =&gt; do {
          assert (p&ne;[]);
          assert (NFlow.isAugmenting c s t f p);
          assert (Graph.isShortestPath (residualGraph c f) s p t);
          let f&#39; = NFlow.augmentingFlow c f p;
          let f = NFlow.augment c f f&#39;;
          assert (NFlow c s t f);
          return (f, False)
        }  
    })
    (f,False);
  assert (NFlow c s t f);
  return f 
}&quot;</span>

<span class="keyword1">lemma</span> edka_partial_refine<span class="delimiter">[</span>refine<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;edka_partial &le; \&lt;Down&gt;Id fofu&quot;</span>
  <span class="keyword1">unfolding</span> edka_partial_def fofu_def
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>refine_rcg bind_refine&#39;<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>refine_dref_type<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>vc_solve simp<span class="delimiter">:</span> find_shortest_augmenting_spec_def<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">done</span></span>


<span class="keyword2">end</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Network&#8250;</span>

<span class="keyword1">subsection</span> <span class="cartouche">&#8249;Complexity and Termination Analysis&#8250;</span>
<span class="keyword1">text</span> <span class="cartouche">&#8249;
  In this section, we show that the loop iterations of the Edmonds-Karp algorithm
  are bounded by $O(VE)$.

  The basic idea of the proof is, that a path that
  takes an edge reverse to an edge on some shortest path 
  cannot be a shortest path itself.

  As augmentation flips at least one edge, this yields a termination argument:
    After augmentation, either the minimum distance between source and target
    increases, or it remains the same, but the number of edges that lay on a
    shortest path decreases. As the minimum distance is bounded by $V$, 
    we get termination within $O(VE)$ loop iterations.
&#8250;</span>

<span class="keyword1">context</span> Graph <span class="keyword2">begin</span>

<span class="keyword1">text</span> <span class="cartouche">&#8249;
  The basic idea is expressed in the following lemma, which, however, 
  is not general enough to be applied for the correctness proof, where
  we flip more than one edge simultaneously.
  &#8250;</span>
<span class="keyword1">lemma</span> isShortestPath_flip_edge<span class="delimiter">:</span>
  <span class="keyword2">assumes</span> <span class="string">&quot;isShortestPath s p t&quot;</span> <span class="string">&quot;(u,v)&isin;set p&quot;</span>
  <span class="keyword2">assumes</span> <span class="string">&quot;isPath s p&#39; t&quot;</span> <span class="string">&quot;(v,u)&isin;set p&#39;&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;length p&#39; &ge; length p + 2&quot;</span>
  <span class="keyword1">using</span> assms
<span class="keyword1">proof</span> -
  <span class="keyword1">from</span> <span class="cartouche">&#8249;isShortestPath s p t&#8250;</span> <span class="keyword1">have</span> 
    MIN<span class="delimiter">:</span> <span class="string">&quot;min_dist s t = length p&quot;</span> <span class="keyword2">and</span> 
      P<span class="delimiter">:</span> <span class="string">&quot;isPath s p t&quot;</span> <span class="keyword2">and</span> 
     DV<span class="delimiter">:</span> <span class="string">&quot;distinct (pathVertices s p)&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isShortestPath_alt isSimplePath_def<span class="delimiter">)</span>
    
  <span class="keyword1">from</span> <span class="cartouche">&#8249;(u,v)&isin;set p&#8250;</span> <span class="keyword3">obtain</span> p1 p2 <span class="keyword2">where</span> <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;p=p1@(u,v)#p2&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> in_set_conv_decomp<span class="delimiter">)</span>
    
  <span class="keyword1">from</span> P DV <span class="keyword1">have</span> <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;u&ne;v&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>cases p2<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp add<span class="delimiter">:</span> isPath_append pathVertices_append<span class="delimiter">)</span>

  <span class="keyword1">from</span> P <span class="keyword1">have</span> DISTS<span class="delimiter">:</span> <span class="string">&quot;dist s (length p1) u&quot;</span> <span class="string">&quot;dist u 1 v&quot;</span> <span class="string">&quot;dist v (length p2) t&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isPath_append dist_def intro<span class="delimiter">:</span> exI<span class="delimiter">[</span><span class="keyword2">where</span> x<span class="delimiter">=</span><span class="string">&quot;[(u,v)]&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="keyword1">from</span> MIN <span class="keyword1">have</span> MIN&#39;<span class="delimiter">:</span> <span class="string">&quot;min_dist s t = length p1 + 1 + length p2&quot;</span> <span class="keyword1">by</span> auto

  <span class="keyword1">from</span> min_dist_split<span class="delimiter">[</span>OF dist_trans<span class="delimiter">[</span>OF DISTS<span class="delimiter">(</span>1<span class="delimiter">,</span>2<span class="delimiter">)</span><span class="delimiter">]</span> DISTS<span class="delimiter">(</span>3<span class="delimiter">)</span> MIN&#39;<span class="delimiter">]</span> <span class="keyword1">have</span>
    MDSV<span class="delimiter">:</span> <span class="string">&quot;min_dist s v = length p1 + 1&quot;</span> <span class="keyword1">by</span> simp
    
  <span class="keyword1">from</span> min_dist_split<span class="delimiter">[</span>OF DISTS<span class="delimiter">(</span>1<span class="delimiter">)</span> dist_trans<span class="delimiter">[</span>OF DISTS<span class="delimiter">(</span>2<span class="delimiter">,</span>3<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span> MIN&#39; <span class="keyword1">have</span>
    MDUT<span class="delimiter">:</span> <span class="string">&quot;min_dist u t = 1 + length p2&quot;</span> <span class="keyword1">by</span> simp

  <span class="keyword1">from</span> <span class="cartouche">&#8249;(v,u)&isin;set p&#39;&#8250;</span> <span class="keyword3">obtain</span> p1&#39; p2&#39; <span class="keyword2">where</span> <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;p&#39;=p1&#39;@(v,u)#p2&#39;&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> in_set_conv_decomp<span class="delimiter">)</span>

  <span class="keyword1">from</span> <span class="cartouche">&#8249;isPath s p&#39; t&#8250;</span> <span class="keyword1">have</span> 
    DISTS&#39;<span class="delimiter">:</span> <span class="string">&quot;dist s (length p1&#39;) v&quot;</span> <span class="string">&quot;dist u (length p2&#39;) t&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isPath_append dist_def<span class="delimiter">)</span>
  
  <span class="keyword1">from</span> DISTS&#39;<span class="delimiter">[</span>THEN min_dist_minD<span class="delimiter">,</span> unfolded MDSV MDUT<span class="delimiter">]</span> <span class="keyword3">show</span>
    <span class="string">&quot;length p + 2 &le; length p&#39;&quot;</span> <span class="keyword1">by</span> auto
<span class="keyword1">qed</span>    


<span class="keyword1">text</span> <span class="cartouche">&#8249;
  To be used for the analysis of augmentation, we have to generalize the 
  lemma to simultaneous flipping of edges:
  &#8250;</span> 
<span class="keyword1">lemma</span> isShortestPath_flip_edges<span class="delimiter">:</span>
  <span class="keyword2">assumes</span> <span class="string">&quot;Graph.E c&#39; &supe; E - edges&quot;</span> <span class="string">&quot;Graph.E c&#39; &sube; E &cup; (prod.swap`edges)&quot;</span>
  <span class="keyword2">assumes</span> SP<span class="delimiter">:</span> <span class="string">&quot;isShortestPath s p t&quot;</span> <span class="keyword2">and</span> EDGES_SS<span class="delimiter">:</span> <span class="string">&quot;edges &sube; set p&quot;</span>
  <span class="keyword2">assumes</span> P&#39;<span class="delimiter">:</span> <span class="string">&quot;Graph.isPath c&#39; s p&#39; t&quot;</span> <span class="string">&quot;prod.swap`edges &cap; set p&#39; &ne; {}&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;length p + 2 &le; length p&#39;&quot;</span>
<span class="keyword1">proof</span> -
  <span class="keyword1">interpret</span> g&#39;<span class="delimiter">!</span><span class="delimiter">:</span> Graph c&#39; <span class="keyword1">.</span>

  <span class="comment">(* TODO: The proof still contains some redundancy: A first flipped edge
    is searched in both, the induction, and the initialization *)</span>
  <span class="keyword1">{</span>
    <span class="keyword3">fix</span> u v p1 p2&#39;
    <span class="keyword3">assume</span> <span class="string">&quot;(u,v)&isin;edges&quot;</span>
       <span class="keyword2">and</span> <span class="string">&quot;isPath s p1 v&quot;</span> <span class="keyword2">and</span> <span class="string">&quot;g&#39;.isPath u p2&#39; t&quot;</span>
    <span class="keyword1">hence</span> <span class="string">&quot;min_dist s t &lt; length p1 + length p2&#39;&quot;</span>   
    <span class="keyword1">proof</span> <span class="delimiter">(</span>induction p2&#39; arbitrary<span class="delimiter">:</span> u v p1 rule<span class="delimiter">:</span> length_induct<span class="delimiter">)</span>
      <span class="keyword3">case</span> <span class="delimiter">(</span>1 p2&#39;<span class="delimiter">)</span>
      <span class="keyword1">note</span> IH <span class="delimiter">=</span> <span class="string">&quot;1.IH&quot;</span><span class="delimiter">[</span>rule_format<span class="delimiter">]</span>
      <span class="keyword1">note</span> P1 <span class="delimiter">=</span> <span class="cartouche">&#8249;isPath s p1 v&#8250;</span>
      <span class="keyword1">note</span> P2&#39; <span class="delimiter">=</span> <span class="cartouche">&#8249;g&#39;.isPath u p2&#39; t&#8250;</span>

      <span class="keyword1">have</span> <span class="string">&quot;length p1 &gt; min_dist s u&quot;</span>
      <span class="keyword1">proof</span> -
        <span class="keyword1">from</span> P1 <span class="keyword1">have</span> <span class="string">&quot;length p1 &ge; min_dist s v&quot;</span>
          <span class="keyword1">using</span> min_dist_minD <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dist_def<span class="delimiter">)</span>
        <span class="keyword1">moreover</span> <span class="keyword1">from</span> <span class="cartouche">&#8249;(u,v)&isin;edges&#8250;</span> EDGES_SS 
        <span class="keyword1">have</span> <span class="string">&quot;min_dist s v = Suc (min_dist s u)&quot;</span>
          <span class="keyword1">using</span> isShortestPath_level_edge<span class="delimiter">[</span>OF SP<span class="delimiter">]</span> <span class="keyword1">by</span> auto
        <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
      <span class="keyword1">qed</span>  

      <span class="keyword1">from</span> isShortestPath_level_edge<span class="delimiter">[</span>OF SP<span class="delimiter">]</span> <span class="cartouche">&#8249;(u,v)&isin;edges&#8250;</span> EDGES_SS 
      <span class="keyword1">have</span> 
            <span class="string">&quot;min_dist s t = min_dist s u + min_dist u t&quot;</span> 
        <span class="keyword2">and</span> <span class="string">&quot;connected s u&quot;</span>
      <span class="keyword1">by</span> auto

      <span class="keyword3">show</span> <span class="var">?case</span>
      <span class="keyword1">proof</span> <span class="delimiter">(</span>cases <span class="string">&quot;prod.swap`edges &cap; set p2&#39; = {}&quot;</span><span class="delimiter">)</span>
        <span class="delimiter">--</span> <span class="cartouche">&#8249;We proceed by a case distinction whether the suffix path contains swapped edges&#8250;</span>
        <span class="keyword3">case</span> True 
        <span class="keyword1">with</span> g&#39;.transfer_path<span class="delimiter">[</span>OF _ P2&#39;<span class="delimiter">,</span> of c<span class="delimiter">]</span> <span class="cartouche">&#8249;g&#39;.E &sube; E &cup; prod.swap ` edges&#8250;</span>
        <span class="keyword1">have</span> <span class="string">&quot;isPath u p2&#39; t&quot;</span> <span class="keyword1">by</span> auto
        <span class="keyword1">hence</span> <span class="string">&quot;length p2&#39; &ge; min_dist u t&quot;</span> <span class="keyword1">using</span> min_dist_minD
          <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dist_def<span class="delimiter">)</span>
        <span class="keyword1">moreover</span> <span class="keyword1">note</span> <span class="cartouche">&#8249;length p1 &gt; min_dist s u&#8250;</span>
        <span class="keyword1">moreover</span> <span class="keyword1">note</span> <span class="cartouche">&#8249;min_dist s t = min_dist s u + min_dist u t&#8250;</span>
        <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
      <span class="keyword1">next</span>
        <span class="keyword3">case</span> False
        <span class="delimiter">--</span> <span class="cartouche">&#8249;Obtain first swapped edge on suffix path&#8250;</span>
        <span class="keyword3">obtain</span> p21&#39; e&#39; p22&#39; <span class="keyword2">where</span> <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;p2&#39;=p21&#39;@e&#39;#p22&#39;&quot;</span> <span class="keyword2">and</span> 
           E_IN_EDGES<span class="delimiter">:</span> <span class="string">&quot;e&#39;&isin;prod.swap`edges&quot;</span> <span class="keyword2">and</span> 
          P1_NO_EDGES<span class="delimiter">:</span> <span class="string">&quot;prod.swap`edges &cap; set p21&#39; = {}&quot;</span>
          <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule split_list_first_propE<span class="delimiter">[</span>of p2&#39; <span class="string">&quot;&lambda;e. e&isin;prod.swap`edges&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>
          <span class="keyword1">using</span> <span class="cartouche">&#8249;prod.swap ` edges &cap; set p2&#39; &ne; {}&#8250;</span> <span class="keyword1"><span class="improper">apply</span></span> auto <span class="delimiter">[</span><span class="delimiter">]</span>
          <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rprems<span class="delimiter">,</span> assumption<span class="delimiter">)</span>
          <span class="keyword1"><span class="improper">apply</span></span> auto
          <span class="keyword1"><span class="improper">done</span></span>
        <span class="keyword3">obtain</span> u&#39; v&#39; <span class="keyword2">where</span> <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;e&#39;=(v&#39;,u&#39;)&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>cases e&#39;<span class="delimiter">)</span>      
  
        <span class="delimiter">--</span> <span class="cartouche">&#8249;Split the suffix path accordingly&#8250;</span>
        <span class="keyword1">from</span> P2&#39; <span class="keyword1">have</span> P21&#39;<span class="delimiter">:</span> <span class="string">&quot;g&#39;.isPath u p21&#39; v&#39;&quot;</span> <span class="keyword2">and</span> P22&#39;<span class="delimiter">:</span> <span class="string">&quot;g&#39;.isPath u&#39; p22&#39; t&quot;</span>
          <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> g&#39;.isPath_append<span class="delimiter">)</span>
        <span class="delimiter">--</span> <span class="cartouche">&#8249;As we chose the first edge, the prefix of the suffix path is also a path in the original graph&#8250;</span>  
        <span class="keyword1">from</span> 
          g&#39;.transfer_path<span class="delimiter">[</span>OF _ P21&#39;<span class="delimiter">,</span> of c<span class="delimiter">]</span> 
          <span class="cartouche">&#8249;g&#39;.E &sube; E &cup; prod.swap ` edges&#8250;</span> 
          P1_NO_EDGES
        <span class="keyword1">have</span> P21<span class="delimiter">:</span> <span class="string">&quot;isPath u p21&#39; v&#39;&quot;</span> <span class="keyword1">by</span> auto
        <span class="keyword1">from</span> min_dist_is_dist<span class="delimiter">[</span>OF <span class="cartouche">&#8249;connected s u&#8250;</span><span class="delimiter">]</span> 
        <span class="keyword3">obtain</span> psu <span class="keyword2">where</span> 
              PSU<span class="delimiter">:</span> <span class="string">&quot;isPath s psu u&quot;</span> <span class="keyword2">and</span> 
          LEN_PSU<span class="delimiter">:</span> <span class="string">&quot;length psu = min_dist s u&quot;</span> 
          <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dist_def<span class="delimiter">)</span>
        <span class="keyword1">from</span> PSU P21 <span class="keyword1">have</span> P1n<span class="delimiter">:</span> <span class="string">&quot;isPath s (psu@p21&#39;) v&#39;&quot;</span> 
          <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isPath_append<span class="delimiter">)</span>
        <span class="keyword1">from</span> IH<span class="delimiter">[</span>OF _ _ P1n P22&#39;<span class="delimiter">]</span> E_IN_EDGES <span class="keyword1">have</span> 
          <span class="string">&quot;min_dist s t &lt; length psu + length p21&#39; + length p22&#39;&quot;</span> 
          <span class="keyword1">by</span> auto
        <span class="keyword1">moreover</span> <span class="keyword1">note</span> <span class="cartouche">&#8249;length p1 &gt; min_dist s u&#8250;</span>
        <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> LEN_PSU<span class="delimiter">)</span>
      <span class="keyword1">qed</span>
    <span class="keyword1">qed</span>  
  <span class="keyword1">}</span> <span class="keyword1">note</span> aux<span class="delimiter">=</span>this

  <span class="comment">(* TODO: This step is analogous to what we do in the False-case of the induction.
    Can we somehow remove the redundancy? *)</span>
  <span class="delimiter">--</span> <span class="cartouche">&#8249;Obtain first swapped edge on path&#8250;</span>
  <span class="keyword3">obtain</span> p1&#39; e p2&#39; <span class="keyword2">where</span> <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;p&#39;=p1&#39;@e#p2&#39;&quot;</span> <span class="keyword2">and</span> 
    E_IN_EDGES<span class="delimiter">:</span> <span class="string">&quot;e&isin;prod.swap`edges&quot;</span> <span class="keyword2">and</span> 
    P1_NO_EDGES<span class="delimiter">:</span> <span class="string">&quot;prod.swap`edges &cap; set p1&#39; = {}&quot;</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule split_list_first_propE<span class="delimiter">[</span>of p&#39; <span class="string">&quot;&lambda;e. e&isin;prod.swap`edges&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="keyword1">using</span> <span class="cartouche">&#8249;prod.swap ` edges &cap; set p&#39; &ne; {}&#8250;</span> <span class="keyword1"><span class="improper">apply</span></span> auto <span class="delimiter">[</span><span class="delimiter">]</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rprems<span class="delimiter">,</span> assumption<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> auto
    <span class="keyword1"><span class="improper">done</span></span>
  <span class="keyword3">obtain</span> u v <span class="keyword2">where</span> <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;e=(v,u)&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>cases e<span class="delimiter">)</span>      

  <span class="delimiter">--</span> <span class="cartouche">&#8249;Split the new path accordingly&#8250;</span>
  <span class="keyword1">from</span> <span class="cartouche">&#8249;g&#39;.isPath s p&#39; t&#8250;</span> <span class="keyword1">have</span> 
    P1&#39;<span class="delimiter">:</span> <span class="string">&quot;g&#39;.isPath s p1&#39; v&quot;</span> <span class="keyword2">and</span> 
    P2&#39;<span class="delimiter">:</span> <span class="string">&quot;g&#39;.isPath u p2&#39; t&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> g&#39;.isPath_append<span class="delimiter">)</span>
  <span class="delimiter">--</span> <span class="cartouche">&#8249;As we chose the first edge, the prefix of the path is also a path in the original graph&#8250;</span>  
  <span class="keyword1">from</span> 
    g&#39;.transfer_path<span class="delimiter">[</span>OF _ P1&#39;<span class="delimiter">,</span> of c<span class="delimiter">]</span> 
    <span class="cartouche">&#8249;g&#39;.E &sube; E &cup; prod.swap ` edges&#8250;</span> 
    P1_NO_EDGES
  <span class="keyword1">have</span> P1<span class="delimiter">:</span> <span class="string">&quot;isPath s p1&#39; v&quot;</span> <span class="keyword1">by</span> auto
  
  <span class="keyword1">from</span> aux<span class="delimiter">[</span>OF _ P1 P2&#39;<span class="delimiter">]</span> E_IN_EDGES 
  <span class="keyword1">have</span> <span class="string">&quot;min_dist s t &lt; length p1&#39; + length p2&#39;&quot;</span>
    <span class="keyword1">by</span> auto
  <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">using</span> SP 
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isShortestPath_min_dist_def<span class="delimiter">)</span>
<span class="keyword1">qed</span>    

<span class="keyword2">end</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Graph&#8250;</span>

<span class="keyword1">text</span> <span class="cartouche">&#8249;We outsource the more specific lemmas to their own locale, 
  to prevent name space pollution&#8250;</span>
<span class="keyword1">locale</span> ek_analysis_defs <span class="delimiter">=</span> Graph <span class="delimiter">+</span>
  <span class="keyword2">fixes</span> s t <span class="delimiter">::</span> node

<span class="keyword1">locale</span> ek_analysis <span class="delimiter">=</span> ek_analysis_defs <span class="delimiter">+</span> Finite_Graph
<span class="keyword2">begin</span>

<span class="keyword1">definition</span> <span class="delimiter">(</span><span class="keyword2">in</span> ek_analysis_defs<span class="delimiter">)</span> 
  <span class="string">&quot;spEdges &equiv; {e. &exist;p. e&isin;set p &and; isShortestPath s p t}&quot;</span>

<span class="keyword1">lemma</span> spEdges_ss_E<span class="delimiter">:</span> <span class="string">&quot;spEdges &sube; E&quot;</span>
  <span class="keyword1">using</span> isPath_edgeset <span class="keyword1">unfolding</span> spEdges_def isShortestPath_def <span class="keyword1">by</span> auto

<span class="keyword1">lemma</span> finite_spEdges<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;finite (spEdges)&quot;</span>  
  <span class="keyword1">using</span> finite_subset<span class="delimiter">[</span>OF spEdges_ss_E<span class="delimiter">]</span> 
  <span class="keyword1">by</span> blast

<span class="keyword1">definition</span> <span class="delimiter">(</span><span class="keyword2">in</span> ek_analysis_defs<span class="delimiter">)</span> <span class="string">&quot;uE &equiv; E &cup; E&macr;&quot;</span>

<span class="keyword1">lemma</span> finite_uE<span class="delimiter">[</span>simp<span class="delimiter">,</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;finite uE&quot;</span>
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> uE_def<span class="delimiter">)</span>

<span class="keyword1">lemma</span> E_ss_uE<span class="delimiter">:</span> <span class="string">&quot;E&sube;uE&quot;</span>  
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> uE_def<span class="delimiter">)</span>

<span class="keyword1">lemma</span> card_spEdges_le<span class="delimiter">:</span>
  <span class="keyword2">shows</span> <span class="string">&quot;card spEdges &le; card uE&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule card_mono<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> order_trans<span class="delimiter">[</span>OF spEdges_ss_E E_ss_uE<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">done</span></span>

<span class="keyword1">lemma</span> card_spEdges_less<span class="delimiter">:</span>
  <span class="keyword2">shows</span> <span class="string">&quot;card spEdges &lt; card uE + 1&quot;</span>
  <span class="keyword1">using</span> card_spEdges_le<span class="delimiter">[</span>OF assms<span class="delimiter">]</span> 
  <span class="keyword1">by</span> auto
  

<span class="keyword1">definition</span> <span class="delimiter">(</span><span class="keyword2">in</span> ek_analysis_defs<span class="delimiter">)</span> <span class="string">&quot;ekMeasure &equiv; 
  if (connected s t) then
    (card V - min_dist s t) * (card uE + 1) + (card (spEdges))
  else 0&quot;</span>

<span class="keyword1">lemma</span> measure_decr<span class="delimiter">:</span>
  <span class="keyword2">assumes</span> SV<span class="delimiter">:</span> <span class="string">&quot;s&isin;V&quot;</span>
  <span class="keyword2">assumes</span> SP<span class="delimiter">:</span> <span class="string">&quot;isShortestPath s p t&quot;</span>
  <span class="keyword2">assumes</span> SP_EDGES<span class="delimiter">:</span> <span class="string">&quot;edges&sube;set p&quot;</span>
  <span class="keyword2">assumes</span> Ebounds<span class="delimiter">:</span> 
    <span class="string">&quot;Graph.E c&#39; &supe; E - edges &cup; prod.swap`edges&quot;</span> 
    <span class="string">&quot;Graph.E c&#39; &sube; E &cup; prod.swap`edges&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;ek_analysis_defs.ekMeasure c&#39; s t &le; ekMeasure&quot;</span>
    <span class="keyword2">and</span> <span class="string">&quot;edges - Graph.E c&#39; &ne; {} 
         ==&gt; ek_analysis_defs.ekMeasure c&#39; s t &lt; ekMeasure&quot;</span>
<span class="keyword1">proof</span> -
  <span class="keyword1">interpret</span> g&#39;<span class="delimiter">!</span><span class="delimiter">:</span> ek_analysis_defs c&#39; s t <span class="keyword1">.</span>

  <span class="keyword1">interpret</span> g&#39;<span class="delimiter">!</span><span class="delimiter">:</span> ek_analysis c&#39; s t
    <span class="keyword1"><span class="improper">apply</span></span> intro_locales
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule g&#39;.Finite_Graph_EI<span class="delimiter">)</span>
    <span class="keyword1">using</span> finite_subset<span class="delimiter">[</span>OF Ebounds<span class="delimiter">(</span>2<span class="delimiter">)</span><span class="delimiter">]</span> finite_subset<span class="delimiter">[</span>OF SP_EDGES<span class="delimiter">]</span>
    <span class="keyword1">by</span> auto
  
  <span class="keyword1">from</span> SP_EDGES SP <span class="keyword1">have</span> <span class="string">&quot;edges &sube; E&quot;</span> 
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> spEdges_def isShortestPath_def dest<span class="delimiter">:</span> isPath_edgeset<span class="delimiter">)</span>
  <span class="keyword1">with</span> Ebounds <span class="keyword1">have</span> Veq<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Graph.V c&#39; = V&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>force simp<span class="delimiter">:</span> Graph.V_def<span class="delimiter">)</span>

  <span class="keyword1">from</span> Ebounds <span class="cartouche">&#8249;edges &sube; E&#8250;</span> <span class="keyword1">have</span> uE_eq<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;g&#39;.uE = uE&quot;</span>  
    <span class="keyword1">by</span> <span class="delimiter">(</span>force simp<span class="delimiter">:</span> ek_analysis_defs.uE_def<span class="delimiter">)</span>

  <span class="keyword1">from</span> SP <span class="keyword1">have</span> LENP<span class="delimiter">:</span> <span class="string">&quot;length p = min_dist s t&quot;</span> 
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isShortestPath_min_dist_def<span class="delimiter">)</span> 

  <span class="keyword1">from</span> SP <span class="keyword1">have</span> CONN<span class="delimiter">:</span> <span class="string">&quot;connected s t&quot;</span> 
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isShortestPath_def connected_def<span class="delimiter">)</span>

  <span class="keyword1">{</span>
    <span class="keyword3">assume</span> NCONN2<span class="delimiter">:</span> <span class="string">&quot;&not;g&#39;.connected s t&quot;</span>
    <span class="keyword1">hence</span> <span class="string">&quot;s&ne;t&quot;</span> <span class="keyword1">by</span> auto
    <span class="keyword1">with</span> CONN NCONN2 <span class="keyword1">have</span> <span class="string">&quot;g&#39;.ekMeasure &lt; ekMeasure&quot;</span>
      <span class="keyword1">unfolding</span> g&#39;.ekMeasure_def ekMeasure_def
      <span class="keyword1">using</span> min_dist_less_V<span class="delimiter">[</span>OF finite_V SV<span class="delimiter">]</span> <span class="comment">(* TODO: Move this result to finite-graph! *)</span>
      <span class="keyword1">by</span> auto
  <span class="keyword1">}</span> <span class="keyword1">moreover</span> <span class="keyword1">{</span>
    <span class="keyword3">assume</span> SHORTER<span class="delimiter">:</span> <span class="string">&quot;g&#39;.min_dist s t &lt; min_dist s t&quot;</span>
    <span class="keyword3">assume</span> CONN2<span class="delimiter">:</span> <span class="string">&quot;g&#39;.connected s t&quot;</span>

    <span class="delimiter">--</span> <span class="cartouche">&#8249;Obtain a shorter path in $g&#39;$&#8250;</span>
    <span class="keyword1">from</span> g&#39;.min_dist_is_dist<span class="delimiter">[</span>OF CONN2<span class="delimiter">]</span> <span class="keyword3">obtain</span> p&#39; <span class="keyword2">where</span>
      P&#39;<span class="delimiter">:</span> <span class="string">&quot;g&#39;.isPath s p&#39; t&quot;</span> <span class="keyword2">and</span> LENP&#39;<span class="delimiter">:</span> <span class="string">&quot;length p&#39; = g&#39;.min_dist s t&quot;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> g&#39;.dist_def<span class="delimiter">)</span>

    <span class="keyword1">{</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Case: It does not use @{term &quot;prod.swap`edges&quot;}. 
        Then it is also a path in $g$, which is shorter than 
        the shortest path in $g$, yielding a contradiction.&#8250;</span>
      <span class="keyword3">assume</span> <span class="string">&quot;prod.swap`edges &cap; set p&#39; = {}&quot;</span>
      <span class="keyword1">with</span> g&#39;.transfer_path<span class="delimiter">[</span>OF _ P&#39;<span class="delimiter">,</span> of c<span class="delimiter">]</span> Ebounds <span class="keyword1">have</span> <span class="string">&quot;dist s (length p&#39;) t&quot;</span>
        <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dist_def<span class="delimiter">)</span>
      <span class="keyword1">from</span> LENP&#39; SHORTER min_dist_minD<span class="delimiter">[</span>OF this<span class="delimiter">]</span> <span class="keyword1">have</span> False <span class="keyword1">by</span> auto 
    <span class="keyword1">}</span> <span class="keyword1">moreover</span> <span class="keyword1">{</span>
      <span class="delimiter">--</span> <span class="cartouche">&#8249;So assume the path uses the edge @{term &quot;prod.swap e&quot;}.&#8250;</span>
      <span class="keyword3">assume</span> <span class="string">&quot;prod.swap`edges &cap; set p&#39; &ne; {}&quot;</span>
      <span class="delimiter">--</span> <span class="cartouche">&#8249;Due to auxiliary lemma, those path must be longer&#8250;</span>
      <span class="keyword1">from</span> isShortestPath_flip_edges<span class="delimiter">[</span>OF _ _ SP SP_EDGES P&#39; this<span class="delimiter">]</span> Ebounds
      <span class="keyword1">have</span> <span class="string">&quot;length p&#39; &gt; length p&quot;</span> <span class="keyword1">by</span> auto
      <span class="keyword1">with</span> SHORTER LENP LENP&#39; <span class="keyword1">have</span> False <span class="keyword1">by</span> auto
    <span class="keyword1">}</span> <span class="keyword1">ultimately</span> <span class="keyword1">have</span> False <span class="keyword1">by</span> auto
  <span class="keyword1">}</span> <span class="keyword1">moreover</span> <span class="keyword1">{</span>
    <span class="keyword3">assume</span> LONGER<span class="delimiter">:</span> <span class="string">&quot;g&#39;.min_dist s t &gt; min_dist s t&quot;</span>
    <span class="keyword3">assume</span> CONN2<span class="delimiter">:</span> <span class="string">&quot;g&#39;.connected s t&quot;</span>
    <span class="keyword1">have</span> <span class="string">&quot;g&#39;.ekMeasure &lt; ekMeasure&quot;</span>
      <span class="keyword1">unfolding</span> g&#39;.ekMeasure_def ekMeasure_def
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>simp only<span class="delimiter">:</span> Veq uE_eq CONN CONN2 if_True<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule mlex_fst_decrI<span class="delimiter">)</span>
      <span class="keyword1">using</span> card_spEdges_less g&#39;.card_spEdges_less 
        <span class="keyword2">and</span> g&#39;.min_dist_less_V<span class="delimiter">[</span>OF _ _ CONN2<span class="delimiter">]</span> SV
        <span class="keyword2">and</span> LONGER
      <span class="keyword1"><span class="improper">apply</span></span> auto
      <span class="keyword1"><span class="improper">done</span></span>
  <span class="keyword1">}</span> <span class="keyword1">moreover</span> <span class="keyword1">{</span>
    <span class="keyword3">assume</span> EQ<span class="delimiter">:</span> <span class="string">&quot;g&#39;.min_dist s t = min_dist s t&quot;</span>
    <span class="keyword3">assume</span> CONN2<span class="delimiter">:</span> <span class="string">&quot;g&#39;.connected s t&quot;</span>

    <span class="keyword1">{</span>
      <span class="keyword3">fix</span> p&#39;
      <span class="keyword3">assume</span> P&#39;<span class="delimiter">:</span> <span class="string">&quot;g&#39;.isShortestPath s p&#39; t&quot;</span>
      <span class="keyword1">have</span> <span class="string">&quot;prod.swap`edges &cap; set p&#39; = {}&quot;</span> 
      <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span> 
        <span class="keyword3">assume</span> EIP&#39;<span class="delimiter">:</span> <span class="string">&quot;prod.swap`edges &cap; set p&#39; &ne; {}&quot;</span>
        <span class="keyword1">from</span> P&#39; <span class="keyword1">have</span> 
             P&#39;<span class="delimiter">:</span> <span class="string">&quot;g&#39;.isPath s p&#39; t&quot;</span> <span class="keyword2">and</span> 
          LENP&#39;<span class="delimiter">:</span> <span class="string">&quot;length p&#39; = g&#39;.min_dist s t&quot;</span>
          <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> g&#39;.isShortestPath_min_dist_def<span class="delimiter">)</span>
        <span class="keyword1">from</span> isShortestPath_flip_edges<span class="delimiter">[</span>OF _ _ SP SP_EDGES P&#39; EIP&#39;<span class="delimiter">]</span> Ebounds 
        <span class="keyword1">have</span> <span class="string">&quot;length p + 2 &le; length p&#39;&quot;</span> <span class="keyword1">by</span> auto
        <span class="keyword1">with</span> LENP LENP&#39; EQ <span class="keyword3">show</span> False <span class="keyword1">by</span> auto
      <span class="keyword1">qed</span>  
      <span class="keyword1">with</span> g&#39;.transfer_path<span class="delimiter">[</span>of p&#39; c s t<span class="delimiter">]</span> P&#39; Ebounds <span class="keyword1">have</span> <span class="string">&quot;isShortestPath s p&#39; t&quot;</span>
        <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> Graph.isShortestPath_min_dist_def EQ<span class="delimiter">)</span>
    <span class="keyword1">}</span> <span class="keyword1">hence</span> SS<span class="delimiter">:</span> <span class="string">&quot;g&#39;.spEdges &sube; spEdges&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> g&#39;.spEdges_def spEdges_def<span class="delimiter">)</span>
        
    <span class="keyword1">{</span>
      <span class="keyword3">assume</span> <span class="string">&quot;edges - Graph.E c&#39; &ne; {}&quot;</span>
      <span class="keyword1">with</span> g&#39;.spEdges_ss_E SS SP SP_EDGES <span class="keyword1">have</span> <span class="string">&quot;g&#39;.spEdges &sub; spEdges&quot;</span>
        <span class="keyword1">unfolding</span> g&#39;.spEdges_def spEdges_def <span class="keyword1">by</span> fastforce
      <span class="keyword1">hence</span> <span class="string">&quot;g&#39;.ekMeasure &lt; ekMeasure&quot;</span>  
        <span class="keyword1">unfolding</span> g&#39;.ekMeasure_def ekMeasure_def 
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>simp only<span class="delimiter">:</span> Veq uE_eq EQ CONN CONN2 if_True<span class="delimiter">)</span>
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule mlex_snd_decrI<span class="delimiter">)</span>
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> EQ<span class="delimiter">)</span>
        <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule psubset_card_mono<span class="delimiter">)</span>
        <span class="keyword1"><span class="improper">apply</span></span> simp
        <span class="keyword1">by</span> simp
    <span class="keyword1">}</span> <span class="keyword1">note</span> G1 <span class="delimiter">=</span> this

    <span class="keyword1">have</span> G2<span class="delimiter">:</span> <span class="string">&quot;g&#39;.ekMeasure &le; ekMeasure&quot;</span>
      <span class="keyword1">unfolding</span> g&#39;.ekMeasure_def ekMeasure_def
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>simp only<span class="delimiter">:</span> Veq uE_eq CONN CONN2 if_True<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule mlex_leI<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> EQ<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule card_mono<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> simp
      <span class="keyword1">by</span> fact
    <span class="keyword1">note</span> G1 G2  
  <span class="keyword1">}</span> <span class="keyword1">ultimately</span> <span class="keyword3">show</span> 
    <span class="string">&quot;g&#39;.ekMeasure &le; ekMeasure&quot;</span> 
    <span class="string">&quot;edges - Graph.E c&#39; &ne; {} ==&gt; g&#39;.ekMeasure &lt; ekMeasure&quot;</span>
    <span class="keyword1">using</span> less_linear<span class="delimiter">[</span>of <span class="string">&quot;g&#39;.min_dist s t&quot;</span> <span class="string">&quot;min_dist s t&quot;</span><span class="delimiter">]</span>   
    <span class="keyword1"><span class="improper">apply</span></span> -
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>fastforce<span class="delimiter">)</span><span class="delimiter">+</span>
    <span class="keyword1"><span class="improper">done</span></span>

<span class="keyword1">qed</span>

<span class="keyword2">end</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Analysis locale&#8250;</span> 

<span class="keyword1">text</span> <span class="cartouche">&#8249;As a first step to the analysis setup, we characterize
  the effect of augmentation on the residual graph
  &#8250;</span>
<span class="keyword1">context</span> Graph
<span class="keyword2">begin</span>

<span class="keyword1">definition</span> <span class="string">&quot;augment_cf edges cap &equiv; &lambda;e. 
  if e&isin;edges then c e - cap 
  else if prod.swap e&isin;edges then c e + cap
  else c e&quot;</span>

<span class="keyword1">lemma</span> augment_cf_empty<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;augment_cf {} cap = c&quot;</span> 
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> augment_cf_def<span class="delimiter">)</span>

<span class="keyword1">lemma</span> augment_cf_ss_V<span class="delimiter">:</span> <span class="string">&quot;[|edges &sube; E|] ==&gt; Graph.V (augment_cf edges cap) &sube; V&quot;</span>  
  <span class="keyword1">unfolding</span> Graph.E_def Graph.V_def
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp add<span class="delimiter">:</span> augment_cf_def<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
  
<span class="keyword1">lemma</span> augment_saturate<span class="delimiter">:</span>
  <span class="keyword2">fixes</span> edges e
  <span class="keyword2">defines</span> <span class="string">&quot;c&#39; &equiv; augment_cf edges (c e)&quot;</span>
  <span class="keyword2">assumes</span> EIE<span class="delimiter">:</span> <span class="string">&quot;e&isin;edges&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;e&notin;Graph.E c&#39;&quot;</span>
  <span class="keyword1">using</span> EIE <span class="keyword1">unfolding</span> c&#39;_def augment_cf_def
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> Graph.E_def<span class="delimiter">)</span>
  

<span class="keyword1">lemma</span> augment_cf_split<span class="delimiter">:</span> 
  <span class="keyword2">assumes</span> <span class="string">&quot;edges1 &cap; edges2 = {}&quot;</span> <span class="string">&quot;edges1&macr; &cap; edges2 = {}&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;Graph.augment_cf c (edges1 &cup; edges2) cap 
    = Graph.augment_cf (Graph.augment_cf c edges1 cap) edges2 cap&quot;</span>  
  <span class="keyword1">using</span> assms
  <span class="keyword1">by</span> <span class="delimiter">(</span>fastforce simp<span class="delimiter">:</span> Graph.augment_cf_def intro<span class="delimiter">!</span><span class="delimiter">:</span> ext<span class="delimiter">)</span>
      
<span class="keyword2">end</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Graph&#8250;</span>

<span class="keyword1">context</span> NFlow <span class="keyword2">begin</span>

<span class="keyword1">lemma</span> augmenting_edge_no_swap<span class="delimiter">:</span> <span class="string">&quot;isAugmenting p ==&gt; set p &cap; (set p)&macr; = {}&quot;</span>
  <span class="keyword1">using</span> cf.isSPath_nt_parallel_pf
  <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isAugmenting_def<span class="delimiter">)</span>

<span class="keyword1">lemma</span> aug_flows_finite<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span> 
  <span class="string">&quot;finite {cf e |e. e &isin; set p}&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule finite_subset<span class="delimiter">[</span><span class="keyword2">where</span> B<span class="delimiter">=</span><span class="string">&quot;cf`set p&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword1">by</span> auto

<span class="keyword1">lemma</span> aug_flows_finite&#39;<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span> 
  <span class="string">&quot;finite {cf (u,v) |u v. (u,v) &isin; set p}&quot;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule finite_subset<span class="delimiter">[</span><span class="keyword2">where</span> B<span class="delimiter">=</span><span class="string">&quot;cf`set p&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword1">by</span> auto

<span class="keyword1">lemma</span> augment_alt<span class="delimiter">:</span>
  <span class="keyword2">assumes</span> AUG<span class="delimiter">:</span> <span class="string">&quot;isAugmenting p&quot;</span>
  <span class="keyword2">defines</span> <span class="string">&quot;f&#39; &equiv; augment (augmentingFlow p)&quot;</span>
  <span class="keyword2">defines</span> <span class="string">&quot;cf&#39; &equiv; residualGraph c f&#39;&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;cf&#39; = Graph.augment_cf cf (set p) (bottleNeck p)&quot;</span>
<span class="keyword1">proof</span> -
  <span class="keyword1">{</span>
    <span class="keyword3">fix</span> u v
    <span class="keyword3">assume</span> <span class="string">&quot;(u,v)&isin;set p&quot;</span>
    <span class="keyword1">hence</span> <span class="string">&quot;bottleNeck p &le; cf (u,v)&quot;</span>
      <span class="keyword1">unfolding</span> bottleNeck_def <span class="keyword1">by</span> <span class="delimiter">(</span>auto intro<span class="delimiter">:</span> Min_le<span class="delimiter">)</span>
  <span class="keyword1">}</span> <span class="keyword1">note</span> bn_smallerI <span class="delimiter">=</span> this

  <span class="keyword1">{</span>
    <span class="keyword3">fix</span> u v
    <span class="keyword3">assume</span> <span class="string">&quot;(u,v)&isin;set p&quot;</span>
    <span class="keyword1">hence</span> <span class="string">&quot;(u,v)&isin;cf.E&quot;</span> <span class="keyword1">using</span> AUG cf.isPath_edgeset
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isAugmenting_def cf.isSimplePath_def<span class="delimiter">)</span>
    <span class="keyword1">hence</span> <span class="string">&quot;(u,v)&isin;E &or; (v,u)&isin;E&quot;</span> <span class="keyword1">using</span> cfE_ss_invE <span class="keyword1">by</span> <span class="delimiter">(</span>auto<span class="delimiter">)</span>
  <span class="keyword1">}</span> <span class="keyword1">note</span> edge_or_swap <span class="delimiter">=</span> this 

  <span class="keyword3">show</span> <span class="var">?thesis</span>  
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule ext<span class="delimiter">)</span>
    <span class="keyword1">unfolding</span> cf.augment_cf_def
    <span class="keyword1">using</span> augmenting_edge_no_swap<span class="delimiter">[</span>OF AUG<span class="delimiter">]</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto 
      simp<span class="delimiter">:</span> augment_def augmentingFlow_def cf&#39;_def f&#39;_def residualGraph_def
      split<span class="delimiter">:</span> prod.splits
      dest<span class="delimiter">:</span> edge_or_swap 
      <span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">done</span></span>
<span class="keyword1">qed</span>    


<span class="keyword1">lemma</span> augmenting_path_contains_bottleneck<span class="delimiter">:</span>
  <span class="keyword2">assumes</span> <span class="string">&quot;isAugmenting p&quot;</span>
  <span class="keyword2">obtains</span> e <span class="keyword2">where</span> <span class="string">&quot;e&isin;set p&quot;</span> <span class="string">&quot;cf e = bottleNeck p&quot;</span> 
<span class="keyword1">proof</span> -  
  <span class="keyword1">from</span> assms <span class="keyword1">have</span> <span class="string">&quot;p&ne;[]&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> isAugmenting_def s_not_t<span class="delimiter">)</span>
  <span class="keyword1">hence</span> <span class="string">&quot;{cf e | e. e &isin; set p} &ne; {}&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>cases p<span class="delimiter">)</span> auto
  <span class="keyword1">with</span> Min_in<span class="delimiter">[</span>OF aug_flows_finite this<span class="delimiter">,</span> folded bottleNeck_def<span class="delimiter">]</span>
    <span class="keyword3">obtain</span> e <span class="keyword2">where</span> <span class="string">&quot;e&isin;set p&quot;</span> <span class="string">&quot;cf e = bottleNeck p&quot;</span> <span class="keyword1">by</span> auto
  <span class="keyword3">thus</span> <span class="var">?thesis</span> <span class="keyword1">by</span> <span class="delimiter">(</span>blast intro<span class="delimiter">:</span> that<span class="delimiter">)</span>
<span class="keyword1">qed</span>  
        
<span class="keyword1">text</span> <span class="cartouche">&#8249;Finally, we show the main theorem used for termination and complexity 
  analysis: Augmentation with a shortest path decreases the measure function.&#8250;</span>
<span class="keyword1">theorem</span> shortest_path_decr_ek_measure<span class="delimiter">:</span>
  <span class="keyword2">fixes</span> p
  <span class="keyword2">assumes</span> SP<span class="delimiter">:</span> <span class="string">&quot;Graph.isShortestPath cf s p t&quot;</span>
  <span class="keyword2">defines</span> <span class="string">&quot;f&#39; &equiv; augment (augmentingFlow p)&quot;</span>
  <span class="keyword2">defines</span> <span class="string">&quot;cf&#39; &equiv; residualGraph c f&#39;&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;ek_analysis_defs.ekMeasure cf&#39; s t &lt; ek_analysis_defs.ekMeasure cf s t&quot;</span>
<span class="keyword1">proof</span> -
  <span class="keyword1">interpret</span> cf<span class="delimiter">!</span><span class="delimiter">:</span> ek_analysis cf 
    <span class="keyword1"><span class="improper">apply</span></span> unfold_locales
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> resV_netV finite_V<span class="delimiter">)</span>

  <span class="keyword1">interpret</span> cf&#39;<span class="delimiter">!</span><span class="delimiter">:</span> ek_analysis_defs cf&#39; <span class="keyword1">.</span>

  <span class="keyword1">from</span> SP <span class="keyword1">have</span> AUG<span class="delimiter">:</span> <span class="string">&quot;isAugmenting p&quot;</span> 
    <span class="keyword1">unfolding</span> isAugmenting_def cf.isShortestPath_alt <span class="keyword1">by</span> simp

  <span class="keyword1">note</span> BNGZ <span class="delimiter">=</span> bottleNeck_gzero<span class="delimiter">[</span>OF AUG<span class="delimiter">]</span>  

  <span class="keyword1">have</span> cf&#39;_alt<span class="delimiter">:</span> <span class="string">&quot;cf&#39; = cf.augment_cf (set p) (bottleNeck p)&quot;</span>
    <span class="keyword1">using</span> augment_alt<span class="delimiter">[</span>OF AUG<span class="delimiter">]</span> <span class="keyword1">unfolding</span> cf&#39;_def f&#39;_def <span class="keyword1">by</span> simp

  <span class="keyword3">obtain</span> e <span class="keyword2">where</span>
    EIP<span class="delimiter">:</span> <span class="string">&quot;e&isin;set p&quot;</span> <span class="keyword2">and</span> EBN<span class="delimiter">:</span> <span class="string">&quot;cf e = bottleNeck p&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>rule augmenting_path_contains_bottleneck<span class="delimiter">[</span>OF AUG<span class="delimiter">]</span><span class="delimiter">)</span> auto

  <span class="keyword1">have</span> ENIE&#39;<span class="delimiter">:</span> <span class="string">&quot;e&notin;cf&#39;.E&quot;</span> 
    <span class="keyword1">using</span> cf.augment_saturate<span class="delimiter">[</span>OF EIP<span class="delimiter">]</span> EBN <span class="keyword1">by</span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> cf&#39;_alt<span class="delimiter">)</span>
  
  <span class="keyword1">{</span> <span class="keyword3">fix</span> e  
    <span class="keyword1">have</span> <span class="string">&quot;cf e + bottleNeck p &ne; 0&quot;</span> <span class="keyword1">using</span> resE_nonNegative<span class="delimiter">[</span>of e<span class="delimiter">]</span> BNGZ <span class="keyword1">by</span> auto 
  <span class="keyword1">}</span> <span class="keyword1">note</span> <span class="delimiter">[</span>simp<span class="delimiter">]</span> <span class="delimiter">=</span> this  
  
  <span class="keyword1">{</span> <span class="keyword3">fix</span> e
    <span class="keyword3">assume</span> <span class="string">&quot;e&isin;set p&quot;</span>
    <span class="keyword1">hence</span> <span class="string">&quot;e &isin; cf.E&quot;</span>
      <span class="keyword1">using</span> cf.shortestPath_is_path<span class="delimiter">[</span>OF SP<span class="delimiter">]</span> cf.isPath_edgeset <span class="keyword1">by</span> blast
    <span class="keyword1">hence</span> <span class="string">&quot;cf e &gt; 0 &and; cf e &ne; 0&quot;</span> <span class="keyword1">using</span> resE_positive<span class="delimiter">[</span>of e<span class="delimiter">]</span> <span class="keyword1">by</span> auto
  <span class="keyword1">}</span> <span class="keyword1">note</span> <span class="delimiter">[</span>simp<span class="delimiter">]</span> <span class="delimiter">=</span> this

  <span class="keyword3">show</span> <span class="var">?thesis</span> 
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule cf.measure_decr<span class="delimiter">(</span>2<span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>simp_all add<span class="delimiter">:</span> s_node<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule SP<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule order_refl<span class="delimiter">)</span>

    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule conjI<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>unfold Graph.E_def<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> cf&#39;_alt cf.augment_cf_def<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>

      <span class="keyword1">using</span> augmenting_edge_no_swap<span class="delimiter">[</span>OF AUG<span class="delimiter">]</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>fastforce 
        simp<span class="delimiter">:</span> cf&#39;_alt cf.augment_cf_def Graph.E_def 
        simp del<span class="delimiter">:</span> cf.zero_cap_simp<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
      
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>unfold Graph.E_def<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> cf&#39;_alt cf.augment_cf_def<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
    <span class="keyword1">using</span> EIP ENIE&#39; <span class="keyword1"><span class="improper">apply</span></span> auto <span class="delimiter">[</span><span class="delimiter">]</span>
    <span class="keyword1"><span class="improper">done</span></span>
<span class="keyword1">qed</span>    

<span class="keyword2">end</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Network with flow&#8250;</span>

<span class="keyword1">subsubsection</span> <span class="cartouche">&#8249;Total Correctness&#8250;</span>
<span class="keyword1">context</span> Network <span class="keyword2">begin</span>
<span class="keyword1">text</span> <span class="cartouche">&#8249;We specify the total correct version of Edmonds-Karp algorithm.&#8250;</span>
<span class="keyword1">definition</span> <span class="string">&quot;edka &equiv; do {
  let f = (&lambda;_. 0);

  (f,_) \&lt;leftarrow&gt; while<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8663;</span><sup>fofu_invar<span class="hidden">&#8662;</span></sup>
    (&lambda;(f,brk). &not;brk) 
    (&lambda;(f,_). do {
      p \&lt;leftarrow&gt; find_shortest_augmenting_spec f;
      case p of 
        None =&gt; return (f,True)
      | Some p =&gt; do {
          assert (p&ne;[]);
          assert (NFlow.isAugmenting c s t f p);
          assert (Graph.isShortestPath (residualGraph c f) s p t);
          let f&#39; = NFlow.augmentingFlow c f p;
          let f = NFlow.augment c f f&#39;;
          assert (NFlow c s t f);
          return (f, False)
        }  
    })
    (f,False);
  assert (NFlow c s t f);
  return f 
}&quot;</span>

<span class="keyword1">text</span> <span class="cartouche">&#8249;Based on the measure function, it is easy to obtain a well-founded 
  relation that proves termination of the loop in the Edmonds-Karp algorithm:&#8250;</span>
<span class="keyword1">definition</span> <span class="string">&quot;edka_wf_rel &equiv; inv_image 
  (less_than_bool &lt;*lex*&gt; measure (&lambda;cf. ek_analysis_defs.ekMeasure cf s t))
  (&lambda;(f,brk). (&not;brk,residualGraph c f))&quot;</span>

<span class="keyword1">lemma</span> edka_wf_rel_wf<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;wf edka_wf_rel&quot;</span>
  <span class="keyword1">unfolding</span> edka_wf_rel_def <span class="keyword1">by</span> auto

<span class="keyword1">text</span> <span class="cartouche">&#8249;The following theorem states that the total correct 
  version of Edmonds-Karp algorithm refines the partial correct one.&#8250;</span>  
<span class="keyword1">theorem</span> edka_refine<span class="delimiter">[</span>refine<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;edka &le; \&lt;Down&gt;Id edka_partial&quot;</span>
  <span class="keyword1">unfolding</span> edka_def edka_partial_def
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>refine_rcg bind_refine&#39; 
    WHILEIT_refine_WHILEI<span class="delimiter">[</span><span class="keyword2">where</span> V<span class="delimiter">=</span>edka_wf_rel<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>refine_dref_type<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>simp<span class="delimiter">;</span> fail<span class="delimiter">)</span>

  <span class="keyword1">txt</span> <span class="cartouche">&#8249;Unfortunately, the verification condition for introducing 
    the variant requires a bit of manual massaging to be solved:&#8250;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>simp<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>erule bind_sim_select_rule<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto split<span class="delimiter">:</span> option.split 
    simp<span class="delimiter">:</span> assert_bind_spec_conv 
    simp<span class="delimiter">:</span> find_shortest_augmenting_spec_def
    simp<span class="delimiter">:</span> edka_wf_rel_def NFlow.shortest_path_decr_ek_measure
  <span class="delimiter">;</span> fail<span class="delimiter">)</span>

  <span class="keyword1">txt</span> <span class="cartouche">&#8249;The other VCs are straightforward&#8250;</span>
  <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>vc_solve<span class="delimiter">)</span>
  <span class="keyword1"><span class="improper">done</span></span>

<span class="keyword1">subsubsection</span> <span class="cartouche">&#8249;Complexity Analysis&#8250;</span>

<span class="keyword1">text</span> <span class="cartouche">&#8249;For the complexity analysis, we additionally show that the measure
  function is bounded by $O(VE)$. Note that our absolute bound is not as 
  precise as possible, but clearly $O(VE)$.&#8250;</span>
  <span class="comment">(* TODO: #edgesSp even bound by |E|, as either e or swap e lays on shortest path! *)</span>
<span class="keyword1">lemma</span> ekMeasure_upper_bound<span class="delimiter">:</span> 
  <span class="string">&quot;ek_analysis_defs.ekMeasure (residualGraph c (&lambda;_. 0)) s t 
   &lt; 2 * card V * card E + card V&quot;</span>
<span class="keyword1">proof</span> -  
  <span class="keyword1">interpret</span> NFlow c s t <span class="string">&quot;(&lambda;_. 0)&quot;</span>
    <span class="keyword1">unfolding</span> NFlow_def Flow_def <span class="keyword1">using</span> Network_axioms 
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> s_node t_node cap_non_negative<span class="delimiter">)</span>

  <span class="keyword1">interpret</span> ek<span class="delimiter">!</span><span class="delimiter">:</span> ek_analysis cf  
    <span class="keyword1">by</span> unfold_locales auto

  <span class="keyword1">have</span> cardV_positive<span class="delimiter">:</span> <span class="string">&quot;card V &gt; 0&quot;</span> <span class="keyword2">and</span> cardE_positive<span class="delimiter">:</span> <span class="string">&quot;card E &gt; 0&quot;</span>
    <span class="keyword1">using</span> card_0_eq<span class="delimiter">[</span>OF finite_V<span class="delimiter">]</span> V_not_empty <span class="keyword1"><span class="improper">apply</span></span> blast
    <span class="keyword1">using</span> card_0_eq<span class="delimiter">[</span>OF finite_E<span class="delimiter">]</span> E_not_empty <span class="keyword1"><span class="improper">apply</span></span> blast
    <span class="keyword1"><span class="improper">done</span></span>

  <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">proof</span> <span class="delimiter">(</span>cases <span class="string">&quot;cf.connected s t&quot;</span><span class="delimiter">)</span>  
    <span class="keyword3">case</span> False <span class="keyword1">hence</span> <span class="string">&quot;ek.ekMeasure = 0&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> ek.ekMeasure_def<span class="delimiter">)</span>
    <span class="keyword1">with</span> cardV_positive cardE_positive <span class="keyword3">show</span> <span class="var">?thesis</span>
      <span class="keyword1">by</span> auto
  <span class="keyword1">next</span>
    <span class="keyword3">case</span> True 

    <span class="keyword1">have</span> <span class="string">&quot;cf.min_dist s t &gt; 0&quot;</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> Graph.min_dist_z_iff True s_not_t<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">done</span></span>

    <span class="keyword1">have</span> <span class="string">&quot;cf = c&quot;</span>  
      <span class="keyword1">unfolding</span> residualGraph_def E_def
      <span class="keyword1">by</span> auto
    <span class="keyword1">hence</span> <span class="string">&quot;ek.uE = E&cup;E&macr;&quot;</span> <span class="keyword1">unfolding</span> ek.uE_def <span class="keyword1">by</span> simp

    <span class="keyword1">from</span> True <span class="keyword1">have</span> <span class="string">&quot;ek.ekMeasure 
      = (card cf.V - cf.min_dist s t) * (card ek.uE + 1) + (card (ek.spEdges))&quot;</span>
      <span class="keyword1">unfolding</span> ek.ekMeasure_def <span class="keyword1">by</span> simp
    <span class="keyword1">also</span> <span class="keyword1">from</span> 
      mlex_bound<span class="delimiter">[</span>of <span class="string">&quot;card cf.V - cf.min_dist s t&quot;</span> <span class="string">&quot;card V&quot;</span><span class="delimiter">,</span> 
                 OF _ ek.card_spEdges_less<span class="delimiter">]</span>
    <span class="keyword1">have</span> <span class="string">&quot;&hellip; &lt; card V * (card ek.uE+1)&quot;</span> 
      <span class="keyword1">using</span> <span class="cartouche">&#8249;cf.min_dist s t &gt; 0&#8250;</span> <span class="cartouche">&#8249;card V &gt; 0&#8250;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> resV_netV<span class="delimiter">)</span>
    <span class="keyword1">also</span> <span class="keyword1">have</span> <span class="string">&quot;card ek.uE &le; 2*card E&quot;</span> <span class="keyword1">unfolding</span> <span class="cartouche">&#8249;ek.uE = E&cup;E&macr;&#8250;</span> 
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule order_trans<span class="delimiter">)</span>
      <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule card_Un_le<span class="delimiter">)</span>
      <span class="keyword1">by</span> auto
    <span class="keyword1">finally</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> algebra_simps<span class="delimiter">)</span>
  <span class="keyword1">qed</span>  
<span class="keyword1">qed</span>  

<span class="keyword1">text</span> <span class="cartouche">&#8249;Finally, we present a version of the Edmonds-Karp algorithm 
  which is instrumented with a loop counter, and asserts that
  there are less than $2|V||E|+|V| = O(|V||E|)$ iterations.

  Note that we only count the non-breaking loop iterations.
  &#8250;</span>

<span class="keyword1">text</span> <span class="cartouche">&#8249;The refinement is achieved by a refinement relation, coupling the 
  instrumented loop state with the uninstrumented one&#8250;</span>
<span class="keyword1">definition</span> <span class="string">&quot;edkac_rel &equiv; {((f,brk,itc), (f,brk)) | f brk itc.
    itc + ek_analysis_defs.ekMeasure (residualGraph c f) s t 
  &lt; 2 * card V * card E + card V
}&quot;</span>

<span class="keyword1">definition</span> <span class="string">&quot;edka_complexity &equiv; do {
  let f = (&lambda;_. 0);

  (f,_,itc) \&lt;leftarrow&gt; while<span class="hidden">&#8681;</span><sub>T</sub> 
    (&lambda;(f,brk,_). &not;brk) 
    (&lambda;(f,_,itc). do {
      p \&lt;leftarrow&gt; find_shortest_augmenting_spec f;
      case p of 
        None =&gt; return (f,True,itc)
      | Some p =&gt; do {
          let f&#39; = NFlow.augmentingFlow c f p;
          let f = NFlow.augment c f f&#39;;
          return (f, False,itc + 1)
        }  
    })
    (f,False,0);
  assert (itc &lt; 2 * card V * card E + card V);
  return f 
}&quot;</span>
  
<span class="keyword1">lemma</span> edka_complexity_refine<span class="delimiter">:</span> <span class="string">&quot;edka_complexity &le; \&lt;Down&gt;Id edka&quot;</span>
<span class="keyword1">proof</span> -
  <span class="keyword1">have</span> <span class="delimiter">[</span>refine_dref_RELATES<span class="delimiter">]</span><span class="delimiter">:</span> 
    <span class="string">&quot;RELATES edkac_rel&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> RELATES_def<span class="delimiter">)</span>

  <span class="keyword3">show</span> <span class="var">?thesis</span>  
    <span class="keyword1">unfolding</span> edka_complexity_def edka_def
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>refine_rcg<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>refine_dref_type<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>vc_solve simp<span class="delimiter">:</span> edkac_rel_def<span class="delimiter">)</span>
    <span class="keyword1">using</span> ekMeasure_upper_bound <span class="keyword1"><span class="improper">apply</span></span> auto <span class="delimiter">[</span><span class="delimiter">]</span>
    <span class="keyword1"><span class="improper">apply</span></span> auto <span class="delimiter">[</span><span class="delimiter">]</span>
    <span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>drule <span class="delimiter">(</span>1<span class="delimiter">)</span> NFlow.shortest_path_decr_ek_measure<span class="delimiter">;</span> auto<span class="delimiter">)</span>
    <span class="keyword1"><span class="improper">done</span></span>
<span class="keyword1">qed</span>    

<span class="keyword1">text</span> <span class="cartouche">&#8249;We show that this algorithm never fails, and computes a maximum flow.&#8250;</span>
<span class="keyword1">theorem</span> <span class="string">&quot;edka_complexity &le; (spec f. isMaxFlow f)&quot;</span>
<span class="keyword1">proof</span> -  
  <span class="keyword1">note</span> edka_complexity_refine
  <span class="keyword1">also</span> <span class="keyword1">note</span> edka_refine
  <span class="keyword1">also</span> <span class="keyword1">note</span> edka_partial_refine
  <span class="keyword1">also</span> <span class="keyword1">note</span> fofu_partial_correct
  <span class="keyword1">finally</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">.</span>
<span class="keyword1">qed</span>  


<span class="keyword2">end</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Network&#8250;</span>
<span class="keyword2">end</span> <span class="delimiter">--</span> <span class="cartouche">&#8249;Theory&#8250;</span>
</pre>

</div>
</body>
</html>
