<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Fofu_Abs_Base (Isabelle2015: May 2015)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Fofu_Abs_Base</h1>

<span class="command">theory</span> <span class="name">Fofu_Abs_Base</span><br/>
<span class="keyword">imports</span> <a href="https://isabelle.in.tum.de/dist/library/HOL/HOL/Complex_Main.html"><span class="name">Complex_Main</span></a> <a href="http://afp.sourceforge.net/browser_info/current/AFP/Automatic_Refinement/Misc.html"><span class="name">Misc</span></a><br/>

</div>
<div class="source">
<pre><span class="keyword1">theory</span> Fofu_Abs_Base
<span class="keyword2">imports</span> Complex_Main Misc
<span class="keyword2">begin</span>  

  <span class="keyword1">context</span>
  <span class="keyword2">begin</span>
    <span class="keyword1">definition</span> <span class="string">&quot;isDisjoint s &equiv; &forall; x y. x &isin; s &and; y &isin; s &and; x &ne; y --&gt; x &cap; y = {}&quot;</span>
  <span class="keyword2">end</span>
  
  <span class="keyword1">locale</span> setExt
  <span class="keyword2">begin</span>
    <span class="keyword1">definition</span> toList <span class="delimiter">::</span> <span class="string">&quot;&#39;a set =&gt; &#39;a list&quot;</span> <span class="keyword2">where</span>
      <span class="string">&quot;toList s &equiv; (SOME l. distinct l &and; set l = s)&quot;</span>
      
    <span class="keyword1">lemma</span> set_toList<span class="delimiter">:</span> <span class="string">&quot;finite s ==&gt; set (toList s) = s&quot;</span>
      <span class="keyword1">unfolding</span> toList_def
      <span class="keyword1">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>mono_tags<span class="delimiter">,</span> lifting<span class="delimiter">)</span> distinct_remdups finite_list set_remdups someI_ex<span class="delimiter">)</span>
      
    <span class="keyword1">lemma</span> toList_Nil<span class="delimiter">:</span> <span class="string">&quot;finite s ==&gt; toList s = [] ==&gt; s = {}&quot;</span>
      <span class="keyword1">unfolding</span> toList_def
      <span class="keyword1">by</span> <span class="delimiter">(</span>metis empty_set set_toList toList_def<span class="delimiter">)</span>
      
    <span class="keyword1">lemma</span> finite_fun_set_1<span class="delimiter">:</span> <span class="string">&quot;finite F ==&gt; finite A ==&gt; finite {f a |f a. f &isin; F &and; a &isin; A}&quot;</span>
      <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;_ _ ==&gt; _ _ ==&gt; finite ?SFA&quot;</span><span class="delimiter">)</span>
      <span class="keyword1">proof</span> -
        <span class="keyword3">assume</span> asm1<span class="delimiter">:</span> <span class="string">&quot;finite F&quot;</span>
        <span class="keyword3">assume</span> asm2<span class="delimiter">:</span> <span class="string">&quot;finite A&quot;</span>
        <span class="keyword1">have</span> <span class="string">&quot;&forall;f. finite {f a | a. a &isin; A}&quot;</span> <span class="keyword1">using</span> asm2 <span class="keyword1">by</span> auto
        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;finite (\&lt;Union&gt;f&isin;F. {f a | a. a &isin; A})&quot;</span> <span class="keyword1">using</span> asm1 <span class="keyword1">by</span> auto
        <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;?SFA = (\&lt;Union&gt;f&isin;F. {f a | a. a &isin; A})&quot;</span> <span class="keyword1">by</span> auto
        <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
      <span class="keyword1">qed</span>
          
    <span class="keyword1">lemma</span> finite_fun_set_2<span class="delimiter">:</span> <span class="string">&quot;finite A ==&gt; finite B ==&gt; finite {f m n | m n. m &isin; A &and; n &isin; B}&quot;</span>
      <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;_ _ ==&gt; _ _ ==&gt; finite ?OS&quot;</span><span class="delimiter">)</span>
      <span class="keyword1">proof</span> -
        <span class="keyword3">assume</span> asm1<span class="delimiter">:</span> <span class="string">&quot;finite A&quot;</span>
        <span class="keyword3">assume</span> asm2<span class="delimiter">:</span> <span class="string">&quot;finite B&quot;</span>
        <span class="keyword1">have</span> <span class="string">&quot;finite {f a | a. a &isin; A }&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;finite ?SFA&quot;</span><span class="delimiter">)</span> <span class="keyword1">using</span> asm1 <span class="keyword1">by</span> auto
        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;finite {g b | g b. g &isin; ?SFA &and; b &isin; B}&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;finite ?AS&quot;</span><span class="delimiter">)</span>
          <span class="keyword1">using</span> finite_fun_set_1<span class="delimiter">[</span>of <span class="var">?SFA</span> B<span class="delimiter">]</span> asm2 <span class="keyword1">by</span> auto
        <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;?OS = ?AS&quot;</span> <span class="keyword1">by</span> auto
        <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
      <span class="keyword1">qed</span>
  <span class="keyword2">end</span>
  
  <span class="keyword1">locale</span> setsumExt
  <span class="keyword2">begin</span>
    <span class="keyword1">lemma</span> singleton<span class="delimiter">:</span> <span class="string">&quot;(&sum;y &isin; {x}. f y) = f x&quot;</span> 
      <span class="keyword1">by</span> <span class="delimiter">(</span>metis add_0_right empty_iff finite.emptyI setsum.empty setsum.insert<span class="delimiter">)</span>
      
    <span class="keyword1">lemma</span> decomp_1<span class="delimiter">:</span> <span class="string">&quot;finite A ==&gt; a &notin; A ==&gt; (&sum;x &isin; (A &cup; {a}). f x) = f a + (&sum;x &isin; A. f x)&quot;</span>
      <span class="keyword1">proof</span> -
        <span class="keyword3">assume</span> asm1<span class="delimiter">:</span> <span class="string">&quot;finite A&quot;</span>
        <span class="keyword3">assume</span> asm2<span class="delimiter">:</span> <span class="string">&quot;a &notin; A&quot;</span>
        <span class="keyword1">have</span> <span class="string">&quot;{a} &cap; A = {} &and; finite {a}&quot;</span> <span class="keyword1">using</span> asm2 <span class="keyword1">by</span> blast
        <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(&sum;x &isin; (A &cup; {a}). f x) = (&sum;x &isin; {a}. f x) + (&sum;x &isin; A. f x)&quot;</span>
          <span class="keyword1">using</span> setsum.union_disjoint<span class="delimiter">[</span>of <span class="string">&quot;{a}&quot;</span> <span class="string">&quot;A&quot;</span> f<span class="delimiter">]</span> asm1 <span class="keyword1">by</span> auto
        <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;(&sum;x &isin; {a}. f x) = f a&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>mono_tags<span class="delimiter">)</span> add.commute empty_iff
            finite.emptyI monoid_add_class.add.left_neutral setsum.empty setsum.insert<span class="delimiter">)</span>
        <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
      <span class="keyword1">qed</span>
      
    <span class="keyword1">lemma</span> decomp_2<span class="delimiter">:</span> <span class="string">&quot;finite s ==&gt; finite {g y a | y a. p y a} ==&gt;
      (&forall;x y a b. x &ne; y --&gt; g x a &ne; g y b) ==&gt; (&sum;x &isin; {g y a | y a. y &isin; s &and; p y a}. f x) =
      (&sum;y &isin; s. (&sum;x &isin; {g y a | a. p y a}. f x))&quot;</span>
      <span class="keyword1">proof</span> -
        <span class="keyword3">assume</span> asm1<span class="delimiter">:</span> <span class="string">&quot;finite s&quot;</span>
        <span class="keyword3">assume</span> asm2<span class="delimiter">:</span> <span class="string">&quot;finite {g y a | y a. p y a}&quot;</span>
        <span class="keyword3">assume</span> asm3<span class="delimiter">:</span> <span class="string">&quot;(&forall;x y a b. x &ne; y --&gt; g x a &ne; g y b)&quot;</span>
        <span class="keyword1">{</span>
          <span class="keyword3">fix</span> l
          <span class="keyword1">have</span> <span class="string">&quot;distinct l ==&gt; finite (set l) ==&gt; finite {g y a | y a. p y a}
            ==&gt; (&forall;x y a b. x &ne; y --&gt; g x a &ne; g y b) ==&gt; 
            (&sum;x &isin; {g y a | y a. y &isin; (set l) &and; p y a}. f x) =
            (&sum;y &isin; (set l). (&sum;x &isin; {g y a | a. p y a}. f x))&quot;</span>
            <span class="keyword1">proof</span> <span class="delimiter">(</span>induction l<span class="delimiter">)</span>
              <span class="keyword3">case</span> Nil
                <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">by</span> auto
            <span class="keyword1">next</span>
              <span class="keyword3">case</span> <span class="delimiter">(</span>Cons e es<span class="delimiter">)</span>
                <span class="keyword1">let</span> <span class="var">?BSET</span> <span class="delimiter">=</span> <span class="string">&quot;&lambda;A. {g y a | y a. y &isin; A &and; p y a}&quot;</span>
                <span class="keyword1">let</span> <span class="var">?SSUM</span> <span class="delimiter">=</span> <span class="string">&quot;&lambda;S. (&sum;x &isin; S. f x)&quot;</span>
                <span class="keyword1">{</span>
                  <span class="keyword1">note</span> f <span class="delimiter">=</span> setsum.union_disjoint<span class="delimiter">[</span>of <span class="string">&quot;?BSET {e}&quot;</span> <span class="string">&quot;?BSET (set es)&quot;</span> f<span class="delimiter">]</span>
                  <span class="keyword1">{</span>
                    <span class="keyword1">note</span> f <span class="delimiter">=</span> finite_subset<span class="delimiter">[</span>of _ <span class="string">&quot;{g y a | y a. p y a}&quot;</span><span class="delimiter">]</span>
                    <span class="keyword1">have</span> f1<span class="delimiter">:</span> <span class="string">&quot;?BSET {e} &sube; {g y a | y a. p y a}&quot;</span> <span class="keyword1">by</span> auto
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;finite (?BSET {e})&quot;</span> <span class="keyword1">using</span> f<span class="delimiter">[</span>OF f1 Cons.prems<span class="delimiter">(</span>3<span class="delimiter">)</span><span class="delimiter">]</span> <span class="keyword1">by</span> blast
                  <span class="keyword1">}</span> <span class="keyword1">note</span> f1 <span class="delimiter">=</span> this
                  <span class="keyword1">{</span>
                    <span class="keyword1">note</span> f <span class="delimiter">=</span> finite_subset<span class="delimiter">[</span>of _ <span class="string">&quot;{g y a | y a. p y a}&quot;</span><span class="delimiter">]</span>
                    <span class="keyword1">have</span> f1<span class="delimiter">:</span> <span class="string">&quot;?BSET (set es) &sube; {g y a | y a. p y a}&quot;</span> <span class="keyword1">by</span> auto
                    <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;finite (?BSET (set es))&quot;</span> <span class="keyword1">using</span> f<span class="delimiter">[</span>OF f1 Cons.prems<span class="delimiter">(</span>3<span class="delimiter">)</span><span class="delimiter">]</span> <span class="keyword1">by</span> blast
                  <span class="keyword1">}</span> <span class="keyword1">note</span> f2 <span class="delimiter">=</span> this
                  <span class="keyword1">have</span> f3<span class="delimiter">:</span> <span class="string">&quot;?BSET {e} &cap; ?BSET (set es) = {}&quot;</span>
                    <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
                      <span class="keyword3">assume</span> <span class="string">&quot;&not; ?BSET {e} &cap; ?BSET (set es) = {}&quot;</span>
                      <span class="keyword1">then</span> <span class="keyword3">obtain</span> y1 a1 y2 a2 <span class="keyword2">where</span> obt1<span class="delimiter">:</span> <span class="string">&quot;(g y1 a1) = (g y2 a2) &and; 
                        y1 &isin; {e} &and; y2 &isin; (set es)&quot;</span> <span class="keyword1">by</span> blast
                      <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;y1 = y2&quot;</span> <span class="keyword1">using</span> Cons.prems<span class="delimiter">(</span>4<span class="delimiter">)</span> <span class="keyword1">by</span> auto
                      <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;&not; distinct (e # es)&quot;</span> <span class="keyword1">using</span> obt1 <span class="keyword1">by</span> auto
                      <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> Cons.prems<span class="delimiter">(</span>1<span class="delimiter">)</span> <span class="keyword1">by</span> auto 
                    <span class="keyword1">qed</span>
                  <span class="keyword1">have</span> f4<span class="delimiter">:</span> <span class="string">&quot;?BSET (set (e # es)) = ?BSET {e} &cup; ?BSET (set es)&quot;</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">have</span> <span class="string">&quot;?BSET (set (e # es)) = {g y a |y a. y &isin; {e} &and; p y a} &cup;
                    {g y a |y a. y &isin; set es &and; p y a}&quot;</span> <span class="keyword1">using</span> Cons.prems<span class="delimiter">(</span>1<span class="delimiter">)</span> <span class="keyword1">by</span> auto 
                  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;?SSUM (?BSET (set (e # es))) =  
                    ?SSUM (?BSET {e}) + ?SSUM (?BSET (set es))&quot;</span> 
                    <span class="keyword1">using</span>  f<span class="delimiter">[</span>OF f1 f2 f3<span class="delimiter">]</span> <span class="keyword1">using</span> Cons.prems<span class="delimiter">(</span>1<span class="delimiter">)</span> <span class="keyword1">by</span> auto
                <span class="keyword1">}</span> <span class="keyword1">note</span> fct1 <span class="delimiter">=</span> this
                <span class="keyword1">{</span>
                  <span class="keyword1">have</span> f1<span class="delimiter">:</span> <span class="string">&quot;distinct es&quot;</span> <span class="keyword1">using</span> Cons.prems<span class="delimiter">(</span>1<span class="delimiter">)</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">have</span> f2<span class="delimiter">:</span> <span class="string">&quot;finite (set es)&quot;</span> <span class="keyword1">using</span> Cons.prems<span class="delimiter">(</span>2<span class="delimiter">)</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">have</span> <span class="string">&quot;?SSUM (?BSET (set es)) = (&sum;y&isin; (set es). (&sum;x&isin; {g y a | a. p y a}. f x))&quot;</span>
                    <span class="keyword1">using</span> Cons.IH<span class="delimiter">[</span>OF f1 f2 Cons.prems<span class="delimiter">(</span>3<span class="delimiter">)</span> Cons.prems<span class="delimiter">(</span>4<span class="delimiter">)</span><span class="delimiter">]</span> <span class="keyword1">by</span> blast
                <span class="keyword1">}</span> <span class="keyword1">note</span> fct2 <span class="delimiter">=</span> this
                <span class="keyword1">have</span> <span class="string">&quot;?SSUM (?BSET {e}) = (&sum;y&isin; {e}.(&sum;x&isin; {g y a | a. p y a}. f x))&quot;</span> <span class="keyword1">by</span> auto
                <span class="keyword3">show</span> <span class="var">?case</span> <span class="keyword1">using</span> fct1 fct2 Cons.prems<span class="delimiter">(</span>1<span class="delimiter">)</span> Cons.prems<span class="delimiter">(</span>2<span class="delimiter">)</span> <span class="keyword1">by</span> auto
            <span class="keyword1">qed</span>
        <span class="keyword1">}</span> <span class="keyword1">note</span> fct <span class="delimiter">=</span> this<span class="delimiter">[</span>of <span class="string">&quot;setExt.toList s&quot;</span><span class="delimiter">]</span>
        <span class="keyword1">let</span> <span class="var">?L</span> <span class="delimiter">=</span> <span class="string">&quot;setExt.toList s&quot;</span>
        <span class="keyword1">have</span> f1<span class="delimiter">:</span> <span class="string">&quot;distinct ?L&quot;</span> <span class="keyword1">using</span> setExt.toList_def
          <span class="keyword1">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>mono_tags<span class="delimiter">,</span> lifting<span class="delimiter">)</span> asm1 finite_distinct_list some_eq_ex<span class="delimiter">)</span>
        <span class="keyword1">have</span> f2<span class="delimiter">:</span> <span class="string">&quot;finite (set ?L)&quot;</span> <span class="keyword1">unfolding</span> setExt.toList_def <span class="keyword1">by</span> auto
        <span class="keyword3">show</span> <span class="var">?thesis</span> 
          <span class="keyword1">using</span> fct<span class="delimiter">[</span>OF f1 f2 asm2 asm3<span class="delimiter">]</span> <span class="keyword1">using</span> asm1 setExt.set_toList<span class="delimiter">[</span>of s<span class="delimiter">]</span> <span class="keyword1">by</span> auto
      <span class="keyword1">qed</span>      
      
    <span class="keyword1">lemma</span> decomp_3<span class="delimiter">:</span> <span class="string">&quot;finite A ==&gt; (&forall;x y a b. a &ne; b --&gt; g x a &ne; g y b) ==&gt;
      (&sum;e &isin; {g x y |y. y &isin; A}. f e) = (&sum;e &isin; {y |y. y &isin; A}. f (g x e))&quot;</span>
      <span class="keyword1">proof</span> <span class="delimiter">(</span>induction <span class="string">&quot;card A&quot;</span> arbitrary<span class="delimiter">:</span> A<span class="delimiter">)</span>
        <span class="keyword3">case</span> <span class="delimiter">(</span>0<span class="delimiter">)</span>
          <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">by</span> auto
      <span class="keyword1">next</span>
        <span class="keyword3">case</span> <span class="delimiter">(</span>Suc c<span class="delimiter">)</span>
          <span class="keyword1">let</span> <span class="var">?S_L</span> <span class="delimiter">=</span> <span class="string">&quot;&lambda;s. {g x y |y. y &isin; s}&quot;</span>
          <span class="keyword1">let</span> <span class="var">?S_R</span> <span class="delimiter">=</span> <span class="string">&quot;&lambda;s. {y |y. y &isin; s}&quot;</span>
          <span class="keyword1">let</span> <span class="var">?SUM_L</span> <span class="delimiter">=</span> <span class="string">&quot;&lambda;s. (&sum;e &isin; s. f e)&quot;</span>
          <span class="keyword1">let</span> <span class="var">?SUM_R</span> <span class="delimiter">=</span> <span class="string">&quot;&lambda;s. (&sum;e &isin; s. f (g x e))&quot;</span>
          <span class="keyword3">obtain</span> a as <span class="keyword2">where</span> obt<span class="delimiter">:</span> <span class="string">&quot;A = {a} &cup; as &and; a &notin; as&quot;</span>
            <span class="keyword1">using</span> Suc.hyps <span class="keyword1">by</span> <span class="delimiter">(</span>metis card_eq_SucD insert_is_Un<span class="delimiter">)</span>
          <span class="keyword1">{</span>
            <span class="keyword1">{</span>
              <span class="keyword1">have</span> f1<span class="delimiter">:</span> <span class="string">&quot;finite (?S_L {a})&quot;</span> <span class="keyword1">by</span> auto
              <span class="keyword1">have</span> f2<span class="delimiter">:</span> <span class="string">&quot;finite (?S_L as)&quot;</span> <span class="keyword1">using</span> Suc.prems<span class="delimiter">(</span>1<span class="delimiter">)</span> obt <span class="keyword1">by</span> auto
              <span class="keyword1">have</span> f3<span class="delimiter">:</span> <span class="string">&quot;?S_L {a} &cap; ?S_L as = {}&quot;</span>
                <span class="keyword1">proof</span> <span class="delimiter">(</span>rule ccontr<span class="delimiter">)</span>
                  <span class="keyword3">assume</span> <span class="string">&quot;&not; ?S_L {a} &cap; ?S_L as = {}&quot;</span>
                  <span class="keyword1">then</span> <span class="keyword3">obtain</span> y1 y2 <span class="keyword2">where</span> s_obt<span class="delimiter">:</span>  <span class="string">&quot;g x y1 = g x y2 &and; g x y1 &isin; ?S_L {a} &and; y1 &isin; {a} &and;
                    g x y2 &isin; ?S_L as &and; y2 &isin; as&quot;</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;y1 = y2&quot;</span> <span class="keyword1">using</span> Suc.prems<span class="delimiter">(</span>2<span class="delimiter">)</span> <span class="keyword1">by</span> auto
                  <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;a &isin; as&quot;</span> <span class="keyword1">using</span> s_obt <span class="keyword1">by</span> auto
                  <span class="keyword3">thus</span> <span class="string">&quot;False&quot;</span> <span class="keyword1">using</span> obt <span class="keyword1">by</span> auto
                <span class="keyword1">qed</span>
                
              <span class="keyword1">note</span> setsum.union_disjoint<span class="delimiter">[</span>OF f1 f2 f3<span class="delimiter">]</span>
            <span class="keyword1">}</span>
            <span class="keyword1">note</span> this
            <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;?S_L ({a} &cup; as) = ?S_L {a} &cup; ?S_L as&quot;</span> <span class="keyword1">using</span> obt <span class="keyword1">by</span> auto  
            <span class="keyword1">ultimately</span> <span class="keyword1">have</span> 
              <span class="string">&quot;?SUM_L (?S_L A) = ?SUM_L (?S_L {a}) + ?SUM_L (?S_L as)&quot;</span> <span class="keyword1">using</span> obt <span class="keyword1">by</span> auto
          <span class="keyword1">}</span>
          <span class="keyword1">moreover</span> <span class="keyword1">{</span>
            <span class="keyword1">have</span> <span class="string">&quot;?SUM_L (?S_L {a}) = ?SUM_R (?S_R {a})&quot;</span> <span class="keyword1">by</span> auto
          <span class="keyword1">}</span> 
          <span class="keyword1">moreover</span> <span class="keyword1">{</span>          
            <span class="keyword1">have</span> f1<span class="delimiter">:</span> <span class="string">&quot;c = card as&quot;</span> <span class="keyword1">using</span> Suc.prems<span class="delimiter">(</span>1<span class="delimiter">)</span> Suc.hyps<span class="delimiter">(</span>2<span class="delimiter">)</span> obt
              <span class="keyword1">by</span> <span class="delimiter">(</span>metis card_0_eq card_Suc_eq diff_Suc_Suc diff_zero finite_insert insert_is_Un<span class="delimiter">)</span>
            <span class="keyword1">have</span> f2<span class="delimiter">:</span> <span class="string">&quot;finite as&quot;</span> <span class="keyword1">using</span> Suc.prems<span class="delimiter">(</span>1<span class="delimiter">)</span> obt <span class="keyword1">by</span> auto
            
            <span class="keyword1">note</span> Suc.hyps<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">[</span>OF f1 f2 Suc.prems<span class="delimiter">(</span>2<span class="delimiter">)</span><span class="delimiter">]</span>
          <span class="keyword1">}</span>
          <span class="keyword1">moreover</span> <span class="keyword1">{</span>
            <span class="keyword1">{</span>
              <span class="keyword1">have</span> f1<span class="delimiter">:</span> <span class="string">&quot;finite (?S_R {a})&quot;</span> <span class="keyword1">by</span> auto
              <span class="keyword1">have</span> f2<span class="delimiter">:</span> <span class="string">&quot;finite (?S_R as)&quot;</span> <span class="keyword1">using</span> Suc.prems<span class="delimiter">(</span>1<span class="delimiter">)</span> obt <span class="keyword1">by</span> auto
              <span class="keyword1">have</span> f3<span class="delimiter">:</span> <span class="string">&quot;?S_R {a} &cap; ?S_R as = {}&quot;</span> <span class="keyword1">using</span> obt <span class="keyword1">by</span> auto
              
              <span class="keyword1">note</span> setsum.union_disjoint<span class="delimiter">[</span>OF f1 f2 f3<span class="delimiter">]</span>
            <span class="keyword1">}</span>
            <span class="keyword1">note</span> this<span class="delimiter">[</span>of <span class="string">&quot;&lambda;e. f (g x e)&quot;</span><span class="delimiter">]</span>
            <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;?S_R {a} &cup; ?S_R as = ?S_R A&quot;</span> <span class="keyword1">using</span> obt <span class="keyword1">by</span> auto
            <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;?SUM_R (?S_R {a}) + ?SUM_R (?S_R as) = ?SUM_R (?S_R A)&quot;</span> <span class="keyword1">by</span> auto
          <span class="keyword1">}</span> 
          <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?case</span> <span class="keyword1">by</span> auto
      <span class="keyword1">qed</span>
    
    <span class="keyword1">lemma</span> decomp_4<span class="delimiter">:</span> <span class="string">&quot;finite s ==&gt; &forall;x &isin; s. f x = a ==&gt; (&sum;x &isin; s. f x) = (&sum;y &isin; {n. n &lt; (card s)}. a)&quot;</span>
      <span class="keyword1">proof</span> <span class="delimiter">(</span>induction <span class="string">&quot;card s&quot;</span> arbitrary<span class="delimiter">:</span> s<span class="delimiter">)</span>
        <span class="keyword3">case</span> 0
          <span class="keyword3">thus</span> <span class="var">?case</span> <span class="keyword1">by</span> auto
      <span class="keyword1">next</span>
        <span class="keyword3">case</span> <span class="delimiter">(</span>Suc c<span class="delimiter">)</span>
          <span class="keyword1">let</span> <span class="var">?SUM_L</span> <span class="delimiter">=</span> <span class="string">&quot;&lambda;s. (&sum;e &isin; s. f e)&quot;</span>
          <span class="keyword3">obtain</span> b bs <span class="keyword2">where</span> obt<span class="delimiter">:</span> <span class="string">&quot;s = {b} &cup; bs &and; b &notin; bs&quot;</span>
            <span class="keyword1">using</span> Suc.hyps <span class="keyword1">by</span> <span class="delimiter">(</span>metis card_eq_SucD insert_is_Un<span class="delimiter">)</span>
          <span class="keyword1">{</span>
            <span class="keyword1">{</span>
              <span class="keyword1">have</span> f1<span class="delimiter">:</span> <span class="string">&quot;finite {b}&quot;</span> <span class="keyword1">by</span> auto
              <span class="keyword1">have</span> f2<span class="delimiter">:</span> <span class="string">&quot;finite bs&quot;</span> <span class="keyword1">using</span> Suc.prems<span class="delimiter">(</span>1<span class="delimiter">)</span> obt <span class="keyword1">by</span> auto
              <span class="keyword1">have</span> f3<span class="delimiter">:</span> <span class="string">&quot;{b} &cap; bs = {}&quot;</span> <span class="keyword1">using</span> obt <span class="keyword1">by</span> auto
              
              <span class="keyword1">note</span> setsum.union_disjoint<span class="delimiter">[</span>OF f1 f2 f3<span class="delimiter">]</span>
            <span class="keyword1">}</span>
            <span class="keyword1">note</span> this<span class="delimiter">[</span>of f<span class="delimiter">]</span>
            <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;{b} &cup; bs = s&quot;</span> <span class="keyword1">using</span> obt <span class="keyword1">by</span> auto  
            <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;?SUM_L s = ?SUM_L {b} + ?SUM_L bs&quot;</span> <span class="keyword1">using</span> obt <span class="keyword1">by</span> auto
          <span class="keyword1">}</span>
          <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;?SUM_L {b} = a&quot;</span> <span class="keyword1">using</span> obt Suc.prems<span class="delimiter">(</span>2<span class="delimiter">)</span> <span class="keyword1">by</span> auto
          <span class="keyword1">moreover</span> <span class="keyword1">{</span>
            <span class="keyword1">have</span> f1<span class="delimiter">:</span> <span class="string">&quot;c = card bs&quot;</span> <span class="keyword1">using</span> Suc.prems<span class="delimiter">(</span>1<span class="delimiter">)</span> Suc.hyps<span class="delimiter">(</span>2<span class="delimiter">)</span> obt
              <span class="keyword1">by</span> <span class="delimiter">(</span>metis card_0_eq card_Suc_eq diff_Suc_Suc diff_zero finite_insert insert_is_Un<span class="delimiter">)</span>
            <span class="keyword1">have</span> f2<span class="delimiter">:</span> <span class="string">&quot;finite bs&quot;</span> <span class="keyword1">using</span> Suc.prems<span class="delimiter">(</span>1<span class="delimiter">)</span> obt <span class="keyword1">by</span> auto
            <span class="keyword1">have</span> f3<span class="delimiter">:</span> <span class="string">&quot; &forall;x &isin; bs. f x = a&quot;</span> <span class="keyword1">using</span> obt Suc.prems<span class="delimiter">(</span>2<span class="delimiter">)</span> <span class="keyword1">by</span> auto
            <span class="keyword1">note</span> Suc.hyps<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">[</span>OF f1 f2 f3<span class="delimiter">]</span>
            
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;setsum f bs = (&sum;y&isin;{n. n &lt; c}. a)&quot;</span> <span class="keyword1">using</span> f1 <span class="keyword1">by</span> simp
          <span class="keyword1">}</span>
          <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;?SUM_L s = a + (&sum;y&isin;{n. n &lt; c}. a)&quot;</span> <span class="keyword1">by</span> auto
          <span class="keyword1">moreover</span> <span class="keyword1">{</span>
            <span class="keyword1">have</span> <span class="string">&quot;{c} &cup; {n. n &lt; c} = {n. n &lt; c + 1}&quot;</span> <span class="keyword1">by</span> auto
            <span class="keyword1">then</span> <span class="keyword1">have</span> <span class="string">&quot;(&sum;x&isin;{c} &cup; {n. n &lt; c}. a) = (&sum;x&isin;{n. n &lt; c + 1}. a)&quot;</span> <span class="keyword1">by</span> simp
            <span class="keyword1">moreover</span> <span class="keyword1">{</span>
              <span class="keyword1">have</span> f1<span class="delimiter">:</span> <span class="string">&quot;finite {c}&quot;</span> <span class="keyword1">by</span> simp
              <span class="keyword1">have</span> f2<span class="delimiter">:</span> <span class="string">&quot;finite {n. n &lt; c}&quot;</span> <span class="keyword1">by</span> simp
              <span class="keyword1">have</span> f3<span class="delimiter">:</span> <span class="string">&quot;{c} &cap; {n. n &lt; c} = {}&quot;</span> <span class="keyword1">by</span> simp
              
              <span class="keyword1">note</span> setsum.union_disjoint<span class="delimiter">[</span>OF f1 f2 f3<span class="delimiter">]</span>
              <span class="keyword1">note</span> this<span class="delimiter">[</span>of <span class="string">&quot;&lambda;x. a&quot;</span><span class="delimiter">]</span>
            <span class="keyword1">}</span>
            <span class="keyword1">moreover</span> <span class="keyword1">have</span> <span class="string">&quot;(&sum;x&isin;{c}. a) = a&quot;</span> <span class="keyword1">by</span> simp
            <span class="keyword1">ultimately</span> <span class="keyword1">have</span> <span class="string">&quot;a + (&sum;x&isin;{n. n &lt; c}. a) = (&sum;x&isin;{n. n &lt; c + 1}. a)&quot;</span> <span class="keyword1">by</span> simp
          <span class="keyword1">}</span>
          <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?case</span> <span class="keyword1">using</span> Suc.hyps<span class="delimiter">(</span>2<span class="delimiter">)</span> <span class="keyword1">by</span> auto 
      <span class="keyword1">qed</span>
   <span class="keyword2">end</span>





  <span class="comment">(* TODO: Miscellaneous General Stuff *)</span>
  <span class="keyword1">lemma</span> remove_subset<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;x&isin;S ==&gt; S-{x} &sub; S&quot;</span> <span class="keyword1">by</span> auto

  <span class="keyword1">lemma</span> fun_neq_ext_iff<span class="delimiter">:</span> <span class="string">&quot;m&ne;m&#39; &lt;-&gt; (&exist;x. m x &ne; m&#39; x)&quot;</span> <span class="keyword1">by</span> auto  


  <span class="comment">(* TODO: Move to Misc *)</span>
  <span class="keyword1">lemma</span> length_Suc_rev_conv<span class="delimiter">:</span> <span class="string">&quot;length xs = Suc n &lt;-&gt; (&exist;ys y. xs=ys@[y] &and; length ys = n)&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>cases xs rule<span class="delimiter">:</span> rev_cases<span class="delimiter">)</span> auto


  <span class="keyword1">lemma</span> zero_comp_diff_simps<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> 
    <span class="string">&quot;(0::&#39;a::linordered_idom) &le; a - b &lt;-&gt; b &le; a&quot;</span> 
    <span class="string">&quot;(0::&#39;a::linordered_idom) &lt; a - b &lt;-&gt; b &lt; a&quot;</span> 
    <span class="keyword1">by</span> auto

  <span class="comment">(* TODO: Move: Misc, or even HOL/Finite_set *)</span>  
  <span class="keyword1">lemma</span> <span class="delimiter">(</span><span class="keyword2">in</span> -<span class="delimiter">)</span> card_inverse<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;card (R&macr;) = card R&quot;</span>
  <span class="keyword1">proof</span> -
    <span class="keyword1">have</span> <span class="string">&quot;finite (R&macr;) &lt;-&gt; finite R&quot;</span> <span class="keyword1">by</span> auto
    <span class="keyword1">have</span> <span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;!!R. prod.swap`R = R&macr;&quot;</span> <span class="keyword1">by</span> auto
    <span class="keyword1">{</span>
      <span class="keyword3">assume</span> <span class="string">&quot;&not;finite R&quot;</span>
      <span class="keyword1">hence</span> <span class="var">?thesis</span>
        <span class="keyword1">by</span> auto
    <span class="keyword1">}</span> <span class="keyword1">moreover</span> <span class="keyword1">{</span>
      <span class="keyword3">assume</span> <span class="string">&quot;finite R&quot;</span>
      <span class="keyword1">with</span> card_image_le<span class="delimiter">[</span>of R prod.swap<span class="delimiter">]</span> card_image_le<span class="delimiter">[</span>of <span class="string">&quot;R&macr;&quot;</span> prod.swap<span class="delimiter">]</span>
      <span class="keyword1">have</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
    <span class="keyword1">}</span> <span class="keyword1">ultimately</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">by</span> blast
  <span class="keyword1">qed</span>  


  <span class="comment">(* TODO: Elaborate and move to Misc, or HOL *)</span>
  <span class="keyword1">text</span> <span class="cartouche">&#8249;Map update at multiple keys&#8250;</span>
  <span class="keyword1">definition</span> <span class="string">&quot;map_mmupd m K v k &equiv; if k&isin;K then Some v else m k&quot;</span>
  <span class="keyword1">lemma</span> map_mmupd_empty<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;map_mmupd m {} v = m&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> map_mmupd_def<span class="delimiter">)</span>

  <span class="keyword1">lemma</span> mmupd_in_upd<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;k&isin;K ==&gt; map_mmupd m K v k = Some v&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> map_mmupd_def<span class="delimiter">)</span>

  <span class="keyword1">lemma</span> mmupd_notin_upd<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;k&notin;K ==&gt; map_mmupd m K v k = m k&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> map_mmupd_def<span class="delimiter">)</span>

  <span class="keyword1">lemma</span> map_mmupdE<span class="delimiter">:</span>
    <span class="keyword2">assumes</span> <span class="string">&quot;map_mmupd m K v k = Some x&quot;</span>
    <span class="keyword2">obtains</span> <span class="string">&quot;k&notin;K&quot;</span> <span class="string">&quot;m k = Some x&quot;</span>
          <span class="delimiter">|</span> <span class="string">&quot;k&isin;K&quot;</span> <span class="string">&quot;x=v&quot;</span>
    <span class="keyword1">using</span> assms <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> map_mmupd_def split<span class="delimiter">:</span> split_if_asm<span class="delimiter">)</span>      

  <span class="keyword1">lemma</span> dom_mmupd<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;dom (map_mmupd m K v) = dom m &cup; K&quot;</span>  
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> map_mmupd_def split<span class="delimiter">:</span> split_if_asm<span class="delimiter">)</span>      

  <span class="comment">(* TODO: Move *)</span>
  <span class="keyword1">lemma</span> le_map_mmupd_not_dom<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;m &sube;<span class="hidden">&#8681;</span><sub>m</sub> map_mmupd m (K-dom m) v&quot;</span> 
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> map_le_def<span class="delimiter">)</span>

  <span class="keyword1">lemma</span> map_mmupd_update_less<span class="delimiter">:</span> <span class="string">&quot;K&sube;K&#39; ==&gt; map_mmupd m (K - dom m) v &sube;<span class="hidden">&#8681;</span><sub>m</sub> map_mmupd m (K&#39;-dom m) v&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> map_le_def map_mmupd_def<span class="delimiter">)</span>

  <span class="comment">(* TODO: Move *)</span>
  <span class="keyword1">text</span> <span class="cartouche">&#8249;Lexicographic measure, assuming upper bound for second component&#8250;</span>
  <span class="keyword1">lemma</span> mlex_fst_decrI<span class="delimiter">:</span>
    <span class="keyword2">fixes</span> a a&#39; b b&#39; N <span class="delimiter">::</span> nat
    <span class="keyword2">assumes</span> <span class="string">&quot;a&lt;a&#39;&quot;</span>
    <span class="keyword2">assumes</span> <span class="string">&quot;b&lt;N&quot;</span> <span class="string">&quot;b&#39;&lt;N&quot;</span>
    <span class="keyword2">shows</span> <span class="string">&quot;a*N + b &lt; a&#39;*N + b&#39;&quot;</span>
  <span class="keyword1">proof</span> -  
    <span class="keyword1">have</span> <span class="string">&quot;a*N + b + 1 &le; a*N + N&quot;</span> <span class="keyword1">using</span> <span class="cartouche">&#8249;b&lt;N&#8250;</span> <span class="keyword1">by</span> linarith 
    <span class="keyword1">also</span> <span class="keyword1">have</span> <span class="string">&quot;&hellip; &le; a&#39;*N&quot;</span> <span class="keyword1">using</span> <span class="cartouche">&#8249;a&lt;a&#39;&#8250;</span>
      <span class="keyword1">by</span> <span class="delimiter">(</span>metis Suc_leI ab_semigroup_add_class.add.commute 
        ab_semigroup_mult_class.mult.commute mult_Suc_right mult_le_mono2<span class="delimiter">)</span> 
    <span class="keyword1">also</span> <span class="keyword1">have</span> <span class="string">&quot;&hellip; &le; a&#39;*N + b&#39;&quot;</span> <span class="keyword1">by</span> auto
    <span class="keyword1">finally</span> <span class="keyword3">show</span> <span class="var">?thesis</span> <span class="keyword1">by</span> auto
  <span class="keyword1">qed</span>      
    
  <span class="keyword1">lemma</span> mlex_leI<span class="delimiter">:</span>
    <span class="keyword2">fixes</span> a a&#39; b b&#39; N <span class="delimiter">::</span> nat
    <span class="keyword2">assumes</span> <span class="string">&quot;a&le;a&#39;&quot;</span>
    <span class="keyword2">assumes</span> <span class="string">&quot;b&le;b&#39;&quot;</span>
    <span class="keyword2">shows</span> <span class="string">&quot;a*N + b &le; a&#39;*N + b&#39;&quot;</span>
    <span class="keyword1">using</span> assms
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto intro<span class="delimiter">!</span><span class="delimiter">:</span> add_mono<span class="delimiter">)</span>
      
  <span class="keyword1">lemma</span> mlex_snd_decrI<span class="delimiter">:</span>
    <span class="keyword2">fixes</span> a a&#39; b b&#39; N <span class="delimiter">::</span> nat
    <span class="keyword2">assumes</span> <span class="string">&quot;a=a&#39;&quot;</span>
    <span class="keyword2">assumes</span> <span class="string">&quot;b&lt;b&#39;&quot;</span>
    <span class="keyword2">shows</span> <span class="string">&quot;a*N + b &lt; a&#39;*N + b&#39;&quot;</span>
    <span class="keyword1">using</span> assms
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto<span class="delimiter">)</span>

  <span class="keyword1">lemma</span> mlex_bound<span class="delimiter">:</span>  
    <span class="keyword2">fixes</span> a b <span class="delimiter">::</span> nat
    <span class="keyword2">assumes</span> <span class="string">&quot;a&lt;A&quot;</span>
    <span class="keyword2">assumes</span> <span class="string">&quot;b&lt;N&quot;</span>
    <span class="keyword2">shows</span> <span class="string">&quot;a*N + b &lt; A*N&quot;</span>
    <span class="keyword1">using</span> assms
    <span class="keyword1">using</span> mlex_fst_decrI <span class="keyword1">by</span> fastforce


  <span class="comment">(* TODO: Move to Misc, close to finite_psupset, theme: termination orderings *)</span>
  <span class="keyword1">definition</span> <span class="string">&quot;less_than_bool &equiv; {(a,b). a&lt;(b::bool)}&quot;</span>
  <span class="keyword1">lemma</span> wf_less_than_bool<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;wf (less_than_bool)&quot;</span>
    <span class="keyword1">unfolding</span> less_than_bool_def
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> wf_def<span class="delimiter">)</span>
  <span class="keyword1">lemma</span> less_than_bool_iff<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span>
    <span class="string">&quot;(x,y)&isin;less_than_bool &lt;-&gt; x=False &and; y=True&quot;</span>  
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> less_than_bool_def<span class="delimiter">)</span>

  <span class="keyword1">definition</span> <span class="string">&quot;greater_bounded N &equiv; inv_image less_than (&lambda;x. N-x)&quot;</span> 
  <span class="keyword1">lemma</span> wf_greater_bounded<span class="delimiter">[</span>simp<span class="delimiter">,</span> intro<span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;wf (greater_bounded N)&quot;</span> <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> greater_bounded_def<span class="delimiter">)</span>

  <span class="keyword1">lemma</span> greater_bounded_Suc_iff<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;(Suc x,x)&isin;greater_bounded N &lt;-&gt; Suc x &le; N&quot;</span>
    <span class="keyword1">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> greater_bounded_def<span class="delimiter">)</span>







<span class="keyword2">end</span></pre>

</div>
</body>
</html>
